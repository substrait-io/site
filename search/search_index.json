{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Substrait: Cross-Language Serialization for Relational Algebra \u00b6 Project Vision \u00b6 Create a well-defined, cross-language specification for data compute operations. This includes a declaration of common operations, custom operations and one or more serialized representations of this specification. The spec focuses on the semantics of each operation and a consistent way to describe. In many ways, the goal of this project is similar to that of the Apache Arrow project. Arrow is focused on a standardized memory representation of columnar data. Substrait is focused on what should be done to data. Example Use Cases \u00b6 Communicate a compute plan between a SQL parser and an execution engine (e.g. Calcite SQL parsing to Arrow C++ compute kernel) Serialize a plan that represents a SQL view for consistent use in multiple systems (e.g. Iceberg views in Spark and Trino) Submit a plan to different execution engines (e.g. Datafusion and Postgres) and get a consistent interpretation of the semantics. Create an alternative plan generation implementation that can connect an existing end-user compute expression system to an existing end-user processing engine (e.g. Pandas operations executed inside SingleStore) Build a pluggable plan visualization tool (e.g. D3 based plan visualizer) Community Principles \u00b6 Be inclusive and open to all. If you want to join the project, open a PR or issue , start a discussion or join the Slack Channel . Ensure a diverse set of contributors that come from multiple data backgrounds to maximize general utility. Build a specification based on open consensus. Avoid over-reliance/coupling to any single technology. Make the specification and all tools freely available on a permissive license (ApacheV2) Related Technologies \u00b6 Apache Calcite : Many ideas in Substrait are inspired by the Calcite project. Calcite is a great JVM-based SQL query parsing and optimization framework. A key goal of the Substrait project is to expose Calcite capabilities more easily to non-JVM technologies as well as expose query planning operations as microservices. Apache Arrow : The Arrow format for data is what the Substrait specification attempts to be for compute expressions. A key goal of Substrait is to enable Substrait producers to execute work within the Arrow Rust and C++ compute kernels. Why not use SQL? \u00b6 SQL is a well known language for describing queries against relational data. It is designed to be simple and allow reading and writing by humans. Substrait is not intended as a replacement for SQL and works alongside SQL to provide capabilities that SQL lacks. SQL is not a great fit for systems that actually satisfy the query because it does not provide sufficient detail and is not represented in a format that is easy for processing. Because of this, most modern systems will first translate the SQL query into a query plan, sometimes called the execution plan. There can be multiple levels of a query plan (e.g. physical and logical), a query plan may be split up and distributed across multiple systems, and a query plan often undergoes simplifying or optimizing transformations. The SQL standard does not define the format of the query or execution plan and there is no open format that is supported by a broad set of systems. Substrait was created to provide a standard and open format for these query plans. Why not just do this within an existing OSS project? \u00b6 A key goal of the Substrait project is to not be coupled to any single existing technology. Trying to get people involved in something can be difficult when it seems to be primarily driven by the opinions and habits of a single community. In many ways, this situation is similar to the early situation with Arrow. The precursor to Arrow was the Apache Drill ValueVectors concepts. As part of creating Arrow, Wes and Jacques recognized the need to create a new community to build a fresh consensus (beyond just what the Apache Drill community wanted). This separation and new independent community was a key ingredient to Arrow\u2019s current success. The needs here are much the same: many separate communities could benefit from Substrait, but each have their own pain points, type systems, development processes and timelines. To help resolve these tensions, one of the approaches proposed in Substrait is to set a bar that at least two of the top four OSS data technologies (Arrow, Spark, Iceberg, Trino) supports something before incorporating it directly into the Substrait specification. (Another goal is to support strong extension points at key locations to avoid this bar being a limiter to broad adoption.) Why the name Substrait? \u00b6 A strait is a narrow connector of water between two other pieces of water. In analytics, data is often thought of as water. Substrait is focused on instructions related to the data. In other words, what defines or supports the movement of water between one or more larger systems. Thus, the underlayment for the strait connecting different pools of water => sub-strait.","title":"Home"},{"location":"#substrait-cross-language-serialization-for-relational-algebra","text":"","title":"Substrait: Cross-Language Serialization for Relational Algebra"},{"location":"#project-vision","text":"Create a well-defined, cross-language specification for data compute operations. This includes a declaration of common operations, custom operations and one or more serialized representations of this specification. The spec focuses on the semantics of each operation and a consistent way to describe. In many ways, the goal of this project is similar to that of the Apache Arrow project. Arrow is focused on a standardized memory representation of columnar data. Substrait is focused on what should be done to data.","title":"Project Vision"},{"location":"#example-use-cases","text":"Communicate a compute plan between a SQL parser and an execution engine (e.g. Calcite SQL parsing to Arrow C++ compute kernel) Serialize a plan that represents a SQL view for consistent use in multiple systems (e.g. Iceberg views in Spark and Trino) Submit a plan to different execution engines (e.g. Datafusion and Postgres) and get a consistent interpretation of the semantics. Create an alternative plan generation implementation that can connect an existing end-user compute expression system to an existing end-user processing engine (e.g. Pandas operations executed inside SingleStore) Build a pluggable plan visualization tool (e.g. D3 based plan visualizer)","title":"Example Use Cases"},{"location":"#community-principles","text":"Be inclusive and open to all. If you want to join the project, open a PR or issue , start a discussion or join the Slack Channel . Ensure a diverse set of contributors that come from multiple data backgrounds to maximize general utility. Build a specification based on open consensus. Avoid over-reliance/coupling to any single technology. Make the specification and all tools freely available on a permissive license (ApacheV2)","title":"Community Principles"},{"location":"#related-technologies","text":"Apache Calcite : Many ideas in Substrait are inspired by the Calcite project. Calcite is a great JVM-based SQL query parsing and optimization framework. A key goal of the Substrait project is to expose Calcite capabilities more easily to non-JVM technologies as well as expose query planning operations as microservices. Apache Arrow : The Arrow format for data is what the Substrait specification attempts to be for compute expressions. A key goal of Substrait is to enable Substrait producers to execute work within the Arrow Rust and C++ compute kernels.","title":"Related Technologies"},{"location":"#why-not-use-sql","text":"SQL is a well known language for describing queries against relational data. It is designed to be simple and allow reading and writing by humans. Substrait is not intended as a replacement for SQL and works alongside SQL to provide capabilities that SQL lacks. SQL is not a great fit for systems that actually satisfy the query because it does not provide sufficient detail and is not represented in a format that is easy for processing. Because of this, most modern systems will first translate the SQL query into a query plan, sometimes called the execution plan. There can be multiple levels of a query plan (e.g. physical and logical), a query plan may be split up and distributed across multiple systems, and a query plan often undergoes simplifying or optimizing transformations. The SQL standard does not define the format of the query or execution plan and there is no open format that is supported by a broad set of systems. Substrait was created to provide a standard and open format for these query plans.","title":"Why not use SQL?"},{"location":"#why-not-just-do-this-within-an-existing-oss-project","text":"A key goal of the Substrait project is to not be coupled to any single existing technology. Trying to get people involved in something can be difficult when it seems to be primarily driven by the opinions and habits of a single community. In many ways, this situation is similar to the early situation with Arrow. The precursor to Arrow was the Apache Drill ValueVectors concepts. As part of creating Arrow, Wes and Jacques recognized the need to create a new community to build a fresh consensus (beyond just what the Apache Drill community wanted). This separation and new independent community was a key ingredient to Arrow\u2019s current success. The needs here are much the same: many separate communities could benefit from Substrait, but each have their own pain points, type systems, development processes and timelines. To help resolve these tensions, one of the approaches proposed in Substrait is to set a bar that at least two of the top four OSS data technologies (Arrow, Spark, Iceberg, Trino) supports something before incorporating it directly into the Substrait specification. (Another goal is to support strong extension points at key locations to avoid this bar being a limiter to broad adoption.)","title":"Why not just do this within an existing OSS project?"},{"location":"#why-the-name-substrait","text":"A strait is a narrow connector of water between two other pieces of water. In analytics, data is often thought of as water. Substrait is focused on instructions related to the data. In other words, what defines or supports the movement of water between one or more larger systems. Thus, the underlayment for the strait connecting different pools of water => sub-strait.","title":"Why the name Substrait?"},{"location":"governance/","text":"Substrait Project Governance \u00b6 The Substrait project is run by volunteers in a collaborative and open way. Its governance is inspired by the Apache Software Foundation. In most cases, people familiar with the ASF model can work with Substrait in the same way. The biggest differences between the models are: Substrait does not have a separate infrastructure governing body that gatekeeps the adoption of new developer tools and technologies. Substrait Management Committee (SMC) members are responsible for recognizing the corporate relationship of its members and ensuring diverse representation and corporate independence. Substrait does not condone private mailing lists. All project business should be discussed in public The only exceptions to this are security escalations ( security@substrait.io ) and harassment ( harassment@substrait.io ). Substrait has an automated continuous release process with no formal voting process per release. More details about concrete things Substrait looks to avoid can be found below. The Substrait Project \u00b6 The Substrait project consists of the code and repositories that reside in the substrait-io GitHub organization , the Substrait.io website , the Substrait mailing list , MS-hosted teams community calls and the Substrait Slack workspace . (All are open to everyone and recordings/transcripts are made where technology supports it.) Substrait Volunteers \u00b6 We recognize four groups of individuals related to the project. User \u00b6 A user is someone who uses Substrait. They may contribute to Substrait by providing feedback to developers in the form of bug reports and feature suggestions. Users participate in the Substrait community by helping other users on mailing lists and user support forums. Contributors \u00b6 A contributor is a user who contributes to the project in the form of code or documentation. They take extra steps to participate in the project (loosely defined as the set of repositories under the github substrait-io organization) , are active on the developer mailing list, participate in discussions, and provide patches, documentation, suggestions, and criticism. Committer \u00b6 A committer is a developer who has write access to the code repositories and has a signed Contributor License Agreement (CLA) on file. Not needing to depend on other people to make patches to the code or documentation, they are actually making short-term decisions for the project. The SMC can (even tacitly) agree and approve the changes into permanency, or they can reject them. Remember that the SMC makes the decisions, not the individual committers. SMC Member \u00b6 A SMC member is a committer who was elected due to merit for the evolution of the project. They have write access to the code repository, the right to cast binding votes on all proposals on community-related decisions,the right to propose other active contributors for committership, and the right to invite active committers to the SMC. The SMC as a whole is the entity that controls the project, nobody else. They are responsible for the continued shaping of this governance model. Substrait Management and Collaboration \u00b6 The Substrait project is managed using a collaborative, consensus-based process. We do not have a hierarchical structure; rather, different groups of contributors have different rights and responsibilities in the organization. Communication \u00b6 Communication must be done via mailing lists, Slack, and/or Github. Communication is always done publicly. There are no private lists and all decisions related to the project are made in public. Communication is frequently done asynchronously since members of the community are distributed across many time zones. Substrait Management Committee \u00b6 The Substrait Management Committee is responsible for the active management of Substrait. The main role of the SMC is to further the long-term development and health of the community as a whole, and to ensure that balanced and wide scale peer review and collaboration takes place. As part of this, the SMC is the primary approver of specification changes, ensuring that proposed changes represent a balanced and thorough examination of possibilities. This doesn\u2019t mean that the SMC has to be involved in the minutiae of a particular specification change but should always shepard a healthy process around specification changes. Substrait Voting Process \u00b6 Because one of the fundamental aspects of accomplishing things is doing so by consensus, we need a way to tell whether we have reached consensus. We do this by voting. There are several different types of voting. In all cases, it is recommended that all community members vote. The number of binding votes required to move forward and the community members who have \u201cbinding\u201d votes differs depending on the type of proposal made. In all cases, a veto of a binding voter results in an inability to move forward. The rules require that a community member registering a negative vote must include an alternative proposal or a detailed explanation of the reasons for the negative vote. The community then tries to gather consensus on an alternative proposal that can resolve the issue. In the great majority of cases, the concerns leading to the negative vote can be addressed. This process is called \u201cconsensus gathering\u201d and we consider it a very important indication of a healthy community. +1 votes required Binding voters Voting Location Process/Governance modifications & actions. This includes promoting new contributors to committer or SMC. 3 SMC Mailing List Format/Specification Modifications (including breaking extension changes) 2 SMC Github PR Non-breaking function introductions 1 (not including proposer) Committers Github PR Non-breaking extension additions & non-format code modifications 1 (not including proposer) Committers Github PR Review-Then-Commit \u00b6 Substrait follows a review-then-commit policy. This requires that all changes receive consensus approval before being committed to the code base. The specific vote requirements follow the table above. Expressing Votes \u00b6 The voting process may seem more than a little weird if you\u2019ve never encountered it before. Votes are represented as numbers between -1 and +1, with \u2018-1\u2019 meaning \u2018no\u2019 and \u2018+1\u2019 meaning \u2018yes.\u2019 The in-between values indicate how strongly the voting individual feels. Here are some examples of fractional votes and what the voter might be communicating with them: +0: \u2018I don\u2019t feel strongly about it, but I\u2019m okay with this.\u2019 -0: \u2018I won\u2019t get in the way, but I\u2019d rather we didn\u2019t do this.\u2019 -0.5: \u2018I don\u2019t like this idea, but I can\u2019t find any rational justification for my feelings.\u2019 ++1: \u2018Wow! I like this! Let\u2019s do it!\u2019 -0.9: \u2018I really don\u2019t like this, but I\u2019m not going to stand in the way if everyone else wants to go ahead with it.\u2019 +0.9: \u2018This is a cool idea and I like it, but I don\u2019t have time/the skills necessary to help out.\u2019 Votes on Code Modification \u00b6 For code-modification votes, +1 votes (review approvals in Github are considered equivalent to a +1) are in favor of the proposal, but -1 votes are vetoes and kill the proposal dead until all vetoers withdraw their -1 votes. Vetoes \u00b6 A -1 (or an unaddressed PR request for changes) vote by a qualified voter stops a code-modification proposal in its tracks. This constitutes a veto, and it cannot be overruled nor overridden by anyone. Vetoes stand until and unless the individual withdraws their veto. To prevent vetoes from being used capriciously, the voter must provide with the veto a technical or community justification showing why the change is bad. Why do we vote? \u00b6 Votes help us to openly resolve conflicts. Without a process, people tend to avoid conflict and thrash around. Votes help to make sure we do the hard work of resolving the conflict. Substrait is non-commercial but commercially-aware \u00b6 Substrait\u2019s mission is to produce software for the public good. All Substrait software is always available for free, and solely under the Apache License. We\u2019re happy to have third parties, including for-profit corporations, take our software and use it for their own purposes. However it is important in these cases to ensure that the third party does not misuse the brand and reputation of the Substrait project for its own purposes. It is important for the longevity and community health of Substrait that the community gets the appropriate credit for producing freely available software. The SMC actively track the corporate allegiances of community members and strives to ensure influence around any particular aspect of the project isn\u2019t overly skewed towards a single corporate entity. Substrait Trademark \u00b6 The SMC is responsible for protecting the Substrait name and brand. TBD what action is taken to support this. Project Roster \u00b6 Substrait Management Committee (SMC) \u00b6 Name Association Phillip Cloud Voltron Data Weston Pace Voltron Data Jacques Nadeau Sundeck Substrait Committers \u00b6 Name Association Jeroen van Straten Voltron Data Carlo Curino Microsoft James Taylor Sundeck Sutou Kouhei Clearcode Micah Kornfeld Google Jinfeng Ni Sundeck Andy Grove Nvidia Jesus Camacho Rodriguez Microsoft Rich Tia Voltron Data Vibhatha Abeykoon Voltron Data Nic Crane Voltron Data Gil Forsyth Voltron Data Additional detail about differences from ASF \u00b6 Corporate Awareness: The ASF takes a blind-eye approach that has proven to be too slow to correct corporate influence which has substantially undermined many OSS projects. In contrast, Substrait SMC members are responsible for identifying corporate risks and over-representation and adjusting inclusion in the project based on that (limiting committership, SMC membership, etc). Each member of the SMC shares responsibility to expand the community and seek out corporate diversity. Infrastructure: The ASF shows its age wrt to infrastructure, having been originally built on SVN. Some examples of requirements that Substrait is eschewing that exist in ASF include: custom git infrastructure, release process that is manual, project external gatekeeping around the use of new tools/technologies.","title":"Governance"},{"location":"governance/#substrait-project-governance","text":"The Substrait project is run by volunteers in a collaborative and open way. Its governance is inspired by the Apache Software Foundation. In most cases, people familiar with the ASF model can work with Substrait in the same way. The biggest differences between the models are: Substrait does not have a separate infrastructure governing body that gatekeeps the adoption of new developer tools and technologies. Substrait Management Committee (SMC) members are responsible for recognizing the corporate relationship of its members and ensuring diverse representation and corporate independence. Substrait does not condone private mailing lists. All project business should be discussed in public The only exceptions to this are security escalations ( security@substrait.io ) and harassment ( harassment@substrait.io ). Substrait has an automated continuous release process with no formal voting process per release. More details about concrete things Substrait looks to avoid can be found below.","title":"Substrait Project Governance"},{"location":"governance/#the-substrait-project","text":"The Substrait project consists of the code and repositories that reside in the substrait-io GitHub organization , the Substrait.io website , the Substrait mailing list , MS-hosted teams community calls and the Substrait Slack workspace . (All are open to everyone and recordings/transcripts are made where technology supports it.)","title":"The Substrait Project"},{"location":"governance/#substrait-volunteers","text":"We recognize four groups of individuals related to the project.","title":"Substrait Volunteers"},{"location":"governance/#user","text":"A user is someone who uses Substrait. They may contribute to Substrait by providing feedback to developers in the form of bug reports and feature suggestions. Users participate in the Substrait community by helping other users on mailing lists and user support forums.","title":"User"},{"location":"governance/#contributors","text":"A contributor is a user who contributes to the project in the form of code or documentation. They take extra steps to participate in the project (loosely defined as the set of repositories under the github substrait-io organization) , are active on the developer mailing list, participate in discussions, and provide patches, documentation, suggestions, and criticism.","title":"Contributors"},{"location":"governance/#committer","text":"A committer is a developer who has write access to the code repositories and has a signed Contributor License Agreement (CLA) on file. Not needing to depend on other people to make patches to the code or documentation, they are actually making short-term decisions for the project. The SMC can (even tacitly) agree and approve the changes into permanency, or they can reject them. Remember that the SMC makes the decisions, not the individual committers.","title":"Committer"},{"location":"governance/#smc-member","text":"A SMC member is a committer who was elected due to merit for the evolution of the project. They have write access to the code repository, the right to cast binding votes on all proposals on community-related decisions,the right to propose other active contributors for committership, and the right to invite active committers to the SMC. The SMC as a whole is the entity that controls the project, nobody else. They are responsible for the continued shaping of this governance model.","title":"SMC Member"},{"location":"governance/#substrait-management-and-collaboration","text":"The Substrait project is managed using a collaborative, consensus-based process. We do not have a hierarchical structure; rather, different groups of contributors have different rights and responsibilities in the organization.","title":"Substrait Management and Collaboration"},{"location":"governance/#communication","text":"Communication must be done via mailing lists, Slack, and/or Github. Communication is always done publicly. There are no private lists and all decisions related to the project are made in public. Communication is frequently done asynchronously since members of the community are distributed across many time zones.","title":"Communication"},{"location":"governance/#substrait-management-committee","text":"The Substrait Management Committee is responsible for the active management of Substrait. The main role of the SMC is to further the long-term development and health of the community as a whole, and to ensure that balanced and wide scale peer review and collaboration takes place. As part of this, the SMC is the primary approver of specification changes, ensuring that proposed changes represent a balanced and thorough examination of possibilities. This doesn\u2019t mean that the SMC has to be involved in the minutiae of a particular specification change but should always shepard a healthy process around specification changes.","title":"Substrait Management Committee"},{"location":"governance/#substrait-voting-process","text":"Because one of the fundamental aspects of accomplishing things is doing so by consensus, we need a way to tell whether we have reached consensus. We do this by voting. There are several different types of voting. In all cases, it is recommended that all community members vote. The number of binding votes required to move forward and the community members who have \u201cbinding\u201d votes differs depending on the type of proposal made. In all cases, a veto of a binding voter results in an inability to move forward. The rules require that a community member registering a negative vote must include an alternative proposal or a detailed explanation of the reasons for the negative vote. The community then tries to gather consensus on an alternative proposal that can resolve the issue. In the great majority of cases, the concerns leading to the negative vote can be addressed. This process is called \u201cconsensus gathering\u201d and we consider it a very important indication of a healthy community. +1 votes required Binding voters Voting Location Process/Governance modifications & actions. This includes promoting new contributors to committer or SMC. 3 SMC Mailing List Format/Specification Modifications (including breaking extension changes) 2 SMC Github PR Non-breaking function introductions 1 (not including proposer) Committers Github PR Non-breaking extension additions & non-format code modifications 1 (not including proposer) Committers Github PR","title":"Substrait Voting Process"},{"location":"governance/#review-then-commit","text":"Substrait follows a review-then-commit policy. This requires that all changes receive consensus approval before being committed to the code base. The specific vote requirements follow the table above.","title":"Review-Then-Commit"},{"location":"governance/#expressing-votes","text":"The voting process may seem more than a little weird if you\u2019ve never encountered it before. Votes are represented as numbers between -1 and +1, with \u2018-1\u2019 meaning \u2018no\u2019 and \u2018+1\u2019 meaning \u2018yes.\u2019 The in-between values indicate how strongly the voting individual feels. Here are some examples of fractional votes and what the voter might be communicating with them: +0: \u2018I don\u2019t feel strongly about it, but I\u2019m okay with this.\u2019 -0: \u2018I won\u2019t get in the way, but I\u2019d rather we didn\u2019t do this.\u2019 -0.5: \u2018I don\u2019t like this idea, but I can\u2019t find any rational justification for my feelings.\u2019 ++1: \u2018Wow! I like this! Let\u2019s do it!\u2019 -0.9: \u2018I really don\u2019t like this, but I\u2019m not going to stand in the way if everyone else wants to go ahead with it.\u2019 +0.9: \u2018This is a cool idea and I like it, but I don\u2019t have time/the skills necessary to help out.\u2019","title":"Expressing Votes"},{"location":"governance/#votes-on-code-modification","text":"For code-modification votes, +1 votes (review approvals in Github are considered equivalent to a +1) are in favor of the proposal, but -1 votes are vetoes and kill the proposal dead until all vetoers withdraw their -1 votes.","title":"Votes on Code Modification"},{"location":"governance/#vetoes","text":"A -1 (or an unaddressed PR request for changes) vote by a qualified voter stops a code-modification proposal in its tracks. This constitutes a veto, and it cannot be overruled nor overridden by anyone. Vetoes stand until and unless the individual withdraws their veto. To prevent vetoes from being used capriciously, the voter must provide with the veto a technical or community justification showing why the change is bad.","title":"Vetoes"},{"location":"governance/#why-do-we-vote","text":"Votes help us to openly resolve conflicts. Without a process, people tend to avoid conflict and thrash around. Votes help to make sure we do the hard work of resolving the conflict.","title":"Why do we vote?"},{"location":"governance/#substrait-is-non-commercial-but-commercially-aware","text":"Substrait\u2019s mission is to produce software for the public good. All Substrait software is always available for free, and solely under the Apache License. We\u2019re happy to have third parties, including for-profit corporations, take our software and use it for their own purposes. However it is important in these cases to ensure that the third party does not misuse the brand and reputation of the Substrait project for its own purposes. It is important for the longevity and community health of Substrait that the community gets the appropriate credit for producing freely available software. The SMC actively track the corporate allegiances of community members and strives to ensure influence around any particular aspect of the project isn\u2019t overly skewed towards a single corporate entity.","title":"Substrait is non-commercial but commercially-aware"},{"location":"governance/#substrait-trademark","text":"The SMC is responsible for protecting the Substrait name and brand. TBD what action is taken to support this.","title":"Substrait Trademark"},{"location":"governance/#project-roster","text":"","title":"Project Roster"},{"location":"governance/#substrait-management-committee-smc","text":"Name Association Phillip Cloud Voltron Data Weston Pace Voltron Data Jacques Nadeau Sundeck","title":"Substrait Management Committee (SMC)"},{"location":"governance/#substrait-committers","text":"Name Association Jeroen van Straten Voltron Data Carlo Curino Microsoft James Taylor Sundeck Sutou Kouhei Clearcode Micah Kornfeld Google Jinfeng Ni Sundeck Andy Grove Nvidia Jesus Camacho Rodriguez Microsoft Rich Tia Voltron Data Vibhatha Abeykoon Voltron Data Nic Crane Voltron Data Gil Forsyth Voltron Data","title":"Substrait Committers"},{"location":"governance/#additional-detail-about-differences-from-asf","text":"Corporate Awareness: The ASF takes a blind-eye approach that has proven to be too slow to correct corporate influence which has substantially undermined many OSS projects. In contrast, Substrait SMC members are responsible for identifying corporate risks and over-representation and adjusting inclusion in the project based on that (limiting committership, SMC membership, etc). Each member of the SMC shares responsibility to expand the community and seek out corporate diversity. Infrastructure: The ASF shows its age wrt to infrastructure, having been originally built on SVN. Some examples of requirements that Substrait is eschewing that exist in ASF include: custom git infrastructure, release process that is manual, project external gatekeeping around the use of new tools/technologies.","title":"Additional detail about differences from ASF"},{"location":"community/","text":"Community \u00b6 Substrait is developed as a consensus-driven open source product under the Apache 2.0 license. Development is done in the open leveraging GitHub issues and PRs. Get In Touch \u00b6 Mailing List/Google Group We use the mailing list to discuss questions, formulate plans and collaborate asynchronously. Slack Channel The developers of Substrait frequent the Slack channel. You can get an invite to the channel by following this link . GitHub Issues Substrait is developed via GitHub issues and pull requests. If you see a problem or want to enhance the product, we suggest you file a GitHub issue for developers to review. Twitter The @substrait_io account on Twitter is our official account. Follow-up to keep to date on what is happening with Substrait! Docs Our website is all maintained in our source repository. If there is something you think can be improved, feel free to fork our repository and post a pull request. Talks \u00b6 Want to learn more about Substrait? Try the following presentations and slide decks. Substrait: A Common Representation for Data Compute Plans (Jacques Nadeau, April 2022) [ slides ] Contribution \u00b6 All contributors are welcome to Substrait.","title":"Community"},{"location":"community/#community","text":"Substrait is developed as a consensus-driven open source product under the Apache 2.0 license. Development is done in the open leveraging GitHub issues and PRs.","title":"Community"},{"location":"community/#get-in-touch","text":"Mailing List/Google Group We use the mailing list to discuss questions, formulate plans and collaborate asynchronously. Slack Channel The developers of Substrait frequent the Slack channel. You can get an invite to the channel by following this link . GitHub Issues Substrait is developed via GitHub issues and pull requests. If you see a problem or want to enhance the product, we suggest you file a GitHub issue for developers to review. Twitter The @substrait_io account on Twitter is our official account. Follow-up to keep to date on what is happening with Substrait! Docs Our website is all maintained in our source repository. If there is something you think can be improved, feel free to fork our repository and post a pull request.","title":"Get In Touch"},{"location":"community/#talks","text":"Want to learn more about Substrait? Try the following presentations and slide decks. Substrait: A Common Representation for Data Compute Plans (Jacques Nadeau, April 2022) [ slides ]","title":"Talks"},{"location":"community/#contribution","text":"All contributors are welcome to Substrait.","title":"Contribution"},{"location":"community/powered_by/","text":"Powered by Substrait \u00b6 In addition to the work maintained in repositories within the substrait-io GitHub organization , a growing list of other open source projects have adopted Substrait. Acero Acero is a query execution engine implemented as a part of the Apache Arrow C++ library. Acero provides a Substrait consumer interface. ADBC ADBC (Arrow Database Connectivity) is an API specification for Apache Arrow-based database access. ADBC allows applications to pass queries either as SQL strings or Substrait plans. Arrow Flight SQL Arrow Flight SQL is a client-server protocol for interacting with databases and query engines using the Apache Arrow in-memory columnar format and the Arrow Flight RPC framework. Arrow Flight SQL allows clients to send queries as SQL strings or Substrait plans. DataFusion DataFusion is an extensible query planning, optimization, and execution framework, written in Rust, that uses Apache Arrow as its in-memory format. DataFusion provides a Substrait producer and consumer that can convert DataFusion logical plans to and from Substrait plans. It can be used through the DataFusion Python bindings . DuckDB DuckDB is an in-process SQL OLAP database management system. DuckDB provides a Substrait extension that allows users to produce and consume Substrait plans through DuckDB\u2019s SQL, Python, and R APIs. Gluten Gluten is a plugin for Apache Spark that allows computation to be offloaded to engines that have better performance or efficiency than Spark\u2019s built-in JVM-based engine. Gluten converts Spark physical plans to Substrait plans. Ibis Ibis is a Python library that provides a lightweight, universal interface for data wrangling. It includes a dataframe API for Python with support for more than 10 query execution engines, plus a Substrait producer to enable support for Substrait-consuming execution engines. Substrait R Interface The Substrait R interface package allows users to construct Substrait plans from R for evaluation by Substrait-consuming execution engines. The package provides a dplyr backend as well as lower-level interfaces for creating Substrait plans and integrations with Acero and DuckDB. Velox Velox is a unified execution engine aimed at accelerating data management systems and streamlining their development. Velox provides a Substrait consumer interface. To add your project to this list, please open a pull request .","title":"Powered by Substrait"},{"location":"community/powered_by/#powered-by-substrait","text":"In addition to the work maintained in repositories within the substrait-io GitHub organization , a growing list of other open source projects have adopted Substrait. Acero Acero is a query execution engine implemented as a part of the Apache Arrow C++ library. Acero provides a Substrait consumer interface. ADBC ADBC (Arrow Database Connectivity) is an API specification for Apache Arrow-based database access. ADBC allows applications to pass queries either as SQL strings or Substrait plans. Arrow Flight SQL Arrow Flight SQL is a client-server protocol for interacting with databases and query engines using the Apache Arrow in-memory columnar format and the Arrow Flight RPC framework. Arrow Flight SQL allows clients to send queries as SQL strings or Substrait plans. DataFusion DataFusion is an extensible query planning, optimization, and execution framework, written in Rust, that uses Apache Arrow as its in-memory format. DataFusion provides a Substrait producer and consumer that can convert DataFusion logical plans to and from Substrait plans. It can be used through the DataFusion Python bindings . DuckDB DuckDB is an in-process SQL OLAP database management system. DuckDB provides a Substrait extension that allows users to produce and consume Substrait plans through DuckDB\u2019s SQL, Python, and R APIs. Gluten Gluten is a plugin for Apache Spark that allows computation to be offloaded to engines that have better performance or efficiency than Spark\u2019s built-in JVM-based engine. Gluten converts Spark physical plans to Substrait plans. Ibis Ibis is a Python library that provides a lightweight, universal interface for data wrangling. It includes a dataframe API for Python with support for more than 10 query execution engines, plus a Substrait producer to enable support for Substrait-consuming execution engines. Substrait R Interface The Substrait R interface package allows users to construct Substrait plans from R for evaluation by Substrait-consuming execution engines. The package provides a dplyr backend as well as lower-level interfaces for creating Substrait plans and integrations with Acero and DuckDB. Velox Velox is a unified execution engine aimed at accelerating data management systems and streamlining their development. Velox provides a Substrait consumer interface. To add your project to this list, please open a pull request .","title":"Powered by Substrait"},{"location":"expressions/aggregate_functions/","text":"Aggregate Functions \u00b6 Aggregate functions are functions that define an operation which consumes values from multiple records to a produce a single output. Aggregate functions in SQL are typically used in GROUP BY functions. Aggregate functions are similar to scalar functions and function signatures with a small set of different properties. Aggregate function signatures contain all the properties defined for scalar functions . Additionally, they contain the properties below: Property Description Required Inherits All properties defined for scalar function. N/A Ordered Whether the result of this function is sensitive to sort order. Optional, defaults to false Maximum set size Maximum allowed set size as an unsigned integer. Optional, defaults to unlimited Decomposable Whether the function can be executed in one or more intermediate steps. Valid options are: NONE , ONE , MANY , describing how intermediate steps can be taken. Optional, defaults to NONE Intermediate Output Type If the function is decomposable, represents the intermediate output type that is used, if the function is defined as either ONE or MANY decomposable. Will be a struct in many cases. Required for ONE and MANY . Invocation Whether the function uses all or only distinct values in the aggregation calculation. Valid options are: ALL , DISTINCT . Optional, defaults to ALL Aggregate Binding \u00b6 When binding an aggregate function, the binding must include the following additional properties beyond the standard scalar binding properties: Property Description Phase Describes the input type of the data: [INITIAL_TO_INTERMEDIATE, INTERMEDIATE_TO_INTERMEDIATE, INITIAL_TO_RESULT, INTERMEDIATE_TO_RESULT] describing what portion of the operation is required. For functions that are NOT decomposable, the only valid option will be INITIAL_TO_RESULT. Ordering Zero or more ordering keys along with key order (ASC|DESC|NULL FIRST, etc.), declared similar to the sort keys in an ORDER BY relational operation. If no sorts are specified, the records are not sorted prior to being passed to the aggregate function.","title":"Aggregate Functions"},{"location":"expressions/aggregate_functions/#aggregate-functions","text":"Aggregate functions are functions that define an operation which consumes values from multiple records to a produce a single output. Aggregate functions in SQL are typically used in GROUP BY functions. Aggregate functions are similar to scalar functions and function signatures with a small set of different properties. Aggregate function signatures contain all the properties defined for scalar functions . Additionally, they contain the properties below: Property Description Required Inherits All properties defined for scalar function. N/A Ordered Whether the result of this function is sensitive to sort order. Optional, defaults to false Maximum set size Maximum allowed set size as an unsigned integer. Optional, defaults to unlimited Decomposable Whether the function can be executed in one or more intermediate steps. Valid options are: NONE , ONE , MANY , describing how intermediate steps can be taken. Optional, defaults to NONE Intermediate Output Type If the function is decomposable, represents the intermediate output type that is used, if the function is defined as either ONE or MANY decomposable. Will be a struct in many cases. Required for ONE and MANY . Invocation Whether the function uses all or only distinct values in the aggregation calculation. Valid options are: ALL , DISTINCT . Optional, defaults to ALL","title":"Aggregate Functions"},{"location":"expressions/aggregate_functions/#aggregate-binding","text":"When binding an aggregate function, the binding must include the following additional properties beyond the standard scalar binding properties: Property Description Phase Describes the input type of the data: [INITIAL_TO_INTERMEDIATE, INTERMEDIATE_TO_INTERMEDIATE, INITIAL_TO_RESULT, INTERMEDIATE_TO_RESULT] describing what portion of the operation is required. For functions that are NOT decomposable, the only valid option will be INITIAL_TO_RESULT. Ordering Zero or more ordering keys along with key order (ASC|DESC|NULL FIRST, etc.), declared similar to the sort keys in an ORDER BY relational operation. If no sorts are specified, the records are not sorted prior to being passed to the aggregate function.","title":"Aggregate Binding"},{"location":"expressions/embedded_functions/","text":"Embedded Functions \u00b6 Embedded functions are a special kind of function where the implementation is embedded within the actual plan. They are commonly used in tools where a user intersperses business logic within a data pipeline. This is more common in data science workflows than traditional SQL workflows. Embedded functions are not pre-registered. Embedded functions require that data be consumed and produced with a standard API, may require memory allocation and have determinate error reporting behavior. They may also have specific runtime dependencies. For example, a Python pickle function may depend on pyarrow 5.0 and pynessie 1.0. Properties for an embedded function include: Property Description Required Function Type The type of embedded function presented. Required Function Properties Function properties, one of those items defined below. Required Output Type The fully resolved output type for this embedded function. Required The binary representation of an embedded function is: Binary Representation message EmbeddedFunction { repeated Expression arguments = 1 ; Type output_type = 2 ; oneof kind { PythonPickleFunction python_pickle_function = 3 ; WebAssemblyFunction web_assembly_function = 4 ; } message PythonPickleFunction { bytes function = 1 ; repeated string prerequisite = 2 ; } message WebAssemblyFunction { bytes script = 1 ; repeated string prerequisite = 2 ; } } Human Readable Representation n/a Example n/a Function Details \u00b6 There are many types of possible stored functions. For each, Substrait works to expose the function in as descriptive a way as possible to support the largest number of consumers. Python Pickle Function Type \u00b6 Property Description Required Pickle Body binary pickle encoded function using [TBD] API representation to access arguments. True Prereqs A list of specific Python conda packages that are prerequisites for access (a structured version of a requirements.txt file). Optional, defaults to none WebAssembly Function Type \u00b6 Property Description Required Script WebAssembly function True Prereqs A list of AssemblyScript prerequisites required to compile the assemblyscript function using NPM coordinates. Optional, defaults to none Discussion Points \u00b6 What are the common embedded function formats? How do we expose the data for a function? How do we express batching capabilities? How do we ensure/declare containerization?","title":"Embedded Functions"},{"location":"expressions/embedded_functions/#embedded-functions","text":"Embedded functions are a special kind of function where the implementation is embedded within the actual plan. They are commonly used in tools where a user intersperses business logic within a data pipeline. This is more common in data science workflows than traditional SQL workflows. Embedded functions are not pre-registered. Embedded functions require that data be consumed and produced with a standard API, may require memory allocation and have determinate error reporting behavior. They may also have specific runtime dependencies. For example, a Python pickle function may depend on pyarrow 5.0 and pynessie 1.0. Properties for an embedded function include: Property Description Required Function Type The type of embedded function presented. Required Function Properties Function properties, one of those items defined below. Required Output Type The fully resolved output type for this embedded function. Required The binary representation of an embedded function is: Binary Representation message EmbeddedFunction { repeated Expression arguments = 1 ; Type output_type = 2 ; oneof kind { PythonPickleFunction python_pickle_function = 3 ; WebAssemblyFunction web_assembly_function = 4 ; } message PythonPickleFunction { bytes function = 1 ; repeated string prerequisite = 2 ; } message WebAssemblyFunction { bytes script = 1 ; repeated string prerequisite = 2 ; } } Human Readable Representation n/a Example n/a","title":"Embedded Functions"},{"location":"expressions/embedded_functions/#function-details","text":"There are many types of possible stored functions. For each, Substrait works to expose the function in as descriptive a way as possible to support the largest number of consumers.","title":"Function Details"},{"location":"expressions/embedded_functions/#python-pickle-function-type","text":"Property Description Required Pickle Body binary pickle encoded function using [TBD] API representation to access arguments. True Prereqs A list of specific Python conda packages that are prerequisites for access (a structured version of a requirements.txt file). Optional, defaults to none","title":"Python Pickle Function Type"},{"location":"expressions/embedded_functions/#webassembly-function-type","text":"Property Description Required Script WebAssembly function True Prereqs A list of AssemblyScript prerequisites required to compile the assemblyscript function using NPM coordinates. Optional, defaults to none","title":"WebAssembly Function Type"},{"location":"expressions/embedded_functions/#discussion-points","text":"What are the common embedded function formats? How do we expose the data for a function? How do we express batching capabilities? How do we ensure/declare containerization?","title":"Discussion Points"},{"location":"expressions/extended_expression/","text":"Extended expression \u00b6 Extended expression is provided for expression level protocol instead of plan rels. It mainly targets for expression only evaluation, such as those computed in Filter/Project/Aggregation rels. Different from original expression defined in substrait protocol, it requires more information to completely describe the computation context, including input data schema, referred function signatures and output schema. Besides, as it will be used seperately with plan rel representation, it need include basic fields like Version. Input and output data schema \u00b6 Similar as base_schema defined in ReadRel , the input data schema tells name/type/nullibilty and layout info of input data for target expression evalutation. It also has a field name to define name of output data. Referred expression \u00b6 It will has one or more referred expressions in this message and the referred expressions can be Expression or AggregateFunction . More types of expression can be added for more scenarios. For multi expressions, user can translate them following same order as it occurs in original plan rel. But it does NOT require the consume side to handle it strictly in previous order. Only need to make sure columns in final output are organized in same order as defined in extended expression message. Function extensions \u00b6 As in the expression message, functions are used by referring function anchor so the related extensions are needed to determine detailed function signature.","title":"Extended expression"},{"location":"expressions/extended_expression/#extended-expression","text":"Extended expression is provided for expression level protocol instead of plan rels. It mainly targets for expression only evaluation, such as those computed in Filter/Project/Aggregation rels. Different from original expression defined in substrait protocol, it requires more information to completely describe the computation context, including input data schema, referred function signatures and output schema. Besides, as it will be used seperately with plan rel representation, it need include basic fields like Version.","title":"Extended expression"},{"location":"expressions/extended_expression/#input-and-output-data-schema","text":"Similar as base_schema defined in ReadRel , the input data schema tells name/type/nullibilty and layout info of input data for target expression evalutation. It also has a field name to define name of output data.","title":"Input and output data schema"},{"location":"expressions/extended_expression/#referred-expression","text":"It will has one or more referred expressions in this message and the referred expressions can be Expression or AggregateFunction . More types of expression can be added for more scenarios. For multi expressions, user can translate them following same order as it occurs in original plan rel. But it does NOT require the consume side to handle it strictly in previous order. Only need to make sure columns in final output are organized in same order as defined in extended expression message.","title":"Referred expression"},{"location":"expressions/extended_expression/#function-extensions","text":"As in the expression message, functions are used by referring function anchor so the related extensions are needed to determine detailed function signature.","title":"Function extensions"},{"location":"expressions/field_references/","text":"Field References \u00b6 In Substrait, all fields are dealt with on a positional basis. Field names are only used at the edge of a plan, for the purposes of naming fields for the outside world. Each operation returns a simple or compound data type. Additional operations can refer to data within that initial operation using field references. To reference a field, you use a reference based on the type of field position you want to reference. Reference Type Properties Type Applicability Type return Struct Field Ordinal position. Zero-based. Only legal within the range of possible fields within a struct. Selecting an ordinal outside the applicable field range results in an invalid plan. struct Type of field referenced Array Value Array offset. Zero-based. Negative numbers can be used to describe an offset relative to the end of the array. For example, -1 means the last element in an array. Negative and positive overflows return null values (no wrapping). list type of list Array Slice Array offset and element count. Zero-based. Negative numbers can be used to describe an offset relative to the end of the array. For example, -1 means the last element in an array. Position does not wrap, nor does length. list Same type as original list Map Key A map value that is matched exactly against available map keys and returned. [TBD, can multiple matches occur?] map Value type of map Map KeyExpression A wildcard string that is matched against a simplified form of regular expressions. Requires the key type of the map to be a character type. [Format detail needed, intention to include basic regex concepts such as greedy/non-greedy.] map List of map value type Masked Complex Expression An expression that provides a mask over a schema declaring which portions of the schema should be presented. This allows a user to select a portion of a complex object but mask certain subsections of that same object. any any Compound References \u00b6 References are typically constructed as a sequence. For example: [struct position 0, struct position 1, array offset 2, array slice 1..3]. Validation \u00b6 References must validate against the schema of the record being referenced. If not, an error is expected. Masked Complex Expression \u00b6 A masked complex expression is used to do a subselection of a portion of a complex record. It allows a user to specify the portion of the complex object to consume. Imagine you have a schema of (note that structs are lists of fields here, as they are in general in Substrait as field names are not used internally in Substrait): struct: - struct: - integer - list: struct: - i32 - string - string - i32 - i16 - i32 - i64 Given this schema, you could declare a mask in pseudocode, such as: 0:[0,1:[..5:[0,2]]],2,3 OR 0: - 0 - 1: ..5: -0 -2 2 3 This mask states that we would like to include fields 0 2 and 3 at the top-level. Within field 0, we want to include subfields 0 and 1. For subfield 0.1, we want to include up to only the first 5 records in the array and only includes fields 0 and 2 within the struct within that array. The resulting schema would be: struct: - struct: - integer - list: struct: - i32 - string - i32 - i64 Unwrapping Behavior \u00b6 By default, when only a single field is selected from a struct, that struct is removed. When only a single element is removed from a list, the list is removed. A user can also configure the mask to avoid unwrapping in these cases. [TBD how we express this in the serialization formats.] Discussion Points \u00b6 Should we support column reordering/positioning using a masked complex expression? (Right now, you can only mask things out.)","title":"Field References"},{"location":"expressions/field_references/#field-references","text":"In Substrait, all fields are dealt with on a positional basis. Field names are only used at the edge of a plan, for the purposes of naming fields for the outside world. Each operation returns a simple or compound data type. Additional operations can refer to data within that initial operation using field references. To reference a field, you use a reference based on the type of field position you want to reference. Reference Type Properties Type Applicability Type return Struct Field Ordinal position. Zero-based. Only legal within the range of possible fields within a struct. Selecting an ordinal outside the applicable field range results in an invalid plan. struct Type of field referenced Array Value Array offset. Zero-based. Negative numbers can be used to describe an offset relative to the end of the array. For example, -1 means the last element in an array. Negative and positive overflows return null values (no wrapping). list type of list Array Slice Array offset and element count. Zero-based. Negative numbers can be used to describe an offset relative to the end of the array. For example, -1 means the last element in an array. Position does not wrap, nor does length. list Same type as original list Map Key A map value that is matched exactly against available map keys and returned. [TBD, can multiple matches occur?] map Value type of map Map KeyExpression A wildcard string that is matched against a simplified form of regular expressions. Requires the key type of the map to be a character type. [Format detail needed, intention to include basic regex concepts such as greedy/non-greedy.] map List of map value type Masked Complex Expression An expression that provides a mask over a schema declaring which portions of the schema should be presented. This allows a user to select a portion of a complex object but mask certain subsections of that same object. any any","title":"Field References"},{"location":"expressions/field_references/#compound-references","text":"References are typically constructed as a sequence. For example: [struct position 0, struct position 1, array offset 2, array slice 1..3].","title":"Compound References"},{"location":"expressions/field_references/#validation","text":"References must validate against the schema of the record being referenced. If not, an error is expected.","title":"Validation"},{"location":"expressions/field_references/#masked-complex-expression","text":"A masked complex expression is used to do a subselection of a portion of a complex record. It allows a user to specify the portion of the complex object to consume. Imagine you have a schema of (note that structs are lists of fields here, as they are in general in Substrait as field names are not used internally in Substrait): struct: - struct: - integer - list: struct: - i32 - string - string - i32 - i16 - i32 - i64 Given this schema, you could declare a mask in pseudocode, such as: 0:[0,1:[..5:[0,2]]],2,3 OR 0: - 0 - 1: ..5: -0 -2 2 3 This mask states that we would like to include fields 0 2 and 3 at the top-level. Within field 0, we want to include subfields 0 and 1. For subfield 0.1, we want to include up to only the first 5 records in the array and only includes fields 0 and 2 within the struct within that array. The resulting schema would be: struct: - struct: - integer - list: struct: - i32 - string - i32 - i64","title":"Masked Complex Expression"},{"location":"expressions/field_references/#unwrapping-behavior","text":"By default, when only a single field is selected from a struct, that struct is removed. When only a single element is removed from a list, the list is removed. A user can also configure the mask to avoid unwrapping in these cases. [TBD how we express this in the serialization formats.]","title":"Unwrapping Behavior"},{"location":"expressions/field_references/#discussion-points","text":"Should we support column reordering/positioning using a masked complex expression? (Right now, you can only mask things out.)","title":"Discussion Points"},{"location":"expressions/scalar_functions/","text":"Scalar Functions \u00b6 A function is a scalar function if that function takes in values from a single record and produces an output value. To clearly specify the definition of functions, Substrait declares an extensible specification plus binding approach to function resolution. A scalar function signature includes the following properties: Property Description Required Name One or more user-friendly UTF-8 strings that are used to reference this function. At least one value is required. List of arguments Argument properties are defined below. Arguments can be fully defined or calculated with a type expression. See further details below. Optional, defaults to niladic. Deterministic Whether this function is expected to reproduce the same output when it is invoked multiple times with the same input. This informs a plan consumer on whether it can constant-reduce the defined function. An example would be a random() function, which is typically expected to be evaluated repeatedly despite having the same set of inputs. Optional, defaults to true. Session Dependent Whether this function is influenced by the session context it is invoked within. For example, a function may be influenced by a user who is invoking the function, the time zone of a session, or some other non-obvious parameter. This can inform caching systems on whether a particular function is cacheable. Optional, defaults to false. Variadic Behavior Whether the last argument of the function is variadic or a single argument. If variadic, the argument can optionally have a lower bound (minimum number of instances) and an upper bound (maximum number of instances). Optional, defaults to single value. Nullability Handling Describes how nullability of input arguments maps to nullability of output arguments. Three options are: MIRROR , DECLARED_OUTPUT and DISCRETE . More details about nullability handling are listed below. Optional, defaults to MIRROR Description Additional description of function for implementers or users. Should be written human-readable to allow exposure to end users. Presented as a map with language => description mappings. E.g. { \"en\": \"This adds two numbers together.\", \"fr\": \"cela ajoute deux nombres\"} . Optional Return Value The output type of the expression. Return types can be expressed as a fully-defined type or a type expression. See below for more on type expressions. Required Implementation Map A map of implementation locations for one or more implementations of the given function. Each key is a function implementation type. Implementation types include examples such as: AthenaArrowLambda, TrinoV361Jar, ArrowCppKernelEnum, GandivaEnum, LinkedIn Transport Jar, etc. [Definition TBD]. Implementation type has one or more properties associated with retrieval of that implementation. Optional Argument Types \u00b6 There are three main types of arguments: value arguments, type arguments, and enumerations. Every defined arguments must be specified in every invocation of the function. When specified, the position of these arguments in the function invocation must match the position of the arguments as defined in the YAML function definition. Value arguments: arguments that refer to a data value. These could be constants (literal expressions defined in the plan) or variables (a reference expression that references data being processed by the plan). This is the most common type of argument. The value of a value argument is not available in output derivation, but its type is. Value arguments can be declared in one of two ways: concrete or parameterized. Concrete types are either simple types or compound types with all parameters fully defined (without referencing any type arguments). Examples include i32 , fp32 , VARCHAR<20> , List<fp32> , etc. Parameterized types are discussed further below. Type arguments: arguments that are used only to inform the evaluation and/or type derivation of the function. For example, you might have a function which is truncate(<type> DECIMAL<P0,S0>, <value> DECIMAL<P1, S1>, <value> i32) . This function declares two value arguments and a type argument. The difference between them is that the type argument has no value at runtime, while the value arguments do. Enumeration: arguments that support a fixed set of declared values as constant arguments. These arguments must be specified as part of an expression. While these could also have been implemented as constant string value arguments, they are formally included to improve validation/contextual help/etc. for frontend processors and IDEs. An example might use might be extract([DAY|YEAR|MONTH], <date value>) . In this example, a producer must specify a type of date part to extract. Note, the value of a required enumeration cannot be used in type derivation. Value Argument Properties \u00b6 Property Description Required Name A human-readable name for this argument to help clarify use. Optional, defaults to a name based on position (e.g. arg0 ) Type A fully defined type or a type expression. Required Constant Whether this argument is required to be a constant for invocation. For example, in some system a regular expression pattern would only be accepted as a literal and not a column value reference. Optional, defaults to false Type Argument Properties \u00b6 Property Description Required Type A partially or completely parameterized type. E.g. List<K> or K Required Name A human-readable name for this argument to help clarify use. Optional, defaults to a name based on position (e.g. arg0 ) Required Enumeration Properties \u00b6 Property Description Required Options List of valid string options for this argument Required Name A human-readable name for this argument to help clarify use. Optional, defaults to a name based on position (e.g. arg0 ) Options \u00b6 In addition to arguments each call may specify zero or more options. These are similar to a required enumeration but more focused on supporting alternative behaviors. Options can be left unspecified and the consumer is free to choose which implementation to use. An example use case might be OVERFLOW_BEHAVIOR:[OVERFLOW, SATURATE, ERROR] If unspecified, an engine is free to use any of the three choices or even some alternative behavior (e.g. setting the value to null on overflow). If specified, the engine would be expected to behave as specified or fail. Note, the value of an optional enumeration cannot be used in type derivation. Option Preference \u00b6 A producer may specify multiple vlaues for an option. If the producer does so then the consumer must deliver the first behavior in the list of values that the consumer is capable of delivering. For example, considering overflow as defined above, if a producer specified [ERROR, SATURATE] then the consumer must deliver ERROR if it is capable of doing so. If it is not then it may deliver SATURATE . If the consumer cannot deliver either behavior then it is an error and the consumer must reject the plan. Optional Properties \u00b6 Property Description Required Values A list of valid strings for this option. Required Name A human-readable name for this option. Required Nullability Handling \u00b6 Mode Description MIRROR This means that the function has the behavior that if at least one of the input arguments are nullable, the return type is also nullable. If all arguments are non-nullable, the return type will be non-nullable. An example might be the + function. DECLARED_OUTPUT Input arguments are accepted of any mix of nullability. The nullability of the output function is whatever the return type expression states. Example use might be the function is_null() where the output is always boolean independent of the nullability of the input. DISCRETE The input and arguments all define concrete nullability and can only be bound to the types that have those nullability. For example, if a type input is declared i64? and one has an i64 literal, the i64 literal must be specifically cast to i64? to allow the operation to bind. Parameterized Types \u00b6 Types are parameterized by two types of values: by inner types (e.g. List<K> ) and numeric values (e.g. DECIMAL<P,S> ). Parameter names are simple strings (frequently a single character). There are two types of parameters: integer parameters and type parameters. When the same parameter name is used multiple times in a function definition, the function can only bind if the exact same value is used for all parameters of that name. For example, if one had a function with a signature of fn(VARCHAR<N>, VARCHAR<N>) , the function would be only be usable if both VARCHAR types had the same length value N . This necessitates that all instances of the same parameter name must be of the same parameter type (all instances are a type parameter or all instances are an integer parameter). Type Parameter Resolution in Variadic Functions \u00b6 When the last argument of a function is variadic and declares a type parameter e.g. fn(A, B, C...) , the C parameter can be marked as either consistent or inconsistent. If marked as consistent, the function can only be bound to arguments where all the C types are the same concrete type. If marked as inconsistent, each unique C can be bound to a different type within the constraints of what T allows. Output Type Derivation \u00b6 Concrete Return Types \u00b6 A concrete return type is one that is fully known at function definition time. Example simple concrete return types would be things such as i32 , fp32 . For compound types, a concrete return type must be fully declared. Example of fully defined compound types: VARCHAR<20> , DECIMAL<25,5> Return Type Expressions \u00b6 Any function can declare a return type expression. A return type expression uses a simplified set of expressions to describe how the return type should be returned. For example, a return expression could be as simple as the return of parameter declared in the arguments. For example f(List<K>) => K or can be a simple mathematical or conditional expression such as add(decimal<a,b>, decimal<c,d>) => decimal<a+c, b+d> . For the simple expression language, there is a very narrow set of types: Integer: 64-bit signed integer (can be a literal or a parameter value) Boolean: True and False Type: A Substrait type (with possibly additional embedded expressions) These types are evaluated using a small set of operations to support common scenarios. List of valid operations: Math: +, -, *, /, min, max Boolean: &&, ||, !, <, >, == Parameters: type, integer Literals: type, integer Fully defined with argument types: type_parameter(string name) => type integer_parameter(string name) => integer not(boolean x) => boolean and(boolean a, boolean b) => boolean or(boolean a, boolean b) => boolean multiply(integer a, integer b) => integer divide(integer a, integer b) => integer add(integer a, integer b) => integer subtract(integer a, integer b) => integer min(integer a, integer b) => integer max(integer a, integer b) => integer equal(integer a, integer b) => boolean greater_than(integer a, integer b) => boolean less_than(integer a, integer b) => boolean covers(Type a, Type b) => boolean Covers means that type b matches type A for as much as type B is defined. For example, if type A is VARCHAR<20> and type B is VARCHAR<N> , type B would be considered covering. Similarlily if type A was List<Struct<a:f32, b:f32>> and type B was List<Struct<>> , it would be considered covering. Note that this is directional \u201cas in B covers A\u201d or \u201cB can be further enhanced to match the definition A\u201d. if(boolean a) then (integer) else (integer) if(boolean a) then (type) else (type) Example Type Expressions \u00b6 For reference, here are are some common output type derivations and how they can be expressed with a return type expression: Operation Definition Add item to list add(<List<T>, T>) => List<T> Decimal Division divide(Decimal<P1,S1>, Decimal<P2,S2>) => Decimal<P1 -S1 + S2 + MAX(6, S1 + P2 + 1), MAX(6, S1 + P2 + 1)> Select a subset of map keys based on a regular expression (requires stringlike keys) extract_values(regex:string, map:Map<K,V>) => List<V> WHERE K IN [STRING, VARCHAR<N>, FIXEDCHAR<N>] Concatenate two fixed sized character strings concat(FIXEDCHAR<A>, FIXEDCHAR<B>) => FIXEDCHAR<A+B> Make a struct of a set of fields and a struct definition. make_struct(<type> T, K...) => T","title":"Scalar Functions"},{"location":"expressions/scalar_functions/#scalar-functions","text":"A function is a scalar function if that function takes in values from a single record and produces an output value. To clearly specify the definition of functions, Substrait declares an extensible specification plus binding approach to function resolution. A scalar function signature includes the following properties: Property Description Required Name One or more user-friendly UTF-8 strings that are used to reference this function. At least one value is required. List of arguments Argument properties are defined below. Arguments can be fully defined or calculated with a type expression. See further details below. Optional, defaults to niladic. Deterministic Whether this function is expected to reproduce the same output when it is invoked multiple times with the same input. This informs a plan consumer on whether it can constant-reduce the defined function. An example would be a random() function, which is typically expected to be evaluated repeatedly despite having the same set of inputs. Optional, defaults to true. Session Dependent Whether this function is influenced by the session context it is invoked within. For example, a function may be influenced by a user who is invoking the function, the time zone of a session, or some other non-obvious parameter. This can inform caching systems on whether a particular function is cacheable. Optional, defaults to false. Variadic Behavior Whether the last argument of the function is variadic or a single argument. If variadic, the argument can optionally have a lower bound (minimum number of instances) and an upper bound (maximum number of instances). Optional, defaults to single value. Nullability Handling Describes how nullability of input arguments maps to nullability of output arguments. Three options are: MIRROR , DECLARED_OUTPUT and DISCRETE . More details about nullability handling are listed below. Optional, defaults to MIRROR Description Additional description of function for implementers or users. Should be written human-readable to allow exposure to end users. Presented as a map with language => description mappings. E.g. { \"en\": \"This adds two numbers together.\", \"fr\": \"cela ajoute deux nombres\"} . Optional Return Value The output type of the expression. Return types can be expressed as a fully-defined type or a type expression. See below for more on type expressions. Required Implementation Map A map of implementation locations for one or more implementations of the given function. Each key is a function implementation type. Implementation types include examples such as: AthenaArrowLambda, TrinoV361Jar, ArrowCppKernelEnum, GandivaEnum, LinkedIn Transport Jar, etc. [Definition TBD]. Implementation type has one or more properties associated with retrieval of that implementation. Optional","title":"Scalar Functions"},{"location":"expressions/scalar_functions/#argument-types","text":"There are three main types of arguments: value arguments, type arguments, and enumerations. Every defined arguments must be specified in every invocation of the function. When specified, the position of these arguments in the function invocation must match the position of the arguments as defined in the YAML function definition. Value arguments: arguments that refer to a data value. These could be constants (literal expressions defined in the plan) or variables (a reference expression that references data being processed by the plan). This is the most common type of argument. The value of a value argument is not available in output derivation, but its type is. Value arguments can be declared in one of two ways: concrete or parameterized. Concrete types are either simple types or compound types with all parameters fully defined (without referencing any type arguments). Examples include i32 , fp32 , VARCHAR<20> , List<fp32> , etc. Parameterized types are discussed further below. Type arguments: arguments that are used only to inform the evaluation and/or type derivation of the function. For example, you might have a function which is truncate(<type> DECIMAL<P0,S0>, <value> DECIMAL<P1, S1>, <value> i32) . This function declares two value arguments and a type argument. The difference between them is that the type argument has no value at runtime, while the value arguments do. Enumeration: arguments that support a fixed set of declared values as constant arguments. These arguments must be specified as part of an expression. While these could also have been implemented as constant string value arguments, they are formally included to improve validation/contextual help/etc. for frontend processors and IDEs. An example might use might be extract([DAY|YEAR|MONTH], <date value>) . In this example, a producer must specify a type of date part to extract. Note, the value of a required enumeration cannot be used in type derivation.","title":"Argument Types"},{"location":"expressions/scalar_functions/#value-argument-properties","text":"Property Description Required Name A human-readable name for this argument to help clarify use. Optional, defaults to a name based on position (e.g. arg0 ) Type A fully defined type or a type expression. Required Constant Whether this argument is required to be a constant for invocation. For example, in some system a regular expression pattern would only be accepted as a literal and not a column value reference. Optional, defaults to false","title":"Value Argument Properties"},{"location":"expressions/scalar_functions/#type-argument-properties","text":"Property Description Required Type A partially or completely parameterized type. E.g. List<K> or K Required Name A human-readable name for this argument to help clarify use. Optional, defaults to a name based on position (e.g. arg0 )","title":"Type Argument Properties"},{"location":"expressions/scalar_functions/#required-enumeration-properties","text":"Property Description Required Options List of valid string options for this argument Required Name A human-readable name for this argument to help clarify use. Optional, defaults to a name based on position (e.g. arg0 )","title":"Required Enumeration Properties"},{"location":"expressions/scalar_functions/#options","text":"In addition to arguments each call may specify zero or more options. These are similar to a required enumeration but more focused on supporting alternative behaviors. Options can be left unspecified and the consumer is free to choose which implementation to use. An example use case might be OVERFLOW_BEHAVIOR:[OVERFLOW, SATURATE, ERROR] If unspecified, an engine is free to use any of the three choices or even some alternative behavior (e.g. setting the value to null on overflow). If specified, the engine would be expected to behave as specified or fail. Note, the value of an optional enumeration cannot be used in type derivation.","title":"Options"},{"location":"expressions/scalar_functions/#option-preference","text":"A producer may specify multiple vlaues for an option. If the producer does so then the consumer must deliver the first behavior in the list of values that the consumer is capable of delivering. For example, considering overflow as defined above, if a producer specified [ERROR, SATURATE] then the consumer must deliver ERROR if it is capable of doing so. If it is not then it may deliver SATURATE . If the consumer cannot deliver either behavior then it is an error and the consumer must reject the plan.","title":"Option Preference"},{"location":"expressions/scalar_functions/#optional-properties","text":"Property Description Required Values A list of valid strings for this option. Required Name A human-readable name for this option. Required","title":"Optional Properties"},{"location":"expressions/scalar_functions/#nullability-handling","text":"Mode Description MIRROR This means that the function has the behavior that if at least one of the input arguments are nullable, the return type is also nullable. If all arguments are non-nullable, the return type will be non-nullable. An example might be the + function. DECLARED_OUTPUT Input arguments are accepted of any mix of nullability. The nullability of the output function is whatever the return type expression states. Example use might be the function is_null() where the output is always boolean independent of the nullability of the input. DISCRETE The input and arguments all define concrete nullability and can only be bound to the types that have those nullability. For example, if a type input is declared i64? and one has an i64 literal, the i64 literal must be specifically cast to i64? to allow the operation to bind.","title":"Nullability Handling"},{"location":"expressions/scalar_functions/#parameterized-types","text":"Types are parameterized by two types of values: by inner types (e.g. List<K> ) and numeric values (e.g. DECIMAL<P,S> ). Parameter names are simple strings (frequently a single character). There are two types of parameters: integer parameters and type parameters. When the same parameter name is used multiple times in a function definition, the function can only bind if the exact same value is used for all parameters of that name. For example, if one had a function with a signature of fn(VARCHAR<N>, VARCHAR<N>) , the function would be only be usable if both VARCHAR types had the same length value N . This necessitates that all instances of the same parameter name must be of the same parameter type (all instances are a type parameter or all instances are an integer parameter).","title":"Parameterized Types"},{"location":"expressions/scalar_functions/#type-parameter-resolution-in-variadic-functions","text":"When the last argument of a function is variadic and declares a type parameter e.g. fn(A, B, C...) , the C parameter can be marked as either consistent or inconsistent. If marked as consistent, the function can only be bound to arguments where all the C types are the same concrete type. If marked as inconsistent, each unique C can be bound to a different type within the constraints of what T allows.","title":"Type Parameter Resolution in Variadic Functions"},{"location":"expressions/scalar_functions/#output-type-derivation","text":"","title":"Output Type Derivation"},{"location":"expressions/scalar_functions/#concrete-return-types","text":"A concrete return type is one that is fully known at function definition time. Example simple concrete return types would be things such as i32 , fp32 . For compound types, a concrete return type must be fully declared. Example of fully defined compound types: VARCHAR<20> , DECIMAL<25,5>","title":"Concrete Return Types"},{"location":"expressions/scalar_functions/#return-type-expressions","text":"Any function can declare a return type expression. A return type expression uses a simplified set of expressions to describe how the return type should be returned. For example, a return expression could be as simple as the return of parameter declared in the arguments. For example f(List<K>) => K or can be a simple mathematical or conditional expression such as add(decimal<a,b>, decimal<c,d>) => decimal<a+c, b+d> . For the simple expression language, there is a very narrow set of types: Integer: 64-bit signed integer (can be a literal or a parameter value) Boolean: True and False Type: A Substrait type (with possibly additional embedded expressions) These types are evaluated using a small set of operations to support common scenarios. List of valid operations: Math: +, -, *, /, min, max Boolean: &&, ||, !, <, >, == Parameters: type, integer Literals: type, integer Fully defined with argument types: type_parameter(string name) => type integer_parameter(string name) => integer not(boolean x) => boolean and(boolean a, boolean b) => boolean or(boolean a, boolean b) => boolean multiply(integer a, integer b) => integer divide(integer a, integer b) => integer add(integer a, integer b) => integer subtract(integer a, integer b) => integer min(integer a, integer b) => integer max(integer a, integer b) => integer equal(integer a, integer b) => boolean greater_than(integer a, integer b) => boolean less_than(integer a, integer b) => boolean covers(Type a, Type b) => boolean Covers means that type b matches type A for as much as type B is defined. For example, if type A is VARCHAR<20> and type B is VARCHAR<N> , type B would be considered covering. Similarlily if type A was List<Struct<a:f32, b:f32>> and type B was List<Struct<>> , it would be considered covering. Note that this is directional \u201cas in B covers A\u201d or \u201cB can be further enhanced to match the definition A\u201d. if(boolean a) then (integer) else (integer) if(boolean a) then (type) else (type)","title":"Return Type Expressions"},{"location":"expressions/scalar_functions/#example-type-expressions","text":"For reference, here are are some common output type derivations and how they can be expressed with a return type expression: Operation Definition Add item to list add(<List<T>, T>) => List<T> Decimal Division divide(Decimal<P1,S1>, Decimal<P2,S2>) => Decimal<P1 -S1 + S2 + MAX(6, S1 + P2 + 1), MAX(6, S1 + P2 + 1)> Select a subset of map keys based on a regular expression (requires stringlike keys) extract_values(regex:string, map:Map<K,V>) => List<V> WHERE K IN [STRING, VARCHAR<N>, FIXEDCHAR<N>] Concatenate two fixed sized character strings concat(FIXEDCHAR<A>, FIXEDCHAR<B>) => FIXEDCHAR<A+B> Make a struct of a set of fields and a struct definition. make_struct(<type> T, K...) => T","title":"Example Type Expressions"},{"location":"expressions/specialized_record_expressions/","text":"Specialized Record Expressions \u00b6 While all types of operations could be reduced to functions, in some cases this would be overly simplistic. Instead, it is helpful to construct some other expression constructs. These constructs should be focused on different expression types as opposed to something that directly related to syntactic sugar. For example, CAST and EXTRACT or SQL operations that are presented using specialized syntax. However, they can easily be modeled using a function paradigm with minimal complexity. Literal Expressions \u00b6 For each data type, it is possible to create a literal value for that data type. The representation depends on the serialization format. Literal expressions include both a type literal and a possibly null value. Nested Type Constructor Expressions \u00b6 These expressions allow structs, lists, and maps to be constructed from a set of expressions. For example, they allow a struct expression like (field 0 - field 1, field 0 + field 1) to be represented. Cast Expression \u00b6 To convert a value from one type to another, Substrait defines a cast expression. Cast expressions declare an expected type, an input argument and an enumeration specifying failure behavior, indicating whether cast should return null on failure or throw an exception. Note that Substrait always requires a cast expression whenever the current type is not exactly equal to (one of) the expected types. For example, it is illegal to directly pass a value of type i8[0] to a function that only supports an i8?[0] argument, some other variation of i8 , or i16[0] . If Expression \u00b6 An if value expression is an expression composed of one if clause, zero or more else if clauses and an else clause. In pseudocode, they are envisioned as: if <boolean expression> then <result expression 1> else if <boolean expression> then <result expression 2> (zero or more times) else <result expression 3> When an if expression is declared, all return expressions must be the same identical type. Shortcut Behavior \u00b6 An if expression is expected to logically short-circuit on a positive outcome. This means that a skipped else/elseif expression cannot cause an error. For example, this should not actually throw an error despite the fact that the cast operation should fail. if 'value' = 'value' then 0 else cast('hello' as integer) Switch Expression \u00b6 Switch expression allow a selection of alternate branches based on the value of a given expression. They are an optimized form of a generic if expression where all conditions are equality to the same value. In pseudocode: switch(value) <value 1> => <return 1> (1 or more times) <else> => <return 3> Return values for a switch expression must all be of identical type. Shortcut Behavior \u00b6 As in if expressions, switch expression evaluation should not be interrupted by \u201croads not taken\u201d. Or List Equality Expression \u00b6 A specialized structure that is often used is a large list of possible values. In SQL, these are typically large IN lists. They can be composed from one or more fields. There are two common patterns, single value and multi value. In pseudocode they are represented as: Single Value: expression, [<value1>, <value2>, ... <valueN>] Multi Value: [expressionA, expressionB], [[value1a, value1b], [value2a, value2b].. [valueNa, valueNb]] For single value expressions, these are a compact equivalent of expression = value1 OR expression = value2 OR .. OR expression = valueN . When using an expression of this type, two things are required; the types of the test expression and all value expressions that are related must be of the same type. Additionally, a function signature for equality must be available for the expression type used.","title":"Specialized Record Expressions"},{"location":"expressions/specialized_record_expressions/#specialized-record-expressions","text":"While all types of operations could be reduced to functions, in some cases this would be overly simplistic. Instead, it is helpful to construct some other expression constructs. These constructs should be focused on different expression types as opposed to something that directly related to syntactic sugar. For example, CAST and EXTRACT or SQL operations that are presented using specialized syntax. However, they can easily be modeled using a function paradigm with minimal complexity.","title":"Specialized Record Expressions"},{"location":"expressions/specialized_record_expressions/#literal-expressions","text":"For each data type, it is possible to create a literal value for that data type. The representation depends on the serialization format. Literal expressions include both a type literal and a possibly null value.","title":"Literal Expressions"},{"location":"expressions/specialized_record_expressions/#nested-type-constructor-expressions","text":"These expressions allow structs, lists, and maps to be constructed from a set of expressions. For example, they allow a struct expression like (field 0 - field 1, field 0 + field 1) to be represented.","title":"Nested Type Constructor Expressions"},{"location":"expressions/specialized_record_expressions/#cast-expression","text":"To convert a value from one type to another, Substrait defines a cast expression. Cast expressions declare an expected type, an input argument and an enumeration specifying failure behavior, indicating whether cast should return null on failure or throw an exception. Note that Substrait always requires a cast expression whenever the current type is not exactly equal to (one of) the expected types. For example, it is illegal to directly pass a value of type i8[0] to a function that only supports an i8?[0] argument, some other variation of i8 , or i16[0] .","title":"Cast Expression"},{"location":"expressions/specialized_record_expressions/#if-expression","text":"An if value expression is an expression composed of one if clause, zero or more else if clauses and an else clause. In pseudocode, they are envisioned as: if <boolean expression> then <result expression 1> else if <boolean expression> then <result expression 2> (zero or more times) else <result expression 3> When an if expression is declared, all return expressions must be the same identical type.","title":"If Expression"},{"location":"expressions/specialized_record_expressions/#shortcut-behavior","text":"An if expression is expected to logically short-circuit on a positive outcome. This means that a skipped else/elseif expression cannot cause an error. For example, this should not actually throw an error despite the fact that the cast operation should fail. if 'value' = 'value' then 0 else cast('hello' as integer)","title":"Shortcut Behavior"},{"location":"expressions/specialized_record_expressions/#switch-expression","text":"Switch expression allow a selection of alternate branches based on the value of a given expression. They are an optimized form of a generic if expression where all conditions are equality to the same value. In pseudocode: switch(value) <value 1> => <return 1> (1 or more times) <else> => <return 3> Return values for a switch expression must all be of identical type.","title":"Switch Expression"},{"location":"expressions/specialized_record_expressions/#shortcut-behavior_1","text":"As in if expressions, switch expression evaluation should not be interrupted by \u201croads not taken\u201d.","title":"Shortcut Behavior"},{"location":"expressions/specialized_record_expressions/#or-list-equality-expression","text":"A specialized structure that is often used is a large list of possible values. In SQL, these are typically large IN lists. They can be composed from one or more fields. There are two common patterns, single value and multi value. In pseudocode they are represented as: Single Value: expression, [<value1>, <value2>, ... <valueN>] Multi Value: [expressionA, expressionB], [[value1a, value1b], [value2a, value2b].. [valueNa, valueNb]] For single value expressions, these are a compact equivalent of expression = value1 OR expression = value2 OR .. OR expression = valueN . When using an expression of this type, two things are required; the types of the test expression and all value expressions that are related must be of the same type. Additionally, a function signature for equality must be available for the expression type used.","title":"Or List Equality Expression"},{"location":"expressions/subqueries/","text":"Subqueries \u00b6 Subqueries are scalar expressions comprised of another query. Forms \u00b6 Scalar \u00b6 Scalar subqueries are subqueries that return one row and one column. Property Description Required Input Input relation Yes IN predicate \u00b6 An IN subquery predicate checks that the left expression is contained in the right subquery. Examples \u00b6 SELECT * FROM t1 WHERE x IN ( SELECT * FROM t2 ) SELECT * FROM t1 WHERE ( x , y ) IN ( SELECT a , b FROM t2 ) Property Description Required Needles Expressions who existence will be checked Yes Haystack Subquery to check Yes Set predicates \u00b6 A set predicate is a predicate over a set of rows in the form of a subquery. EXISTS and UNIQUE are common SQL spellings of these kinds of predicates. Property Description Required Operation The operation to perform over the set Yes Tuples Set of tuples to check using the operation Yes Set comparisons \u00b6 A set comparison subquery is a subquery comparison using ANY or ALL operations. Examples \u00b6 SELECT * FROM t1 WHERE x < ANY ( SELECT y from t2 ) Property Description Required Reduction operation The kind of reduction to use over the subquery Yes Comparison operation The kind of comparison operation to use Yes Expression Left-hand side expression to check Yes Subquery Subquery to check Yes","title":"Subqueries"},{"location":"expressions/subqueries/#subqueries","text":"Subqueries are scalar expressions comprised of another query.","title":"Subqueries"},{"location":"expressions/subqueries/#forms","text":"","title":"Forms"},{"location":"expressions/subqueries/#scalar","text":"Scalar subqueries are subqueries that return one row and one column. Property Description Required Input Input relation Yes","title":"Scalar"},{"location":"expressions/subqueries/#in-predicate","text":"An IN subquery predicate checks that the left expression is contained in the right subquery.","title":"IN predicate"},{"location":"expressions/subqueries/#examples","text":"SELECT * FROM t1 WHERE x IN ( SELECT * FROM t2 ) SELECT * FROM t1 WHERE ( x , y ) IN ( SELECT a , b FROM t2 ) Property Description Required Needles Expressions who existence will be checked Yes Haystack Subquery to check Yes","title":"Examples"},{"location":"expressions/subqueries/#set-predicates","text":"A set predicate is a predicate over a set of rows in the form of a subquery. EXISTS and UNIQUE are common SQL spellings of these kinds of predicates. Property Description Required Operation The operation to perform over the set Yes Tuples Set of tuples to check using the operation Yes","title":"Set predicates"},{"location":"expressions/subqueries/#set-comparisons","text":"A set comparison subquery is a subquery comparison using ANY or ALL operations.","title":"Set comparisons"},{"location":"expressions/subqueries/#examples_1","text":"SELECT * FROM t1 WHERE x < ANY ( SELECT y from t2 ) Property Description Required Reduction operation The kind of reduction to use over the subquery Yes Comparison operation The kind of comparison operation to use Yes Expression Left-hand side expression to check Yes Subquery Subquery to check Yes","title":"Examples"},{"location":"expressions/table_functions/","text":"Table Functions \u00b6 Table functions produce zero or more records for each input record. Table functions use a signature similar to scalar functions. However, they are not allowed in the same contexts. to be completed\u2026","title":"Table Functions"},{"location":"expressions/table_functions/#table-functions","text":"Table functions produce zero or more records for each input record. Table functions use a signature similar to scalar functions. However, they are not allowed in the same contexts. to be completed\u2026","title":"Table Functions"},{"location":"expressions/user_defined_functions/","text":"User-Defined Functions \u00b6 Substrait supports the creation of custom functions using simple extensions , using the facilities described in scalar functions . In fact, the functions defined by Substrait use the same mechanism. The extension files for them can be found here .","title":"User-Defined Functions"},{"location":"expressions/user_defined_functions/#user-defined-functions","text":"Substrait supports the creation of custom functions using simple extensions , using the facilities described in scalar functions . In fact, the functions defined by Substrait use the same mechanism. The extension files for them can be found here .","title":"User-Defined Functions"},{"location":"expressions/window_functions/","text":"Window Functions \u00b6 Window functions are functions which consume values from multiple records to produce a single output. They are similar to aggregate functions, but also have a focused window of analysis to compare to their partition window. Window functions are similar to scalar values to an end user, producing a single value for each input record. However, the consumption visibility for the production of each single record can be many records. Window function signatures contain all the properties defined for aggregate functions . Additionally, they contain the properties below Property Description Required Inherits All properties defined for aggregate functions. N/A Window Type STREAMING or PARTITION. Describes whether the function needs to see all data for the specific partition operation simultaneously. Operations like SUM can produce values in a streaming manner with no complete visibility of the partition. NTILE requires visibility of the entire partition before it can start producing values. Optional, defaults to PARTITION When binding an aggregate function, the binding must include the following additional properties beyond the standard scalar binding properties: Property Description Required Partition A list of partitioning expressions. False, defaults to a single partition for the entire dataset Lower Bound Bound Following(int64), Bound Trailing(int64) or CurrentRow. False, defaults to start of partition Upper Bound Bound Following(int64), Bound Trailing(int64) or CurrentRow. False, defaults to end of partition","title":"Window Functions"},{"location":"expressions/window_functions/#window-functions","text":"Window functions are functions which consume values from multiple records to produce a single output. They are similar to aggregate functions, but also have a focused window of analysis to compare to their partition window. Window functions are similar to scalar values to an end user, producing a single value for each input record. However, the consumption visibility for the production of each single record can be many records. Window function signatures contain all the properties defined for aggregate functions . Additionally, they contain the properties below Property Description Required Inherits All properties defined for aggregate functions. N/A Window Type STREAMING or PARTITION. Describes whether the function needs to see all data for the specific partition operation simultaneously. Operations like SUM can produce values in a streaming manner with no complete visibility of the partition. NTILE requires visibility of the entire partition before it can start producing values. Optional, defaults to PARTITION When binding an aggregate function, the binding must include the following additional properties beyond the standard scalar binding properties: Property Description Required Partition A list of partitioning expressions. False, defaults to a single partition for the entire dataset Lower Bound Bound Following(int64), Bound Trailing(int64) or CurrentRow. False, defaults to start of partition Upper Bound Bound Following(int64), Bound Trailing(int64) or CurrentRow. False, defaults to end of partition","title":"Window Functions"},{"location":"extensions/","text":"Extensions \u00b6 In many cases, the existing objects in Substrait will be sufficient to accomplish a particular use case. However, it is sometimes helpful to create a new data type, scalar function signature or some other custom representation within a system. For that, Substrait provides a number of extension points. Simple Extensions \u00b6 Some kinds of primitives are so frequently extended that Substrait defines a standard YAML format that describes how the extended functionality can be interpreted. This allows different projects/systems to use the YAML definition as a specification so that interoperability isn\u2019t constrained to the base Substrait specification. The main types of extensions that are defined in this manner include the following: Data types Type variations Scalar Functions Aggregate Functions Window Functions Table Functions To extend these items, developers can create one or more YAML files at a defined URI that describes the properties of each of these extensions. The YAML file is constructed according to the YAML Schema . Each definition in the file corresponds to the YAML-based serialization of the relevant data structure. If a user only wants to extend one of these types of objects (e.g. types), a developer does not have to provide definitions for the other extension points. A Substrait plan can reference one or more YAML files via URI for extension. In the places where these entities are referenced, they will be referenced using a URI + name reference. The name scheme per type works as follows: Category Naming scheme Type The name as defined on the type object. Type Variation The name as defined on the type variation object. Function Signature In a specific YAML, if there is only one function implementation with a specific name, a extension type declaration can reference the function using either simple or compound references. Simple references are simply the name of the function (e.g. add ). Compound references (e.g. add:i8_i8 )are described below. Function Signature Compound Names \u00b6 A YAML file may contain one or more functions by the same name. When only a single function is declared within the file, it can be referenced using the name of that function or a compound name. When more than one function of the same name is declared within a YAML file, the key used in the function extension declaration is a combination of the name of the function along with a list of the required input argument types. Optional arguments are not included in the signature. The format is as follows: <function name>:<short_arg_type0>_<short_arg_type1>_..._<short_arg_typeN> Rather than using a full data type representation, the input argument types ( short_arg_type ) are mapped to single-level short name. The mappings are listed in the table below. Note It is required that two function implementations with the same simple name must resolve to different compound names using types. If two function implementations in a YAML file resolve to the same compound name, the YAML file is invalid and behavior is undefined. Argument Type Signature Name Required Enumeration req i8 i8 i16 i16 i32 i32 i64 i64 fp32 fp32 fp64 fp64 string str binary vbin timestamp ts timestamp_tz tstz date date time time interval_year iyear interval_day iday uuid uuid fixedchar<N> fchar varchar<N> vchar fixedbinary<N> fbin decimal<P,S> dec struct<T1,T2,\u2026,TN> struct list<T> list map<K,V> map any[\\d]? any user defined type u!name Examples \u00b6 Function Signature Function Name add(optional enumeration, i8, i8) => i8 add:i8_i8 avg(fp32) => fp32 avg:fp32 extract(required enumeration, timestamp) => i64 extract:req_ts sum(any1) => any1 sum:any Advanced Extensions \u00b6 Less common extensions can be extended using customization support at the serialization level. This includes the following kinds of extensions: Extension Type Description Relation Modification (semantic) Extensions to an existing relation that will alter the semantics of that relation. These kinds of extensions require that any plan consumer understand the extension to be able to manipulate or execute that operator. Ignoring these extensions will result in an incorrect interpretation of the plan. An example extension might be creating a customized version of Aggregate that can optionally apply a filter before aggregating the data. Note: Semantic-changing extensions shouldn\u2019t change the core characteristics of the underlying relation. For example, they should not change the default direct output field ordering, change the number of fields output or change the behavior of physical property characteristics. If one needs to change one of these behaviors, one should define a new relation as described below. Relation Modification (optimization) Extensions to an existing relation that can improve the efficiency of a plan consumer but don\u2019t fundamentally change the behavior of the operation. An example might be an estimated amount of memory the relation is expected to use or a particular algorithmic pattern that is perceived to be optimal. New Relations Creates an entirely new kind of relation. It is the most flexible way to extend Substrait but also make the Substrait plan the least interoperable. In most cases it is better to use a semantic changing relation as oppposed to a new relation as it means existing code patterns can easily be extended to work with the additional properties. New Read Types Defines a new subcategory of read that can be used in a ReadRel. One of Substrait is to provide a fairly extensive set of read patterns within the project as opposed to requiring people to define new types externally. As such, we suggest that you first talk with the Substrait community to determine whether you read type can be incorporated directly in the core specification. New Write Types Similar to a read type but for writes. As with reads, the community recommends that interested extenders first discuss with the community about developing new write types in the community before using the extension mechanisms. Plan Extensions Semantic and/or optimization based additions at the plan level. Because extension mechanisms are different for each serialization format, please refer to the corresponding serialization sections to understand how these extensions are defined in more detail.","title":"Extensions"},{"location":"extensions/#extensions","text":"In many cases, the existing objects in Substrait will be sufficient to accomplish a particular use case. However, it is sometimes helpful to create a new data type, scalar function signature or some other custom representation within a system. For that, Substrait provides a number of extension points.","title":"Extensions"},{"location":"extensions/#simple-extensions","text":"Some kinds of primitives are so frequently extended that Substrait defines a standard YAML format that describes how the extended functionality can be interpreted. This allows different projects/systems to use the YAML definition as a specification so that interoperability isn\u2019t constrained to the base Substrait specification. The main types of extensions that are defined in this manner include the following: Data types Type variations Scalar Functions Aggregate Functions Window Functions Table Functions To extend these items, developers can create one or more YAML files at a defined URI that describes the properties of each of these extensions. The YAML file is constructed according to the YAML Schema . Each definition in the file corresponds to the YAML-based serialization of the relevant data structure. If a user only wants to extend one of these types of objects (e.g. types), a developer does not have to provide definitions for the other extension points. A Substrait plan can reference one or more YAML files via URI for extension. In the places where these entities are referenced, they will be referenced using a URI + name reference. The name scheme per type works as follows: Category Naming scheme Type The name as defined on the type object. Type Variation The name as defined on the type variation object. Function Signature In a specific YAML, if there is only one function implementation with a specific name, a extension type declaration can reference the function using either simple or compound references. Simple references are simply the name of the function (e.g. add ). Compound references (e.g. add:i8_i8 )are described below.","title":"Simple Extensions"},{"location":"extensions/#function-signature-compound-names","text":"A YAML file may contain one or more functions by the same name. When only a single function is declared within the file, it can be referenced using the name of that function or a compound name. When more than one function of the same name is declared within a YAML file, the key used in the function extension declaration is a combination of the name of the function along with a list of the required input argument types. Optional arguments are not included in the signature. The format is as follows: <function name>:<short_arg_type0>_<short_arg_type1>_..._<short_arg_typeN> Rather than using a full data type representation, the input argument types ( short_arg_type ) are mapped to single-level short name. The mappings are listed in the table below. Note It is required that two function implementations with the same simple name must resolve to different compound names using types. If two function implementations in a YAML file resolve to the same compound name, the YAML file is invalid and behavior is undefined. Argument Type Signature Name Required Enumeration req i8 i8 i16 i16 i32 i32 i64 i64 fp32 fp32 fp64 fp64 string str binary vbin timestamp ts timestamp_tz tstz date date time time interval_year iyear interval_day iday uuid uuid fixedchar<N> fchar varchar<N> vchar fixedbinary<N> fbin decimal<P,S> dec struct<T1,T2,\u2026,TN> struct list<T> list map<K,V> map any[\\d]? any user defined type u!name","title":"Function Signature Compound Names"},{"location":"extensions/#examples","text":"Function Signature Function Name add(optional enumeration, i8, i8) => i8 add:i8_i8 avg(fp32) => fp32 avg:fp32 extract(required enumeration, timestamp) => i64 extract:req_ts sum(any1) => any1 sum:any","title":"Examples"},{"location":"extensions/#advanced-extensions","text":"Less common extensions can be extended using customization support at the serialization level. This includes the following kinds of extensions: Extension Type Description Relation Modification (semantic) Extensions to an existing relation that will alter the semantics of that relation. These kinds of extensions require that any plan consumer understand the extension to be able to manipulate or execute that operator. Ignoring these extensions will result in an incorrect interpretation of the plan. An example extension might be creating a customized version of Aggregate that can optionally apply a filter before aggregating the data. Note: Semantic-changing extensions shouldn\u2019t change the core characteristics of the underlying relation. For example, they should not change the default direct output field ordering, change the number of fields output or change the behavior of physical property characteristics. If one needs to change one of these behaviors, one should define a new relation as described below. Relation Modification (optimization) Extensions to an existing relation that can improve the efficiency of a plan consumer but don\u2019t fundamentally change the behavior of the operation. An example might be an estimated amount of memory the relation is expected to use or a particular algorithmic pattern that is perceived to be optimal. New Relations Creates an entirely new kind of relation. It is the most flexible way to extend Substrait but also make the Substrait plan the least interoperable. In most cases it is better to use a semantic changing relation as oppposed to a new relation as it means existing code patterns can easily be extended to work with the additional properties. New Read Types Defines a new subcategory of read that can be used in a ReadRel. One of Substrait is to provide a fairly extensive set of read patterns within the project as opposed to requiring people to define new types externally. As such, we suggest that you first talk with the Substrait community to determine whether you read type can be incorporated directly in the core specification. New Write Types Similar to a read type but for writes. As with reads, the community recommends that interested extenders first discuss with the community about developing new write types in the community before using the extension mechanisms. Plan Extensions Semantic and/or optimization based additions at the plan level. Because extension mechanisms are different for each serialization format, please refer to the corresponding serialization sections to understand how these extensions are defined in more detail.","title":"Advanced Extensions"},{"location":"extensions/functions_aggregate_approx/","text":"functions_aggregate_approx.yaml \u00b6 This document file is generated for functions_aggregate_approx.yaml Aggregate Functions \u00b6 approx_count_distinct \u00b6 Implementations: approx_count_distinct( x ): -> return_type 0. approx_count_distinct( any ): -> i64 Calculates the approximate number of rows that contain distinct values of the expression argument using HyperLogLog. This function provides an alternative to the COUNT (DISTINCT expression) function, which returns the exact number of rows that contain distinct values of an expression. APPROX_COUNT_DISTINCT processes large amounts of data significantly faster than COUNT, with negligible deviation from the exact result.","title":"functions_aggregate_approx.yaml"},{"location":"extensions/functions_aggregate_approx/#functions_aggregate_approxyaml","text":"This document file is generated for functions_aggregate_approx.yaml","title":"functions_aggregate_approx.yaml"},{"location":"extensions/functions_aggregate_approx/#aggregate-functions","text":"","title":"Aggregate Functions"},{"location":"extensions/functions_aggregate_approx/#approx_count_distinct","text":"Implementations: approx_count_distinct( x ): -> return_type 0. approx_count_distinct( any ): -> i64 Calculates the approximate number of rows that contain distinct values of the expression argument using HyperLogLog. This function provides an alternative to the COUNT (DISTINCT expression) function, which returns the exact number of rows that contain distinct values of an expression. APPROX_COUNT_DISTINCT processes large amounts of data significantly faster than COUNT, with negligible deviation from the exact result.","title":"approx_count_distinct"},{"location":"extensions/functions_aggregate_generic/","text":"functions_aggregate_generic.yaml \u00b6 This document file is generated for functions_aggregate_generic.yaml Aggregate Functions \u00b6 count \u00b6 Implementations: count( x , option:overflow ): -> return_type 0. count( any , option:overflow ): -> i64 Count a set of values Options: overflow ['SILENT', 'SATURATE', 'ERROR'] count \u00b6 Implementations: Count a set of records (not field referenced) any_value \u00b6 Implementations: any_value( x ): -> return_type 0. any_value( any ): -> any? *Selects an arbitrary value from a group of values. If the input is empty, the function returns null. *","title":"functions_aggregate_generic.yaml"},{"location":"extensions/functions_aggregate_generic/#functions_aggregate_genericyaml","text":"This document file is generated for functions_aggregate_generic.yaml","title":"functions_aggregate_generic.yaml"},{"location":"extensions/functions_aggregate_generic/#aggregate-functions","text":"","title":"Aggregate Functions"},{"location":"extensions/functions_aggregate_generic/#count","text":"Implementations: count( x , option:overflow ): -> return_type 0. count( any , option:overflow ): -> i64 Count a set of values Options: overflow ['SILENT', 'SATURATE', 'ERROR']","title":"count"},{"location":"extensions/functions_aggregate_generic/#count_1","text":"Implementations: Count a set of records (not field referenced)","title":"count"},{"location":"extensions/functions_aggregate_generic/#any_value","text":"Implementations: any_value( x ): -> return_type 0. any_value( any ): -> any? *Selects an arbitrary value from a group of values. If the input is empty, the function returns null. *","title":"any_value"},{"location":"extensions/functions_arithmetic/","text":"functions_arithmetic.yaml \u00b6 This document file is generated for functions_arithmetic.yaml Scalar Functions \u00b6 add \u00b6 Implementations: add( x , y , option:overflow ): -> return_type 0. add( i8 , i8 , option:overflow ): -> i8 1. add( i16 , i16 , option:overflow ): -> i16 2. add( i32 , i32 , option:overflow ): -> i32 3. add( i64 , i64 , option:overflow ): -> i64 4. add( fp32 , fp32 , option:rounding ): -> fp32 5. add( fp64 , fp64 , option:rounding ): -> fp64 Add two values. Options: overflow ['SILENT', 'SATURATE', 'ERROR'] rounding ['TIE_TO_EVEN', 'TIE_AWAY_FROM_ZERO', 'TRUNCATE', 'CEILING', 'FLOOR'] subtract \u00b6 Implementations: subtract( x , y , option:overflow ): -> return_type 0. subtract( i8 , i8 , option:overflow ): -> i8 1. subtract( i16 , i16 , option:overflow ): -> i16 2. subtract( i32 , i32 , option:overflow ): -> i32 3. subtract( i64 , i64 , option:overflow ): -> i64 4. subtract( fp32 , fp32 , option:rounding ): -> fp32 5. subtract( fp64 , fp64 , option:rounding ): -> fp64 Subtract one value from another. Options: overflow ['SILENT', 'SATURATE', 'ERROR'] rounding ['TIE_TO_EVEN', 'TIE_AWAY_FROM_ZERO', 'TRUNCATE', 'CEILING', 'FLOOR'] multiply \u00b6 Implementations: multiply( x , y , option:overflow ): -> return_type 0. multiply( i8 , i8 , option:overflow ): -> i8 1. multiply( i16 , i16 , option:overflow ): -> i16 2. multiply( i32 , i32 , option:overflow ): -> i32 3. multiply( i64 , i64 , option:overflow ): -> i64 4. multiply( fp32 , fp32 , option:rounding ): -> fp32 5. multiply( fp64 , fp64 , option:rounding ): -> fp64 Multiply two values. Options: overflow ['SILENT', 'SATURATE', 'ERROR'] rounding ['TIE_TO_EVEN', 'TIE_AWAY_FROM_ZERO', 'TRUNCATE', 'CEILING', 'FLOOR'] divide \u00b6 Implementations: divide( x , y , option:overflow ): -> return_type 0. divide( i8 , i8 , option:overflow ): -> i8 1. divide( i16 , i16 , option:overflow ): -> i16 2. divide( i32 , i32 , option:overflow ): -> i32 3. divide( i64 , i64 , option:overflow ): -> i64 4. divide( fp32 , fp32 , option:rounding , option:on_domain_error , option:on_division_by_zero ): -> fp32 5. divide( fp64 , fp64 , option:rounding , option:on_domain_error , option:on_division_by_zero ): -> fp64 *Divide x by y. In the case of integer division, partial values are truncated (i.e. rounded towards 0). The on_division_by_zero option governs behavior in cases where y is 0 and x is not 0. LIMIT means positive or negative infinity (depending on the sign of x and y). If x and y are both 0 or both \u00b1infinity, behavior will be governed by on_domain_error . * Options: overflow ['SILENT', 'SATURATE', 'ERROR'] rounding ['TIE_TO_EVEN', 'TIE_AWAY_FROM_ZERO', 'TRUNCATE', 'CEILING', 'FLOOR'] on_domain_error ['NAN', 'ERROR'] on_division_by_zero ['LIMIT', 'NAN', 'ERROR'] negate \u00b6 Implementations: negate( x , option:overflow ): -> return_type 0. negate( i8 , option:overflow ): -> i8 1. negate( i16 , option:overflow ): -> i16 2. negate( i32 , option:overflow ): -> i32 3. negate( i64 , option:overflow ): -> i64 4. negate( fp32 ): -> fp32 5. negate( fp64 ): -> fp64 Negation of the value Options: overflow ['SILENT', 'SATURATE', 'ERROR'] modulus \u00b6 Implementations: modulus( x , y ): -> return_type 0. modulus( i8 , i8 ): -> i8 1. modulus( i16 , i16 ): -> i16 2. modulus( i32 , i32 ): -> i32 3. modulus( i64 , i64 ): -> i64 Get the remainder when dividing one value by another. power \u00b6 Implementations: power( x , y , option:overflow ): -> return_type 0. power( i64 , i64 , option:overflow ): -> i64 1. power( fp32 , fp32 ): -> fp32 2. power( fp64 , fp64 ): -> fp64 Take the power with x as the base and y as exponent. Options: overflow ['SILENT', 'SATURATE', 'ERROR'] sqrt \u00b6 Implementations: sqrt( x , option:rounding , option:on_domain_error ): -> return_type 0. sqrt( i64 , option:rounding , option:on_domain_error ): -> fp64 1. sqrt( fp32 , option:rounding , option:on_domain_error ): -> fp32 2. sqrt( fp64 , option:rounding , option:on_domain_error ): -> fp64 Square root of the value Options: rounding ['TIE_TO_EVEN', 'TIE_AWAY_FROM_ZERO', 'TRUNCATE', 'CEILING', 'FLOOR'] on_domain_error ['NAN', 'ERROR'] exp \u00b6 Implementations: exp( x , option:rounding ): -> return_type 0. exp( fp32 , option:rounding ): -> fp32 1. exp( fp64 , option:rounding ): -> fp64 The mathematical constant e, raised to the power of the value. Options: rounding ['TIE_TO_EVEN', 'TIE_AWAY_FROM_ZERO', 'TRUNCATE', 'CEILING', 'FLOOR'] cos \u00b6 Implementations: cos( x , option:rounding ): -> return_type 0. cos( fp32 , option:rounding ): -> fp64 1. cos( fp64 , option:rounding ): -> fp64 Get the cosine of a value in radians. Options: rounding ['TIE_TO_EVEN', 'TIE_AWAY_FROM_ZERO', 'TRUNCATE', 'CEILING', 'FLOOR'] sin \u00b6 Implementations: sin( x , option:rounding ): -> return_type 0. sin( fp32 , option:rounding ): -> fp64 1. sin( fp64 , option:rounding ): -> fp64 Get the sine of a value in radians. Options: rounding ['TIE_TO_EVEN', 'TIE_AWAY_FROM_ZERO', 'TRUNCATE', 'CEILING', 'FLOOR'] tan \u00b6 Implementations: tan( x , option:rounding ): -> return_type 0. tan( fp32 , option:rounding ): -> fp64 1. tan( fp64 , option:rounding ): -> fp64 Get the tangent of a value in radians. Options: rounding ['TIE_TO_EVEN', 'TIE_AWAY_FROM_ZERO', 'TRUNCATE', 'CEILING', 'FLOOR'] cosh \u00b6 Implementations: cosh( x , option:rounding ): -> return_type 0. cosh( fp32 , option:rounding ): -> fp32 1. cosh( fp64 , option:rounding ): -> fp64 Get the hyperbolic cosine of a value in radians. Options: rounding ['TIE_TO_EVEN', 'TIE_AWAY_FROM_ZERO', 'TRUNCATE', 'CEILING', 'FLOOR'] sinh \u00b6 Implementations: sinh( x , option:rounding ): -> return_type 0. sinh( fp32 , option:rounding ): -> fp32 1. sinh( fp64 , option:rounding ): -> fp64 Get the hyperbolic sine of a value in radians. Options: rounding ['TIE_TO_EVEN', 'TIE_AWAY_FROM_ZERO', 'TRUNCATE', 'CEILING', 'FLOOR'] tanh \u00b6 Implementations: tanh( x , option:rounding ): -> return_type 0. tanh( fp32 , option:rounding ): -> fp32 1. tanh( fp64 , option:rounding ): -> fp64 Get the hyperbolic tangent of a value in radians. Options: rounding ['TIE_TO_EVEN', 'TIE_AWAY_FROM_ZERO', 'TRUNCATE', 'CEILING', 'FLOOR'] acos \u00b6 Implementations: acos( x , option:rounding , option:on_domain_error ): -> return_type 0. acos( fp32 , option:rounding , option:on_domain_error ): -> fp64 1. acos( fp64 , option:rounding , option:on_domain_error ): -> fp64 Get the arccosine of a value in radians. Options: rounding ['TIE_TO_EVEN', 'TIE_AWAY_FROM_ZERO', 'TRUNCATE', 'CEILING', 'FLOOR'] on_domain_error ['NAN', 'ERROR'] asin \u00b6 Implementations: asin( x , option:rounding , option:on_domain_error ): -> return_type 0. asin( fp32 , option:rounding , option:on_domain_error ): -> fp64 1. asin( fp64 , option:rounding , option:on_domain_error ): -> fp64 Get the arcsine of a value in radians. Options: rounding ['TIE_TO_EVEN', 'TIE_AWAY_FROM_ZERO', 'TRUNCATE', 'CEILING', 'FLOOR'] on_domain_error ['NAN', 'ERROR'] atan \u00b6 Implementations: atan( x , option:rounding ): -> return_type 0. atan( fp32 , option:rounding ): -> fp64 1. atan( fp64 , option:rounding ): -> fp64 Get the arctangent of a value in radians. Options: rounding ['TIE_TO_EVEN', 'TIE_AWAY_FROM_ZERO', 'TRUNCATE', 'CEILING', 'FLOOR'] acosh \u00b6 Implementations: acosh( x , option:rounding , option:on_domain_error ): -> return_type 0. acosh( fp32 , option:rounding , option:on_domain_error ): -> fp32 1. acosh( fp64 , option:rounding , option:on_domain_error ): -> fp64 Get the hyperbolic arccosine of a value in radians. Options: rounding ['TIE_TO_EVEN', 'TIE_AWAY_FROM_ZERO', 'TRUNCATE', 'CEILING', 'FLOOR'] on_domain_error ['NAN', 'ERROR'] asinh \u00b6 Implementations: asinh( x , option:rounding ): -> return_type 0. asinh( fp32 , option:rounding ): -> fp32 1. asinh( fp64 , option:rounding ): -> fp64 Get the hyperbolic arcsine of a value in radians. Options: rounding ['TIE_TO_EVEN', 'TIE_AWAY_FROM_ZERO', 'TRUNCATE', 'CEILING', 'FLOOR'] atanh \u00b6 Implementations: atanh( x , option:rounding , option:on_domain_error ): -> return_type 0. atanh( fp32 , option:rounding , option:on_domain_error ): -> fp32 1. atanh( fp64 , option:rounding , option:on_domain_error ): -> fp64 Get the hyperbolic arctangent of a value in radians. Options: rounding ['TIE_TO_EVEN', 'TIE_AWAY_FROM_ZERO', 'TRUNCATE', 'CEILING', 'FLOOR'] on_domain_error ['NAN', 'ERROR'] atan2 \u00b6 Implementations: atan2( x , y , option:rounding , option:on_domain_error ): -> return_type 0. atan2( fp32 , fp32 , option:rounding , option:on_domain_error ): -> fp64 1. atan2( fp64 , fp64 , option:rounding , option:on_domain_error ): -> fp64 Get the arctangent of values given as x/y pairs. Options: rounding ['TIE_TO_EVEN', 'TIE_AWAY_FROM_ZERO', 'TRUNCATE', 'CEILING', 'FLOOR'] on_domain_error ['NAN', 'ERROR'] abs \u00b6 Implementations: abs( x , option:overflow ): -> return_type 0. abs( i8 , option:overflow ): -> i8 1. abs( i16 , option:overflow ): -> i16 2. abs( i32 , option:overflow ): -> i32 3. abs( i64 , option:overflow ): -> i64 4. abs( fp32 ): -> fp32 5. abs( fp64 ): -> fp64 *Calculate the absolute value of the argument. Integer values allow the specification of overflow behavior to handle the unevenness of the twos complement, e.g. Int8 range [-128 : 127]. * Options: overflow ['SILENT', 'SATURATE', 'ERROR'] sign \u00b6 Implementations: sign( x ): -> return_type 0. sign( i8 ): -> i8 1. sign( i16 ): -> i16 2. sign( i32 ): -> i32 3. sign( i64 ): -> i64 4. sign( fp32 ): -> fp32 5. sign( fp64 ): -> fp64 *Return the signedness of the argument. Integer values return signedness with the same type as the input. Possible return values are [-1, 0, 1] Floating point values return signedness with the same type as the input. Possible return values are [-1.0, -0.0, 0.0, 1.0, NaN] * factorial \u00b6 Implementations: factorial( n , option:overflow ): -> return_type 0. factorial( i32 , option:overflow ): -> i32 1. factorial( i64 , option:overflow ): -> i64 *Return the factorial of a given integer input. The factorial of 0! is 1 by convention. Negative inputs will raise an error. * Options: overflow ['SILENT', 'SATURATE', 'ERROR'] bitwise_not \u00b6 Implementations: bitwise_not( x ): -> return_type 0. bitwise_not( i8 ): -> i8 1. bitwise_not( i16 ): -> i16 2. bitwise_not( i32 ): -> i32 3. bitwise_not( i64 ): -> i64 *Return the bitwise NOT result for one integer input. * bitwise_and \u00b6 Implementations: bitwise_and( x , y ): -> return_type 0. bitwise_and( i8 , i8 ): -> i8 1. bitwise_and( i16 , i16 ): -> i16 2. bitwise_and( i32 , i32 ): -> i32 3. bitwise_and( i64 , i64 ): -> i64 *Return the bitwise AND result for two integer inputs. * bitwise_or \u00b6 Implementations: bitwise_or( x , y ): -> return_type 0. bitwise_or( i8 , i8 ): -> i8 1. bitwise_or( i16 , i16 ): -> i16 2. bitwise_or( i32 , i32 ): -> i32 3. bitwise_or( i64 , i64 ): -> i64 *Return the bitwise OR result for two given integer inputs. * bitwise_xor \u00b6 Implementations: bitwise_xor( x , y ): -> return_type 0. bitwise_xor( i8 , i8 ): -> i8 1. bitwise_xor( i16 , i16 ): -> i16 2. bitwise_xor( i32 , i32 ): -> i32 3. bitwise_xor( i64 , i64 ): -> i64 *Return the bitwise XOR result for two integer inputs. * Aggregate Functions \u00b6 sum \u00b6 Implementations: sum( x , option:overflow ): -> return_type 0. sum( i8 , option:overflow ): -> i64? 1. sum( i16 , option:overflow ): -> i64? 2. sum( i32 , option:overflow ): -> i64? 3. sum( i64 , option:overflow ): -> i64? 4. sum( fp32 , option:overflow ): -> fp64? 5. sum( fp64 , option:overflow ): -> fp64? Sum a set of values. The sum of zero elements yields null. Options: overflow ['SILENT', 'SATURATE', 'ERROR'] sum0 \u00b6 Implementations: sum0( x , option:overflow ): -> return_type 0. sum0( i8 , option:overflow ): -> i64 1. sum0( i16 , option:overflow ): -> i64 2. sum0( i32 , option:overflow ): -> i64 3. sum0( i64 , option:overflow ): -> i64 4. sum0( fp32 , option:overflow ): -> fp64 5. sum0( fp64 , option:overflow ): -> fp64 *Sum a set of values. The sum of zero elements yields zero. Null values are ignored. * Options: overflow ['SILENT', 'SATURATE', 'ERROR'] avg \u00b6 Implementations: avg( x , option:overflow ): -> return_type 0. avg( i8 , option:overflow ): -> i8? 1. avg( i16 , option:overflow ): -> i16? 2. avg( i32 , option:overflow ): -> i32? 3. avg( i64 , option:overflow ): -> i64? 4. avg( fp32 , option:overflow ): -> fp32? 5. avg( fp64 , option:overflow ): -> fp64? Average a set of values. For integral types, this truncates partial values. Options: overflow ['SILENT', 'SATURATE', 'ERROR'] min \u00b6 Implementations: min( x ): -> return_type 0. min( i8 ): -> i8? 1. min( i16 ): -> i16? 2. min( i32 ): -> i32? 3. min( i64 ): -> i64? 4. min( fp32 ): -> fp32? 5. min( fp64 ): -> fp64? Min a set of values. max \u00b6 Implementations: max( x ): -> return_type 0. max( i8 ): -> i8? 1. max( i16 ): -> i16? 2. max( i32 ): -> i32? 3. max( i64 ): -> i64? 4. max( fp32 ): -> fp32? 5. max( fp64 ): -> fp64? Max a set of values. product \u00b6 Implementations: product( x , option:overflow ): -> return_type 0. product( i8 , option:overflow ): -> i8 1. product( i16 , option:overflow ): -> i16 2. product( i32 , option:overflow ): -> i32 3. product( i64 , option:overflow ): -> i64 4. product( fp32 , option:rounding ): -> fp32 5. product( fp64 , option:rounding ): -> fp64 Product of a set of values. Returns 1 for empty input. Options: overflow ['SILENT', 'SATURATE', 'ERROR'] rounding ['TIE_TO_EVEN', 'TIE_AWAY_FROM_ZERO', 'TRUNCATE', 'CEILING', 'FLOOR'] std_dev \u00b6 Implementations: std_dev( x , option:rounding , option:distribution ): -> return_type 0. std_dev( fp32 , option:rounding , option:distribution ): -> fp32? 1. std_dev( fp64 , option:rounding , option:distribution ): -> fp64? Calculates standard-deviation for a set of values. Options: rounding ['TIE_TO_EVEN', 'TIE_AWAY_FROM_ZERO', 'TRUNCATE', 'CEILING', 'FLOOR'] distribution ['SAMPLE', 'POPULATION'] variance \u00b6 Implementations: variance( x , option:rounding , option:distribution ): -> return_type 0. variance( fp32 , option:rounding , option:distribution ): -> fp32? 1. variance( fp64 , option:rounding , option:distribution ): -> fp64? Calculates variance for a set of values. Options: rounding ['TIE_TO_EVEN', 'TIE_AWAY_FROM_ZERO', 'TRUNCATE', 'CEILING', 'FLOOR'] distribution ['SAMPLE', 'POPULATION'] corr \u00b6 Implementations: corr( x , y , option:rounding ): -> return_type 0. corr( fp32 , fp32 , option:rounding ): -> fp32? 1. corr( fp64 , fp64 , option:rounding ): -> fp64? *Calculates the value of Pearson\u2019s correlation coefficient between x and y . If there is no input, null is returned. * Options: rounding ['TIE_TO_EVEN', 'TIE_AWAY_FROM_ZERO', 'TRUNCATE', 'CEILING', 'FLOOR'] mode \u00b6 Implementations: mode( x ): -> return_type 0. mode( i8 ): -> i8? 1. mode( i16 ): -> i16? 2. mode( i32 ): -> i32? 3. mode( i64 ): -> i64? 4. mode( fp32 ): -> fp32? 5. mode( fp64 ): -> fp64? *Calculates mode for a set of values. If there is no input, null is returned. * median \u00b6 Implementations: median( precision , x , option:rounding ): -> return_type 0. median( precision , i8 , option:rounding ): -> i8? 1. median( precision , i16 , option:rounding ): -> i16? 2. median( precision , i32 , option:rounding ): -> i32? 3. median( precision , i64 , option:rounding ): -> i64? 4. median( precision , fp32 , option:rounding ): -> fp32? 5. median( precision , fp64 , option:rounding ): -> fp64? *Calculate the median for a set of values. Returns null if applied to zero records. For the integer implementations, the rounding option determines how the median should be rounded if it ends up midway between two values. For the floating point implementations, they specify the usual floating point rounding mode. * Options: precision ['EXACT', 'APPROXIMATE'] rounding ['TIE_TO_EVEN', 'TIE_AWAY_FROM_ZERO', 'TRUNCATE', 'CEILING', 'FLOOR'] quantile \u00b6 Implementations: quantile( boundaries , precision , n , distribution , option:rounding ): -> return_type n: A positive integer which defines the number of quantile partitions. distribution: The data for which the quantiles should be computed. 0. quantile( boundaries , precision , i64 , any , option:rounding ): -> LIST?<any> *Calculates quantiles for a set of values. This function will divide the aggregated values (passed via the distribution argument) over N equally-sized bins, where N is passed via a constant argument. It will then return the values at the boundaries of these bins in list form. If the input is appropriately sorted, this computes the quantiles of the distribution. The function can optionally return the first and/or last element of the input, as specified by the boundaries argument. If the input is appropriately sorted, this will thus be the minimum and/or maximum values of the distribution. When the boundaries do not lie exactly on elements of the incoming distribution, the function will interpolate between the two nearby elements. If the interpolated value cannot be represented exactly, the rounding option controls how the value should be selected or computed. The function fails and returns null in the following cases: - n is null or less than one; - any value in distribution is null. The function returns an empty list if n equals 1 and boundaries is set to NEITHER . * Options: boundaries ['NEITHER', 'MINIMUM', 'MAXIMUM', 'BOTH'] precision ['EXACT', 'APPROXIMATE'] rounding ['TIE_TO_EVEN', 'TIE_AWAY_FROM_ZERO', 'TRUNCATE', 'CEILING', 'FLOOR'] Window Functions \u00b6 row_number \u00b6 Implementations: 0. row_number(): -> i64? the number of the current row within its partition. rank \u00b6 Implementations: 0. rank(): -> i64? the rank of the current row, with gaps. dense_rank \u00b6 Implementations: 0. dense_rank(): -> i64? the rank of the current row, without gaps. percent_rank \u00b6 Implementations: 0. percent_rank(): -> fp64? the relative rank of the current row. cume_dist \u00b6 Implementations: 0. cume_dist(): -> fp64? the cumulative distribution. ntile \u00b6 Implementations: ntile( x ): -> return_type 0. ntile( i32 ): -> i32? 1. ntile( i64 ): -> i64? Return an integer ranging from 1 to the argument value,dividing the partition as equally as possible.","title":"functions_arithmetic.yaml"},{"location":"extensions/functions_arithmetic/#functions_arithmeticyaml","text":"This document file is generated for functions_arithmetic.yaml","title":"functions_arithmetic.yaml"},{"location":"extensions/functions_arithmetic/#scalar-functions","text":"","title":"Scalar Functions"},{"location":"extensions/functions_arithmetic/#add","text":"Implementations: add( x , y , option:overflow ): -> return_type 0. add( i8 , i8 , option:overflow ): -> i8 1. add( i16 , i16 , option:overflow ): -> i16 2. add( i32 , i32 , option:overflow ): -> i32 3. add( i64 , i64 , option:overflow ): -> i64 4. add( fp32 , fp32 , option:rounding ): -> fp32 5. add( fp64 , fp64 , option:rounding ): -> fp64 Add two values. Options: overflow ['SILENT', 'SATURATE', 'ERROR'] rounding ['TIE_TO_EVEN', 'TIE_AWAY_FROM_ZERO', 'TRUNCATE', 'CEILING', 'FLOOR']","title":"add"},{"location":"extensions/functions_arithmetic/#subtract","text":"Implementations: subtract( x , y , option:overflow ): -> return_type 0. subtract( i8 , i8 , option:overflow ): -> i8 1. subtract( i16 , i16 , option:overflow ): -> i16 2. subtract( i32 , i32 , option:overflow ): -> i32 3. subtract( i64 , i64 , option:overflow ): -> i64 4. subtract( fp32 , fp32 , option:rounding ): -> fp32 5. subtract( fp64 , fp64 , option:rounding ): -> fp64 Subtract one value from another. Options: overflow ['SILENT', 'SATURATE', 'ERROR'] rounding ['TIE_TO_EVEN', 'TIE_AWAY_FROM_ZERO', 'TRUNCATE', 'CEILING', 'FLOOR']","title":"subtract"},{"location":"extensions/functions_arithmetic/#multiply","text":"Implementations: multiply( x , y , option:overflow ): -> return_type 0. multiply( i8 , i8 , option:overflow ): -> i8 1. multiply( i16 , i16 , option:overflow ): -> i16 2. multiply( i32 , i32 , option:overflow ): -> i32 3. multiply( i64 , i64 , option:overflow ): -> i64 4. multiply( fp32 , fp32 , option:rounding ): -> fp32 5. multiply( fp64 , fp64 , option:rounding ): -> fp64 Multiply two values. Options: overflow ['SILENT', 'SATURATE', 'ERROR'] rounding ['TIE_TO_EVEN', 'TIE_AWAY_FROM_ZERO', 'TRUNCATE', 'CEILING', 'FLOOR']","title":"multiply"},{"location":"extensions/functions_arithmetic/#divide","text":"Implementations: divide( x , y , option:overflow ): -> return_type 0. divide( i8 , i8 , option:overflow ): -> i8 1. divide( i16 , i16 , option:overflow ): -> i16 2. divide( i32 , i32 , option:overflow ): -> i32 3. divide( i64 , i64 , option:overflow ): -> i64 4. divide( fp32 , fp32 , option:rounding , option:on_domain_error , option:on_division_by_zero ): -> fp32 5. divide( fp64 , fp64 , option:rounding , option:on_domain_error , option:on_division_by_zero ): -> fp64 *Divide x by y. In the case of integer division, partial values are truncated (i.e. rounded towards 0). The on_division_by_zero option governs behavior in cases where y is 0 and x is not 0. LIMIT means positive or negative infinity (depending on the sign of x and y). If x and y are both 0 or both \u00b1infinity, behavior will be governed by on_domain_error . * Options: overflow ['SILENT', 'SATURATE', 'ERROR'] rounding ['TIE_TO_EVEN', 'TIE_AWAY_FROM_ZERO', 'TRUNCATE', 'CEILING', 'FLOOR'] on_domain_error ['NAN', 'ERROR'] on_division_by_zero ['LIMIT', 'NAN', 'ERROR']","title":"divide"},{"location":"extensions/functions_arithmetic/#negate","text":"Implementations: negate( x , option:overflow ): -> return_type 0. negate( i8 , option:overflow ): -> i8 1. negate( i16 , option:overflow ): -> i16 2. negate( i32 , option:overflow ): -> i32 3. negate( i64 , option:overflow ): -> i64 4. negate( fp32 ): -> fp32 5. negate( fp64 ): -> fp64 Negation of the value Options: overflow ['SILENT', 'SATURATE', 'ERROR']","title":"negate"},{"location":"extensions/functions_arithmetic/#modulus","text":"Implementations: modulus( x , y ): -> return_type 0. modulus( i8 , i8 ): -> i8 1. modulus( i16 , i16 ): -> i16 2. modulus( i32 , i32 ): -> i32 3. modulus( i64 , i64 ): -> i64 Get the remainder when dividing one value by another.","title":"modulus"},{"location":"extensions/functions_arithmetic/#power","text":"Implementations: power( x , y , option:overflow ): -> return_type 0. power( i64 , i64 , option:overflow ): -> i64 1. power( fp32 , fp32 ): -> fp32 2. power( fp64 , fp64 ): -> fp64 Take the power with x as the base and y as exponent. Options: overflow ['SILENT', 'SATURATE', 'ERROR']","title":"power"},{"location":"extensions/functions_arithmetic/#sqrt","text":"Implementations: sqrt( x , option:rounding , option:on_domain_error ): -> return_type 0. sqrt( i64 , option:rounding , option:on_domain_error ): -> fp64 1. sqrt( fp32 , option:rounding , option:on_domain_error ): -> fp32 2. sqrt( fp64 , option:rounding , option:on_domain_error ): -> fp64 Square root of the value Options: rounding ['TIE_TO_EVEN', 'TIE_AWAY_FROM_ZERO', 'TRUNCATE', 'CEILING', 'FLOOR'] on_domain_error ['NAN', 'ERROR']","title":"sqrt"},{"location":"extensions/functions_arithmetic/#exp","text":"Implementations: exp( x , option:rounding ): -> return_type 0. exp( fp32 , option:rounding ): -> fp32 1. exp( fp64 , option:rounding ): -> fp64 The mathematical constant e, raised to the power of the value. Options: rounding ['TIE_TO_EVEN', 'TIE_AWAY_FROM_ZERO', 'TRUNCATE', 'CEILING', 'FLOOR']","title":"exp"},{"location":"extensions/functions_arithmetic/#cos","text":"Implementations: cos( x , option:rounding ): -> return_type 0. cos( fp32 , option:rounding ): -> fp64 1. cos( fp64 , option:rounding ): -> fp64 Get the cosine of a value in radians. Options: rounding ['TIE_TO_EVEN', 'TIE_AWAY_FROM_ZERO', 'TRUNCATE', 'CEILING', 'FLOOR']","title":"cos"},{"location":"extensions/functions_arithmetic/#sin","text":"Implementations: sin( x , option:rounding ): -> return_type 0. sin( fp32 , option:rounding ): -> fp64 1. sin( fp64 , option:rounding ): -> fp64 Get the sine of a value in radians. Options: rounding ['TIE_TO_EVEN', 'TIE_AWAY_FROM_ZERO', 'TRUNCATE', 'CEILING', 'FLOOR']","title":"sin"},{"location":"extensions/functions_arithmetic/#tan","text":"Implementations: tan( x , option:rounding ): -> return_type 0. tan( fp32 , option:rounding ): -> fp64 1. tan( fp64 , option:rounding ): -> fp64 Get the tangent of a value in radians. Options: rounding ['TIE_TO_EVEN', 'TIE_AWAY_FROM_ZERO', 'TRUNCATE', 'CEILING', 'FLOOR']","title":"tan"},{"location":"extensions/functions_arithmetic/#cosh","text":"Implementations: cosh( x , option:rounding ): -> return_type 0. cosh( fp32 , option:rounding ): -> fp32 1. cosh( fp64 , option:rounding ): -> fp64 Get the hyperbolic cosine of a value in radians. Options: rounding ['TIE_TO_EVEN', 'TIE_AWAY_FROM_ZERO', 'TRUNCATE', 'CEILING', 'FLOOR']","title":"cosh"},{"location":"extensions/functions_arithmetic/#sinh","text":"Implementations: sinh( x , option:rounding ): -> return_type 0. sinh( fp32 , option:rounding ): -> fp32 1. sinh( fp64 , option:rounding ): -> fp64 Get the hyperbolic sine of a value in radians. Options: rounding ['TIE_TO_EVEN', 'TIE_AWAY_FROM_ZERO', 'TRUNCATE', 'CEILING', 'FLOOR']","title":"sinh"},{"location":"extensions/functions_arithmetic/#tanh","text":"Implementations: tanh( x , option:rounding ): -> return_type 0. tanh( fp32 , option:rounding ): -> fp32 1. tanh( fp64 , option:rounding ): -> fp64 Get the hyperbolic tangent of a value in radians. Options: rounding ['TIE_TO_EVEN', 'TIE_AWAY_FROM_ZERO', 'TRUNCATE', 'CEILING', 'FLOOR']","title":"tanh"},{"location":"extensions/functions_arithmetic/#acos","text":"Implementations: acos( x , option:rounding , option:on_domain_error ): -> return_type 0. acos( fp32 , option:rounding , option:on_domain_error ): -> fp64 1. acos( fp64 , option:rounding , option:on_domain_error ): -> fp64 Get the arccosine of a value in radians. Options: rounding ['TIE_TO_EVEN', 'TIE_AWAY_FROM_ZERO', 'TRUNCATE', 'CEILING', 'FLOOR'] on_domain_error ['NAN', 'ERROR']","title":"acos"},{"location":"extensions/functions_arithmetic/#asin","text":"Implementations: asin( x , option:rounding , option:on_domain_error ): -> return_type 0. asin( fp32 , option:rounding , option:on_domain_error ): -> fp64 1. asin( fp64 , option:rounding , option:on_domain_error ): -> fp64 Get the arcsine of a value in radians. Options: rounding ['TIE_TO_EVEN', 'TIE_AWAY_FROM_ZERO', 'TRUNCATE', 'CEILING', 'FLOOR'] on_domain_error ['NAN', 'ERROR']","title":"asin"},{"location":"extensions/functions_arithmetic/#atan","text":"Implementations: atan( x , option:rounding ): -> return_type 0. atan( fp32 , option:rounding ): -> fp64 1. atan( fp64 , option:rounding ): -> fp64 Get the arctangent of a value in radians. Options: rounding ['TIE_TO_EVEN', 'TIE_AWAY_FROM_ZERO', 'TRUNCATE', 'CEILING', 'FLOOR']","title":"atan"},{"location":"extensions/functions_arithmetic/#acosh","text":"Implementations: acosh( x , option:rounding , option:on_domain_error ): -> return_type 0. acosh( fp32 , option:rounding , option:on_domain_error ): -> fp32 1. acosh( fp64 , option:rounding , option:on_domain_error ): -> fp64 Get the hyperbolic arccosine of a value in radians. Options: rounding ['TIE_TO_EVEN', 'TIE_AWAY_FROM_ZERO', 'TRUNCATE', 'CEILING', 'FLOOR'] on_domain_error ['NAN', 'ERROR']","title":"acosh"},{"location":"extensions/functions_arithmetic/#asinh","text":"Implementations: asinh( x , option:rounding ): -> return_type 0. asinh( fp32 , option:rounding ): -> fp32 1. asinh( fp64 , option:rounding ): -> fp64 Get the hyperbolic arcsine of a value in radians. Options: rounding ['TIE_TO_EVEN', 'TIE_AWAY_FROM_ZERO', 'TRUNCATE', 'CEILING', 'FLOOR']","title":"asinh"},{"location":"extensions/functions_arithmetic/#atanh","text":"Implementations: atanh( x , option:rounding , option:on_domain_error ): -> return_type 0. atanh( fp32 , option:rounding , option:on_domain_error ): -> fp32 1. atanh( fp64 , option:rounding , option:on_domain_error ): -> fp64 Get the hyperbolic arctangent of a value in radians. Options: rounding ['TIE_TO_EVEN', 'TIE_AWAY_FROM_ZERO', 'TRUNCATE', 'CEILING', 'FLOOR'] on_domain_error ['NAN', 'ERROR']","title":"atanh"},{"location":"extensions/functions_arithmetic/#atan2","text":"Implementations: atan2( x , y , option:rounding , option:on_domain_error ): -> return_type 0. atan2( fp32 , fp32 , option:rounding , option:on_domain_error ): -> fp64 1. atan2( fp64 , fp64 , option:rounding , option:on_domain_error ): -> fp64 Get the arctangent of values given as x/y pairs. Options: rounding ['TIE_TO_EVEN', 'TIE_AWAY_FROM_ZERO', 'TRUNCATE', 'CEILING', 'FLOOR'] on_domain_error ['NAN', 'ERROR']","title":"atan2"},{"location":"extensions/functions_arithmetic/#abs","text":"Implementations: abs( x , option:overflow ): -> return_type 0. abs( i8 , option:overflow ): -> i8 1. abs( i16 , option:overflow ): -> i16 2. abs( i32 , option:overflow ): -> i32 3. abs( i64 , option:overflow ): -> i64 4. abs( fp32 ): -> fp32 5. abs( fp64 ): -> fp64 *Calculate the absolute value of the argument. Integer values allow the specification of overflow behavior to handle the unevenness of the twos complement, e.g. Int8 range [-128 : 127]. * Options: overflow ['SILENT', 'SATURATE', 'ERROR']","title":"abs"},{"location":"extensions/functions_arithmetic/#sign","text":"Implementations: sign( x ): -> return_type 0. sign( i8 ): -> i8 1. sign( i16 ): -> i16 2. sign( i32 ): -> i32 3. sign( i64 ): -> i64 4. sign( fp32 ): -> fp32 5. sign( fp64 ): -> fp64 *Return the signedness of the argument. Integer values return signedness with the same type as the input. Possible return values are [-1, 0, 1] Floating point values return signedness with the same type as the input. Possible return values are [-1.0, -0.0, 0.0, 1.0, NaN] *","title":"sign"},{"location":"extensions/functions_arithmetic/#factorial","text":"Implementations: factorial( n , option:overflow ): -> return_type 0. factorial( i32 , option:overflow ): -> i32 1. factorial( i64 , option:overflow ): -> i64 *Return the factorial of a given integer input. The factorial of 0! is 1 by convention. Negative inputs will raise an error. * Options: overflow ['SILENT', 'SATURATE', 'ERROR']","title":"factorial"},{"location":"extensions/functions_arithmetic/#bitwise_not","text":"Implementations: bitwise_not( x ): -> return_type 0. bitwise_not( i8 ): -> i8 1. bitwise_not( i16 ): -> i16 2. bitwise_not( i32 ): -> i32 3. bitwise_not( i64 ): -> i64 *Return the bitwise NOT result for one integer input. *","title":"bitwise_not"},{"location":"extensions/functions_arithmetic/#bitwise_and","text":"Implementations: bitwise_and( x , y ): -> return_type 0. bitwise_and( i8 , i8 ): -> i8 1. bitwise_and( i16 , i16 ): -> i16 2. bitwise_and( i32 , i32 ): -> i32 3. bitwise_and( i64 , i64 ): -> i64 *Return the bitwise AND result for two integer inputs. *","title":"bitwise_and"},{"location":"extensions/functions_arithmetic/#bitwise_or","text":"Implementations: bitwise_or( x , y ): -> return_type 0. bitwise_or( i8 , i8 ): -> i8 1. bitwise_or( i16 , i16 ): -> i16 2. bitwise_or( i32 , i32 ): -> i32 3. bitwise_or( i64 , i64 ): -> i64 *Return the bitwise OR result for two given integer inputs. *","title":"bitwise_or"},{"location":"extensions/functions_arithmetic/#bitwise_xor","text":"Implementations: bitwise_xor( x , y ): -> return_type 0. bitwise_xor( i8 , i8 ): -> i8 1. bitwise_xor( i16 , i16 ): -> i16 2. bitwise_xor( i32 , i32 ): -> i32 3. bitwise_xor( i64 , i64 ): -> i64 *Return the bitwise XOR result for two integer inputs. *","title":"bitwise_xor"},{"location":"extensions/functions_arithmetic/#aggregate-functions","text":"","title":"Aggregate Functions"},{"location":"extensions/functions_arithmetic/#sum","text":"Implementations: sum( x , option:overflow ): -> return_type 0. sum( i8 , option:overflow ): -> i64? 1. sum( i16 , option:overflow ): -> i64? 2. sum( i32 , option:overflow ): -> i64? 3. sum( i64 , option:overflow ): -> i64? 4. sum( fp32 , option:overflow ): -> fp64? 5. sum( fp64 , option:overflow ): -> fp64? Sum a set of values. The sum of zero elements yields null. Options: overflow ['SILENT', 'SATURATE', 'ERROR']","title":"sum"},{"location":"extensions/functions_arithmetic/#sum0","text":"Implementations: sum0( x , option:overflow ): -> return_type 0. sum0( i8 , option:overflow ): -> i64 1. sum0( i16 , option:overflow ): -> i64 2. sum0( i32 , option:overflow ): -> i64 3. sum0( i64 , option:overflow ): -> i64 4. sum0( fp32 , option:overflow ): -> fp64 5. sum0( fp64 , option:overflow ): -> fp64 *Sum a set of values. The sum of zero elements yields zero. Null values are ignored. * Options: overflow ['SILENT', 'SATURATE', 'ERROR']","title":"sum0"},{"location":"extensions/functions_arithmetic/#avg","text":"Implementations: avg( x , option:overflow ): -> return_type 0. avg( i8 , option:overflow ): -> i8? 1. avg( i16 , option:overflow ): -> i16? 2. avg( i32 , option:overflow ): -> i32? 3. avg( i64 , option:overflow ): -> i64? 4. avg( fp32 , option:overflow ): -> fp32? 5. avg( fp64 , option:overflow ): -> fp64? Average a set of values. For integral types, this truncates partial values. Options: overflow ['SILENT', 'SATURATE', 'ERROR']","title":"avg"},{"location":"extensions/functions_arithmetic/#min","text":"Implementations: min( x ): -> return_type 0. min( i8 ): -> i8? 1. min( i16 ): -> i16? 2. min( i32 ): -> i32? 3. min( i64 ): -> i64? 4. min( fp32 ): -> fp32? 5. min( fp64 ): -> fp64? Min a set of values.","title":"min"},{"location":"extensions/functions_arithmetic/#max","text":"Implementations: max( x ): -> return_type 0. max( i8 ): -> i8? 1. max( i16 ): -> i16? 2. max( i32 ): -> i32? 3. max( i64 ): -> i64? 4. max( fp32 ): -> fp32? 5. max( fp64 ): -> fp64? Max a set of values.","title":"max"},{"location":"extensions/functions_arithmetic/#product","text":"Implementations: product( x , option:overflow ): -> return_type 0. product( i8 , option:overflow ): -> i8 1. product( i16 , option:overflow ): -> i16 2. product( i32 , option:overflow ): -> i32 3. product( i64 , option:overflow ): -> i64 4. product( fp32 , option:rounding ): -> fp32 5. product( fp64 , option:rounding ): -> fp64 Product of a set of values. Returns 1 for empty input. Options: overflow ['SILENT', 'SATURATE', 'ERROR'] rounding ['TIE_TO_EVEN', 'TIE_AWAY_FROM_ZERO', 'TRUNCATE', 'CEILING', 'FLOOR']","title":"product"},{"location":"extensions/functions_arithmetic/#std_dev","text":"Implementations: std_dev( x , option:rounding , option:distribution ): -> return_type 0. std_dev( fp32 , option:rounding , option:distribution ): -> fp32? 1. std_dev( fp64 , option:rounding , option:distribution ): -> fp64? Calculates standard-deviation for a set of values. Options: rounding ['TIE_TO_EVEN', 'TIE_AWAY_FROM_ZERO', 'TRUNCATE', 'CEILING', 'FLOOR'] distribution ['SAMPLE', 'POPULATION']","title":"std_dev"},{"location":"extensions/functions_arithmetic/#variance","text":"Implementations: variance( x , option:rounding , option:distribution ): -> return_type 0. variance( fp32 , option:rounding , option:distribution ): -> fp32? 1. variance( fp64 , option:rounding , option:distribution ): -> fp64? Calculates variance for a set of values. Options: rounding ['TIE_TO_EVEN', 'TIE_AWAY_FROM_ZERO', 'TRUNCATE', 'CEILING', 'FLOOR'] distribution ['SAMPLE', 'POPULATION']","title":"variance"},{"location":"extensions/functions_arithmetic/#corr","text":"Implementations: corr( x , y , option:rounding ): -> return_type 0. corr( fp32 , fp32 , option:rounding ): -> fp32? 1. corr( fp64 , fp64 , option:rounding ): -> fp64? *Calculates the value of Pearson\u2019s correlation coefficient between x and y . If there is no input, null is returned. * Options: rounding ['TIE_TO_EVEN', 'TIE_AWAY_FROM_ZERO', 'TRUNCATE', 'CEILING', 'FLOOR']","title":"corr"},{"location":"extensions/functions_arithmetic/#mode","text":"Implementations: mode( x ): -> return_type 0. mode( i8 ): -> i8? 1. mode( i16 ): -> i16? 2. mode( i32 ): -> i32? 3. mode( i64 ): -> i64? 4. mode( fp32 ): -> fp32? 5. mode( fp64 ): -> fp64? *Calculates mode for a set of values. If there is no input, null is returned. *","title":"mode"},{"location":"extensions/functions_arithmetic/#median","text":"Implementations: median( precision , x , option:rounding ): -> return_type 0. median( precision , i8 , option:rounding ): -> i8? 1. median( precision , i16 , option:rounding ): -> i16? 2. median( precision , i32 , option:rounding ): -> i32? 3. median( precision , i64 , option:rounding ): -> i64? 4. median( precision , fp32 , option:rounding ): -> fp32? 5. median( precision , fp64 , option:rounding ): -> fp64? *Calculate the median for a set of values. Returns null if applied to zero records. For the integer implementations, the rounding option determines how the median should be rounded if it ends up midway between two values. For the floating point implementations, they specify the usual floating point rounding mode. * Options: precision ['EXACT', 'APPROXIMATE'] rounding ['TIE_TO_EVEN', 'TIE_AWAY_FROM_ZERO', 'TRUNCATE', 'CEILING', 'FLOOR']","title":"median"},{"location":"extensions/functions_arithmetic/#quantile","text":"Implementations: quantile( boundaries , precision , n , distribution , option:rounding ): -> return_type n: A positive integer which defines the number of quantile partitions. distribution: The data for which the quantiles should be computed. 0. quantile( boundaries , precision , i64 , any , option:rounding ): -> LIST?<any> *Calculates quantiles for a set of values. This function will divide the aggregated values (passed via the distribution argument) over N equally-sized bins, where N is passed via a constant argument. It will then return the values at the boundaries of these bins in list form. If the input is appropriately sorted, this computes the quantiles of the distribution. The function can optionally return the first and/or last element of the input, as specified by the boundaries argument. If the input is appropriately sorted, this will thus be the minimum and/or maximum values of the distribution. When the boundaries do not lie exactly on elements of the incoming distribution, the function will interpolate between the two nearby elements. If the interpolated value cannot be represented exactly, the rounding option controls how the value should be selected or computed. The function fails and returns null in the following cases: - n is null or less than one; - any value in distribution is null. The function returns an empty list if n equals 1 and boundaries is set to NEITHER . * Options: boundaries ['NEITHER', 'MINIMUM', 'MAXIMUM', 'BOTH'] precision ['EXACT', 'APPROXIMATE'] rounding ['TIE_TO_EVEN', 'TIE_AWAY_FROM_ZERO', 'TRUNCATE', 'CEILING', 'FLOOR']","title":"quantile"},{"location":"extensions/functions_arithmetic/#window-functions","text":"","title":"Window Functions"},{"location":"extensions/functions_arithmetic/#row_number","text":"Implementations: 0. row_number(): -> i64? the number of the current row within its partition.","title":"row_number"},{"location":"extensions/functions_arithmetic/#rank","text":"Implementations: 0. rank(): -> i64? the rank of the current row, with gaps.","title":"rank"},{"location":"extensions/functions_arithmetic/#dense_rank","text":"Implementations: 0. dense_rank(): -> i64? the rank of the current row, without gaps.","title":"dense_rank"},{"location":"extensions/functions_arithmetic/#percent_rank","text":"Implementations: 0. percent_rank(): -> fp64? the relative rank of the current row.","title":"percent_rank"},{"location":"extensions/functions_arithmetic/#cume_dist","text":"Implementations: 0. cume_dist(): -> fp64? the cumulative distribution.","title":"cume_dist"},{"location":"extensions/functions_arithmetic/#ntile","text":"Implementations: ntile( x ): -> return_type 0. ntile( i32 ): -> i32? 1. ntile( i64 ): -> i64? Return an integer ranging from 1 to the argument value,dividing the partition as equally as possible.","title":"ntile"},{"location":"extensions/functions_arithmetic_decimal/","text":"functions_arithmetic_decimal.yaml \u00b6 This document file is generated for functions_arithmetic_decimal.yaml Scalar Functions \u00b6 add \u00b6 Implementations: add( x , y , option:overflow ): -> return_type 0. add( decimal<P1,S1> , decimal<P2,S2> , option:overflow ): -> init_scale = max(S1,S2) init_prec = init_scale + max(P1 - S1, P2 - S2) + 1 min_scale = min(init_scale, 6) delta = init_prec - 38 prec = min(init_prec, 38) scale_after_borrow = max(init_scale - delta, min_scale) scale = init_prec > 38 ? scale_after_borrow : init_scale DECIMAL<prec, scale> Add two decimal values. Options: overflow ['SILENT', 'SATURATE', 'ERROR'] subtract \u00b6 Implementations: subtract( x , y , option:overflow ): -> return_type 0. subtract( decimal<P1,S1> , decimal<P2,S2> , option:overflow ): -> init_scale = max(S1,S2) init_prec = init_scale + max(P1 - S1, P2 - S2) + 1 min_scale = min(init_scale, 6) delta = init_prec - 38 prec = min(init_prec, 38) scale_after_borrow = max(init_scale - delta, min_scale) scale = init_prec > 38 ? scale_after_borrow : init_scale DECIMAL<prec, scale> Options: overflow ['SILENT', 'SATURATE', 'ERROR'] multiply \u00b6 Implementations: multiply( x , y , option:overflow ): -> return_type 0. multiply( decimal<P1,S1> , decimal<P2,S2> , option:overflow ): -> init_scale = S1 + S2 init_prec = P1 + P2 + 1 min_scale = min(init_scale, 6) delta = init_prec - 38 prec = min(init_prec, 38) scale_after_borrow = max(init_scale - delta, min_scale) scale = init_prec > 38 ? scale_after_borrow : init_scale DECIMAL<prec, scale> Options: overflow ['SILENT', 'SATURATE', 'ERROR'] divide \u00b6 Implementations: divide( x , y , option:overflow ): -> return_type 0. divide( decimal<P1,S1> , decimal<P2,S2> , option:overflow ): -> init_scale = max(6, S1 + P2 + 1) init_prec = P1 - S1 + P2 + init_scale min_scale = min(init_scale, 6) delta = init_prec - 38 prec = min(init_prec, 38) scale_after_borrow = max(init_scale - delta, min_scale) scale = init_prec > 38 ? scale_after_borrow : init_scale DECIMAL<prec, scale> Options: overflow ['SILENT', 'SATURATE', 'ERROR'] modulus \u00b6 Implementations: modulus( x , y , option:overflow ): -> return_type 0. modulus( decimal<P1,S1> , decimal<P2,S2> , option:overflow ): -> init_scale = max(S1,S2) init_prec = min(P1 - S1, P2 - S2) + init_scale min_scale = min(init_scale, 6) delta = init_prec - 38 prec = min(init_prec, 38) scale_after_borrow = max(init_scale - delta, min_scale) scale = init_prec > 38 ? scale_after_borrow : init_scale DECIMAL<prec, scale> Options: overflow ['SILENT', 'SATURATE', 'ERROR'] Aggregate Functions \u00b6 sum \u00b6 Implementations: sum( x , option:overflow ): -> return_type 0. sum( DECIMAL<P, S> , option:overflow ): -> DECIMAL?<38,S> Sum a set of values. Options: overflow ['SILENT', 'SATURATE', 'ERROR'] avg \u00b6 Implementations: avg( x , option:overflow ): -> return_type 0. avg( DECIMAL<P,S> , option:overflow ): -> DECIMAL<38,S> Average a set of values. Options: overflow ['SILENT', 'SATURATE', 'ERROR'] min \u00b6 Implementations: min( x ): -> return_type 0. min( DECIMAL<P, S> ): -> DECIMAL?<P, S> Min a set of values. max \u00b6 Implementations: max( x ): -> return_type 0. max( DECIMAL<P,S> ): -> DECIMAL?<P, S> Max a set of values.","title":"functions_arithmetic_decimal.yaml"},{"location":"extensions/functions_arithmetic_decimal/#functions_arithmetic_decimalyaml","text":"This document file is generated for functions_arithmetic_decimal.yaml","title":"functions_arithmetic_decimal.yaml"},{"location":"extensions/functions_arithmetic_decimal/#scalar-functions","text":"","title":"Scalar Functions"},{"location":"extensions/functions_arithmetic_decimal/#add","text":"Implementations: add( x , y , option:overflow ): -> return_type 0. add( decimal<P1,S1> , decimal<P2,S2> , option:overflow ): -> init_scale = max(S1,S2) init_prec = init_scale + max(P1 - S1, P2 - S2) + 1 min_scale = min(init_scale, 6) delta = init_prec - 38 prec = min(init_prec, 38) scale_after_borrow = max(init_scale - delta, min_scale) scale = init_prec > 38 ? scale_after_borrow : init_scale DECIMAL<prec, scale> Add two decimal values. Options: overflow ['SILENT', 'SATURATE', 'ERROR']","title":"add"},{"location":"extensions/functions_arithmetic_decimal/#subtract","text":"Implementations: subtract( x , y , option:overflow ): -> return_type 0. subtract( decimal<P1,S1> , decimal<P2,S2> , option:overflow ): -> init_scale = max(S1,S2) init_prec = init_scale + max(P1 - S1, P2 - S2) + 1 min_scale = min(init_scale, 6) delta = init_prec - 38 prec = min(init_prec, 38) scale_after_borrow = max(init_scale - delta, min_scale) scale = init_prec > 38 ? scale_after_borrow : init_scale DECIMAL<prec, scale> Options: overflow ['SILENT', 'SATURATE', 'ERROR']","title":"subtract"},{"location":"extensions/functions_arithmetic_decimal/#multiply","text":"Implementations: multiply( x , y , option:overflow ): -> return_type 0. multiply( decimal<P1,S1> , decimal<P2,S2> , option:overflow ): -> init_scale = S1 + S2 init_prec = P1 + P2 + 1 min_scale = min(init_scale, 6) delta = init_prec - 38 prec = min(init_prec, 38) scale_after_borrow = max(init_scale - delta, min_scale) scale = init_prec > 38 ? scale_after_borrow : init_scale DECIMAL<prec, scale> Options: overflow ['SILENT', 'SATURATE', 'ERROR']","title":"multiply"},{"location":"extensions/functions_arithmetic_decimal/#divide","text":"Implementations: divide( x , y , option:overflow ): -> return_type 0. divide( decimal<P1,S1> , decimal<P2,S2> , option:overflow ): -> init_scale = max(6, S1 + P2 + 1) init_prec = P1 - S1 + P2 + init_scale min_scale = min(init_scale, 6) delta = init_prec - 38 prec = min(init_prec, 38) scale_after_borrow = max(init_scale - delta, min_scale) scale = init_prec > 38 ? scale_after_borrow : init_scale DECIMAL<prec, scale> Options: overflow ['SILENT', 'SATURATE', 'ERROR']","title":"divide"},{"location":"extensions/functions_arithmetic_decimal/#modulus","text":"Implementations: modulus( x , y , option:overflow ): -> return_type 0. modulus( decimal<P1,S1> , decimal<P2,S2> , option:overflow ): -> init_scale = max(S1,S2) init_prec = min(P1 - S1, P2 - S2) + init_scale min_scale = min(init_scale, 6) delta = init_prec - 38 prec = min(init_prec, 38) scale_after_borrow = max(init_scale - delta, min_scale) scale = init_prec > 38 ? scale_after_borrow : init_scale DECIMAL<prec, scale> Options: overflow ['SILENT', 'SATURATE', 'ERROR']","title":"modulus"},{"location":"extensions/functions_arithmetic_decimal/#aggregate-functions","text":"","title":"Aggregate Functions"},{"location":"extensions/functions_arithmetic_decimal/#sum","text":"Implementations: sum( x , option:overflow ): -> return_type 0. sum( DECIMAL<P, S> , option:overflow ): -> DECIMAL?<38,S> Sum a set of values. Options: overflow ['SILENT', 'SATURATE', 'ERROR']","title":"sum"},{"location":"extensions/functions_arithmetic_decimal/#avg","text":"Implementations: avg( x , option:overflow ): -> return_type 0. avg( DECIMAL<P,S> , option:overflow ): -> DECIMAL<38,S> Average a set of values. Options: overflow ['SILENT', 'SATURATE', 'ERROR']","title":"avg"},{"location":"extensions/functions_arithmetic_decimal/#min","text":"Implementations: min( x ): -> return_type 0. min( DECIMAL<P, S> ): -> DECIMAL?<P, S> Min a set of values.","title":"min"},{"location":"extensions/functions_arithmetic_decimal/#max","text":"Implementations: max( x ): -> return_type 0. max( DECIMAL<P,S> ): -> DECIMAL?<P, S> Max a set of values.","title":"max"},{"location":"extensions/functions_boolean/","text":"functions_boolean.yaml \u00b6 This document file is generated for functions_boolean.yaml Scalar Functions \u00b6 or \u00b6 Implementations: or( a ): -> return_type 0. or( boolean? ): -> boolean? *The boolean or using Kleene logic. This function behaves as follows with nulls: true or null = true null or true = true false or null = null null or false = null null or null = null In other words, in this context a null value really means \u201cunknown\u201d, and an unknown value or true is always true. Behavior for 0 or 1 inputs is as follows: or() -> false or(x) -> x * and \u00b6 Implementations: and( a ): -> return_type 0. and( boolean? ): -> boolean? *The boolean and using Kleene logic. This function behaves as follows with nulls: true and null = null null and true = null false and null = false null and false = false null and null = null In other words, in this context a null value really means \u201cunknown\u201d, and an unknown value and false is always false. Behavior for 0 or 1 inputs is as follows: and() -> true and(x) -> x * and_not \u00b6 Implementations: and_not( a , b ): -> return_type 0. and_not( boolean? , boolean? ): -> boolean? *The boolean and of one value and the negation of the other using Kleene logic. This function behaves as follows with nulls: true and not null = null null and not false = null false and not null = false null and not true = false null and not null = null In other words, in this context a null value really means \u201cunknown\u201d, and an unknown value and not true is always false, as is false and not an unknown value. * xor \u00b6 Implementations: xor( a , b ): -> return_type 0. xor( boolean? , boolean? ): -> boolean? *The boolean xor of two values using Kleene logic. When a null is encountered in either input, a null is output. * not \u00b6 Implementations: not( a ): -> return_type 0. not( boolean? ): -> boolean? *The not of a boolean value. When a null is input, a null is output. * Aggregate Functions \u00b6 bool_and \u00b6 Implementations: bool_and( a ): -> return_type 0. bool_and( boolean ): -> boolean? *If any value in the input is false, false is returned. If the input is empty or only contains nulls, null is returned. Otherwise, true is returned. * bool_or \u00b6 Implementations: bool_or( a ): -> return_type 0. bool_or( boolean ): -> boolean? *If any value in the input is true, true is returned. If the input is empty or only contains nulls, null is returned. Otherwise, false is returned. *","title":"functions_boolean.yaml"},{"location":"extensions/functions_boolean/#functions_booleanyaml","text":"This document file is generated for functions_boolean.yaml","title":"functions_boolean.yaml"},{"location":"extensions/functions_boolean/#scalar-functions","text":"","title":"Scalar Functions"},{"location":"extensions/functions_boolean/#or","text":"Implementations: or( a ): -> return_type 0. or( boolean? ): -> boolean? *The boolean or using Kleene logic. This function behaves as follows with nulls: true or null = true null or true = true false or null = null null or false = null null or null = null In other words, in this context a null value really means \u201cunknown\u201d, and an unknown value or true is always true. Behavior for 0 or 1 inputs is as follows: or() -> false or(x) -> x *","title":"or"},{"location":"extensions/functions_boolean/#and","text":"Implementations: and( a ): -> return_type 0. and( boolean? ): -> boolean? *The boolean and using Kleene logic. This function behaves as follows with nulls: true and null = null null and true = null false and null = false null and false = false null and null = null In other words, in this context a null value really means \u201cunknown\u201d, and an unknown value and false is always false. Behavior for 0 or 1 inputs is as follows: and() -> true and(x) -> x *","title":"and"},{"location":"extensions/functions_boolean/#and_not","text":"Implementations: and_not( a , b ): -> return_type 0. and_not( boolean? , boolean? ): -> boolean? *The boolean and of one value and the negation of the other using Kleene logic. This function behaves as follows with nulls: true and not null = null null and not false = null false and not null = false null and not true = false null and not null = null In other words, in this context a null value really means \u201cunknown\u201d, and an unknown value and not true is always false, as is false and not an unknown value. *","title":"and_not"},{"location":"extensions/functions_boolean/#xor","text":"Implementations: xor( a , b ): -> return_type 0. xor( boolean? , boolean? ): -> boolean? *The boolean xor of two values using Kleene logic. When a null is encountered in either input, a null is output. *","title":"xor"},{"location":"extensions/functions_boolean/#not","text":"Implementations: not( a ): -> return_type 0. not( boolean? ): -> boolean? *The not of a boolean value. When a null is input, a null is output. *","title":"not"},{"location":"extensions/functions_boolean/#aggregate-functions","text":"","title":"Aggregate Functions"},{"location":"extensions/functions_boolean/#bool_and","text":"Implementations: bool_and( a ): -> return_type 0. bool_and( boolean ): -> boolean? *If any value in the input is false, false is returned. If the input is empty or only contains nulls, null is returned. Otherwise, true is returned. *","title":"bool_and"},{"location":"extensions/functions_boolean/#bool_or","text":"Implementations: bool_or( a ): -> return_type 0. bool_or( boolean ): -> boolean? *If any value in the input is true, true is returned. If the input is empty or only contains nulls, null is returned. Otherwise, false is returned. *","title":"bool_or"},{"location":"extensions/functions_comparison/","text":"functions_comparison.yaml \u00b6 This document file is generated for functions_comparison.yaml Scalar Functions \u00b6 not_equal \u00b6 Implementations: not_equal( x , y ): -> return_type 0. not_equal( any1 , any1 ): -> BOOLEAN *Whether two values are not_equal. not_equal(x, y) := (x != y) If either/both of x and y are null , null is returned. * equal \u00b6 Implementations: equal( x , y ): -> return_type 0. equal( any1 , any1 ): -> BOOLEAN *Whether two values are equal. equal(x, y) := (x == y) If either/both of x and y are null , null is returned. * is_not_distinct_from \u00b6 Implementations: is_not_distinct_from( x , y ): -> return_type 0. is_not_distinct_from( any1 , any1 ): -> BOOLEAN *Whether two values are equal. This function treats null values as comparable, so is_not_distinct_from(null, null) == True This is in contrast to equal , in which null values do not compare. * lt \u00b6 Implementations: lt( x , y ): -> return_type 0. lt( any1 , any1 ): -> BOOLEAN *Less than. lt(x, y) := (x < y) If either/both of x and y are null , null is returned. * gt \u00b6 Implementations: gt( x , y ): -> return_type 0. gt( any1 , any1 ): -> BOOLEAN *Greater than. gt(x, y) := (x > y) If either/both of x and y are null , null is returned. * lte \u00b6 Implementations: lte( x , y ): -> return_type 0. lte( any1 , any1 ): -> BOOLEAN *Less than or equal to. lte(x, y) := (x <= y) If either/both of x and y are null , null is returned. * gte \u00b6 Implementations: gte( x , y ): -> return_type 0. gte( any1 , any1 ): -> BOOLEAN *Greater than or equal to. gte(x, y) := (x >= y) If either/both of x and y are null , null is returned. * between \u00b6 Implementations: between( expression , low , high ): -> return_type expression: The expression to test for in the range defined by `low` and `high`. low: The value to check if greater than or equal to. high: The value to check if less than or equal to. 0. between( any1 , any1 , any1 ): -> BOOLEAN Whether the expression is greater than or equal to low and less than or equal to high . expression BETWEEN low AND high If low , high , or expression are null , null is returned. is_null \u00b6 Implementations: is_null( x ): -> return_type 0. is_null( any1 ): -> BOOLEAN Whether a value is null. NaN is not null. is_not_null \u00b6 Implementations: is_not_null( x ): -> return_type 0. is_not_null( any1 ): -> BOOLEAN Whether a value is not null. NaN is not null. is_nan \u00b6 Implementations: is_nan( x ): -> return_type 0. is_nan( fp32 ): -> BOOLEAN 1. is_nan( fp64 ): -> BOOLEAN *Whether a value is not a number. If x is null , null is returned. * is_finite \u00b6 Implementations: is_finite( x ): -> return_type 0. is_finite( fp32 ): -> BOOLEAN 1. is_finite( fp64 ): -> BOOLEAN *Whether a value is finite (neither infinite nor NaN). If x is null , null is returned. * is_infinite \u00b6 Implementations: is_infinite( x ): -> return_type 0. is_infinite( fp32 ): -> BOOLEAN 1. is_infinite( fp64 ): -> BOOLEAN *Whether a value is infinite. If x is null , null is returned. * nullif \u00b6 Implementations: nullif( x , y ): -> return_type 0. nullif( any1 , any1 ): -> any1 If two values are equal, return null. Otherwise, return the first value. coalesce \u00b6 Implementations: 0. coalesce( any1 , any1 ): -> any1 Evaluate arguments from left to right and return the first argument that is not null. Once a non-null argument is found, the remaining arguments are not evaluated. If all arguments are null, return null.","title":"functions_comparison.yaml"},{"location":"extensions/functions_comparison/#functions_comparisonyaml","text":"This document file is generated for functions_comparison.yaml","title":"functions_comparison.yaml"},{"location":"extensions/functions_comparison/#scalar-functions","text":"","title":"Scalar Functions"},{"location":"extensions/functions_comparison/#not_equal","text":"Implementations: not_equal( x , y ): -> return_type 0. not_equal( any1 , any1 ): -> BOOLEAN *Whether two values are not_equal. not_equal(x, y) := (x != y) If either/both of x and y are null , null is returned. *","title":"not_equal"},{"location":"extensions/functions_comparison/#equal","text":"Implementations: equal( x , y ): -> return_type 0. equal( any1 , any1 ): -> BOOLEAN *Whether two values are equal. equal(x, y) := (x == y) If either/both of x and y are null , null is returned. *","title":"equal"},{"location":"extensions/functions_comparison/#is_not_distinct_from","text":"Implementations: is_not_distinct_from( x , y ): -> return_type 0. is_not_distinct_from( any1 , any1 ): -> BOOLEAN *Whether two values are equal. This function treats null values as comparable, so is_not_distinct_from(null, null) == True This is in contrast to equal , in which null values do not compare. *","title":"is_not_distinct_from"},{"location":"extensions/functions_comparison/#lt","text":"Implementations: lt( x , y ): -> return_type 0. lt( any1 , any1 ): -> BOOLEAN *Less than. lt(x, y) := (x < y) If either/both of x and y are null , null is returned. *","title":"lt"},{"location":"extensions/functions_comparison/#gt","text":"Implementations: gt( x , y ): -> return_type 0. gt( any1 , any1 ): -> BOOLEAN *Greater than. gt(x, y) := (x > y) If either/both of x and y are null , null is returned. *","title":"gt"},{"location":"extensions/functions_comparison/#lte","text":"Implementations: lte( x , y ): -> return_type 0. lte( any1 , any1 ): -> BOOLEAN *Less than or equal to. lte(x, y) := (x <= y) If either/both of x and y are null , null is returned. *","title":"lte"},{"location":"extensions/functions_comparison/#gte","text":"Implementations: gte( x , y ): -> return_type 0. gte( any1 , any1 ): -> BOOLEAN *Greater than or equal to. gte(x, y) := (x >= y) If either/both of x and y are null , null is returned. *","title":"gte"},{"location":"extensions/functions_comparison/#between","text":"Implementations: between( expression , low , high ): -> return_type expression: The expression to test for in the range defined by `low` and `high`. low: The value to check if greater than or equal to. high: The value to check if less than or equal to. 0. between( any1 , any1 , any1 ): -> BOOLEAN Whether the expression is greater than or equal to low and less than or equal to high . expression BETWEEN low AND high If low , high , or expression are null , null is returned.","title":"between"},{"location":"extensions/functions_comparison/#is_null","text":"Implementations: is_null( x ): -> return_type 0. is_null( any1 ): -> BOOLEAN Whether a value is null. NaN is not null.","title":"is_null"},{"location":"extensions/functions_comparison/#is_not_null","text":"Implementations: is_not_null( x ): -> return_type 0. is_not_null( any1 ): -> BOOLEAN Whether a value is not null. NaN is not null.","title":"is_not_null"},{"location":"extensions/functions_comparison/#is_nan","text":"Implementations: is_nan( x ): -> return_type 0. is_nan( fp32 ): -> BOOLEAN 1. is_nan( fp64 ): -> BOOLEAN *Whether a value is not a number. If x is null , null is returned. *","title":"is_nan"},{"location":"extensions/functions_comparison/#is_finite","text":"Implementations: is_finite( x ): -> return_type 0. is_finite( fp32 ): -> BOOLEAN 1. is_finite( fp64 ): -> BOOLEAN *Whether a value is finite (neither infinite nor NaN). If x is null , null is returned. *","title":"is_finite"},{"location":"extensions/functions_comparison/#is_infinite","text":"Implementations: is_infinite( x ): -> return_type 0. is_infinite( fp32 ): -> BOOLEAN 1. is_infinite( fp64 ): -> BOOLEAN *Whether a value is infinite. If x is null , null is returned. *","title":"is_infinite"},{"location":"extensions/functions_comparison/#nullif","text":"Implementations: nullif( x , y ): -> return_type 0. nullif( any1 , any1 ): -> any1 If two values are equal, return null. Otherwise, return the first value.","title":"nullif"},{"location":"extensions/functions_comparison/#coalesce","text":"Implementations: 0. coalesce( any1 , any1 ): -> any1 Evaluate arguments from left to right and return the first argument that is not null. Once a non-null argument is found, the remaining arguments are not evaluated. If all arguments are null, return null.","title":"coalesce"},{"location":"extensions/functions_datetime/","text":"functions_datetime.yaml \u00b6 This document file is generated for functions_datetime.yaml Scalar Functions \u00b6 extract \u00b6 Implementations: extract( component , x , timezone ): -> return_type x: Timezone string from IANA tzdb. 0. extract( component , timestamp_tz , string ): -> i64 1. extract( component , timestamp ): -> i64 2. extract( component , date ): -> i64 3. extract( component , time ): -> i64 Extract portion of a date/time value. * YEAR Return the year of the value. * ISO_YEAR Return the ISO 8601 week-numbering year. First week of an ISO year has the majority (4 or more) of its days in January. * US_YEAR Return US epidemiological year. First week of US epidemiological year has the majority (4 or more) of its days in January. Last week of US epidemiological year has the year\u2019s last Wednesday in it. US epidemiological week starts on Sunday. * QUARTER Return the quarter from the value (1-4). * MONTH Return the month from value (1-12). * DAY Return the day of the month (1-31). * DAY_OF_YEAR Return the day of year (1 to 366). January 1 st maps to day number 1, February 1 st to 32, etc. * MONDAY_DAY_OF_WEEK Return the day of week from Monday (1) to Sunday (7). * SUNDAY_DAY_OF_WEEK Return the day of week from Sunday (1) to Saturday (7). * MONDAY_WEEK Return week of year number (1-53). First week starts on first Monday of January. * SUNDAY_WEEK Return week of year number (1-53). First week starts on first Sunday of January. * ISO_WEEK Return ISO week of year number (1-53). First ISO calendar week has the majority (4 or more) of its days in January. ISO week starts on Monday. * US_WEEK Return ISO-like week of year number (1-53). First US calendar week has the majority (4 or more) of its days in January. US week starts on Sunday. * HOUR Return the hour (0-23). * MINUTE Return the minute (0-59). * SECOND Return the second (0-59). * MILLISECOND Return number of milliseconds since the last full second. * MICROSECOND Return number of microseconds since the last full millisecond. * SUBSECOND Return number of microseconds since the last full second of the given timestamp. * UNIX_TIME Return number of seconds that have elapsed since 1970-01-01 00:00:00 UTC, ignoring leap seconds. * TIMEZONE_OFFSET Return number of seconds of timezone offset to UTC. Timezone strings must be as defined by IANA timezone database ( https://www.iana.org/time-zones ). Examples: \u201cPacific/Marquesas\u201d, \u201cEtc/GMT+1\u201d. If timezone is invalid an error is thrown. Options: component ['YEAR', 'ISO_YEAR', 'US_YEAR', 'QUARTER', 'MONTH', 'DAY', 'DAY_OF_YEAR', 'MONDAY_DAY_OF_WEEK', 'SUNDAY_DAY_OF_WEEK', 'MONDAY_WEEK', 'SUNDAY_WEEK', 'ISO_WEEK', 'US_WEEK', 'HOUR', 'MINUTE', 'SECOND', 'MILLISECOND', 'MICROSECOND', 'SUBSECOND', 'UNIX_TIME', 'TIMEZONE_OFFSET'] component ['YEAR', 'ISO_YEAR', 'US_YEAR', 'QUARTER', 'MONTH', 'DAY', 'DAY_OF_YEAR', 'MONDAY_DAY_OF_WEEK', 'SUNDAY_DAY_OF_WEEK', 'MONDAY_WEEK', 'SUNDAY_WEEK', 'ISO_WEEK', 'US_WEEK', 'HOUR', 'MINUTE', 'SECOND', 'MILLISECOND', 'MICROSECOND', 'SUBSECOND', 'UNIX_TIME'] component ['YEAR', 'ISO_YEAR', 'US_YEAR', 'QUARTER', 'MONTH', 'DAY', 'DAY_OF_YEAR', 'MONDAY_DAY_OF_WEEK', 'SUNDAY_DAY_OF_WEEK', 'MONDAY_WEEK', 'SUNDAY_WEEK', 'ISO_WEEK', 'US_WEEK', 'UNIX_TIME'] component ['HOUR', 'MINUTE', 'SECOND', 'MILLISECOND', 'MICROSECOND', 'SUBSECOND'] extract_boolean \u00b6 Implementations: extract_boolean( component , x ): -> return_type 0. extract_boolean( component , timestamp ): -> boolean 1. extract_boolean( component , timestamp_tz , string ): -> boolean 2. extract_boolean( component , date ): -> boolean *Extract boolean values of a date/time value. * IS_LEAP_YEAR Return true if year of the given value is a leap year and false otherwise. * IS_DST Return true if DST (Daylight Savings Time) is observed at the given value in the given timezone. Timezone strings must be as defined by IANA timezone database ( https://www.iana.org/time-zones ). Examples: \u201cPacific/Marquesas\u201d, \u201cEtc/GMT+1\u201d. If timezone is invalid an error is thrown.* Options: component ['IS_LEAP_YEAR'] component ['IS_LEAP_YEAR', 'IS_DST'] add \u00b6 Implementations: add( x , y ): -> return_type 0. add( timestamp , interval_year ): -> timestamp 1. add( timestamp_tz , interval_year , string ): -> timestamp_tz 2. add( date , interval_year ): -> timestamp 3. add( timestamp , interval_day ): -> timestamp 4. add( timestamp_tz , interval_day ): -> timestamp_tz 5. add( date , interval_day ): -> timestamp Add an interval to a date/time type. Timezone strings must be as defined by IANA timezone database ( https://www.iana.org/time-zones ). Examples: \u201cPacific/Marquesas\u201d, \u201cEtc/GMT+1\u201d. If timezone is invalid an error is thrown. add_intervals \u00b6 Implementations: add_intervals( x , y ): -> return_type 0. add_intervals( interval_day , interval_day ): -> interval_day 1. add_intervals( interval_year , interval_year ): -> interval_year Add two intervals together. subtract \u00b6 Implementations: subtract( x , y ): -> return_type 0. subtract( timestamp , interval_year ): -> timestamp 1. subtract( timestamp_tz , interval_year ): -> timestamp_tz 2. subtract( timestamp_tz , interval_year , string ): -> timestamp_tz 3. subtract( date , interval_year ): -> date 4. subtract( timestamp , interval_day ): -> timestamp 5. subtract( timestamp_tz , interval_day ): -> timestamp_tz 6. subtract( date , interval_day ): -> date Subtract an interval from a date/time type. Timezone strings must be as defined by IANA timezone database ( https://www.iana.org/time-zones ). Examples: \u201cPacific/Marquesas\u201d, \u201cEtc/GMT+1\u201d. If timezone is invalid an error is thrown. lte \u00b6 Implementations: lte( x , y ): -> return_type 0. lte( timestamp , timestamp ): -> boolean 1. lte( timestamp_tz , timestamp_tz ): -> boolean 2. lte( date , date ): -> boolean 3. lte( interval_day , interval_day ): -> boolean 4. lte( interval_year , interval_year ): -> boolean less than or equal to lt \u00b6 Implementations: lt( x , y ): -> return_type 0. lt( timestamp , timestamp ): -> boolean 1. lt( timestamp_tz , timestamp_tz ): -> boolean 2. lt( date , date ): -> boolean 3. lt( interval_day , interval_day ): -> boolean 4. lt( interval_year , interval_year ): -> boolean less than gte \u00b6 Implementations: gte( x , y ): -> return_type 0. gte( timestamp , timestamp ): -> boolean 1. gte( timestamp_tz , timestamp_tz ): -> boolean 2. gte( date , date ): -> boolean 3. gte( interval_day , interval_day ): -> boolean 4. gte( interval_year , interval_year ): -> boolean greater than or equal to gt \u00b6 Implementations: gt( x , y ): -> return_type 0. gt( timestamp , timestamp ): -> boolean 1. gt( timestamp_tz , timestamp_tz ): -> boolean 2. gt( date , date ): -> boolean 3. gt( interval_day , interval_day ): -> boolean 4. gt( interval_year , interval_year ): -> boolean greater than assume_timezone \u00b6 Implementations: assume_timezone( x , timezone ): -> return_type x: Timezone string from IANA tzdb. 0. assume_timezone( timestamp , string ): -> timestamp_tz 1. assume_timezone( date , string ): -> timestamp_tz Convert local timestamp to UTC-relative timestamp_tz using given local time\u2019s timezone. Timezone strings must be as defined by IANA timezone database ( https://www.iana.org/time-zones ). Examples: \u201cPacific/Marquesas\u201d, \u201cEtc/GMT+1\u201d. If timezone is invalid an error is thrown. local_timestamp \u00b6 Implementations: local_timestamp( x , timezone ): -> return_type x: Timezone string from IANA tzdb. 0. local_timestamp( timestamp_tz , string ): -> timestamp Convert UTC-relative timestamp_tz to local timestamp using given local time\u2019s timezone. Timezone strings must be as defined by IANA timezone database ( https://www.iana.org/time-zones ). Examples: \u201cPacific/Marquesas\u201d, \u201cEtc/GMT+1\u201d. If timezone is invalid an error is thrown. strptime \u00b6 Implementations: strptime( timestamp_string , format , timezone ): -> return_type timestamp_string: Timezone string from IANA tzdb. 0. strptime( string , string , string ): -> timestamp_tz 1. strptime( string , string ): -> timestamp_tz 2. strptime( string , string ): -> date 3. strptime( string , string ): -> time Parse string into timestamp/date/time using provided format, see https://man7.org/linux/man-pages/man3/strptime.3.html for reference. If timezone is present in timestamp and provided as parameter an error is thrown. Timezone strings must be as defined by IANA timezone database ( https://www.iana.org/time-zones ). Examples: \u201cPacific/Marquesas\u201d, \u201cEtc/GMT+1\u201d. If timezone is supplied as parameter and present in the parsed string the parsed timezone is used. If parameter supplied timezone is invalid an error is thrown. strftime \u00b6 Implementations: strftime( x , format ): -> return_type 0. strftime( timestamp , string ): -> string 1. strftime( timestamp_tz , string , string ): -> string 2. strftime( date , string ): -> string 3. strftime( time , string ): -> string Convert timestamp/date/time to string using provided format, see https://man7.org/linux/man-pages/man3/strftime.3.html for reference. Timezone strings must be as defined by IANA timezone database ( https://www.iana.org/time-zones ). Examples: \u201cPacific/Marquesas\u201d, \u201cEtc/GMT+1\u201d. If timezone is invalid an error is thrown. round_temporal \u00b6 Implementations: round_temporal( x , rounding , unit , multiple , origin ): -> return_type 0. round_temporal( timestamp , rounding , unit , i64 , timestamp ): -> timestamp 1. round_temporal( timestamp_tz , rounding , unit , i64 , string , timestamp_tz ): -> timestamp_tz 2. round_temporal( date , rounding , unit , i64 , date ): -> date 3. round_temporal( time , rounding , unit , i64 , time ): -> time Round a given timestamp/date/time to a multiple of a time unit. If the given timestamp is not already an exact multiple from the origin in the given timezone, the resulting point is chosen as one of the two nearest multiples. Which of these is chosen is governed by rounding: FLOOR means to use the earlier one, CEIL means to use the later one, ROUND_TIE_DOWN means to choose the nearest and tie to the earlier one if equidistant, ROUND_TIE_UP means to choose the nearest and tie to the later one if equidistant. Timezone strings must be as defined by IANA timezone database ( https://www.iana.org/time-zones ). Examples: \u201cPacific/Marquesas\u201d, \u201cEtc/GMT+1\u201d. If timezone is invalid an error is thrown. Options: rounding ['FLOOR', 'CEIL', 'ROUND_TIE_DOWN', 'ROUND_TIE_UP'] unit ['YEAR', 'MONTH', 'WEEK', 'DAY', 'HOUR', 'MINUTE', 'SECOND', 'MILLISECOND', 'MICROSECOND'] rounding ['YEAR', 'MONTH', 'WEEK', 'DAY'] unit ['HOUR', 'MINUTE', 'SECOND', 'MILLISECOND', 'MICROSECOND'] round_calendar \u00b6 Implementations: round_calendar( x , rounding , unit , origin , multiple ): -> return_type 0. round_calendar( timestamp , rounding , unit , origin , i64 ): -> timestamp 1. round_calendar( timestamp_tz , rounding , unit , origin , i64 , string ): -> timestamp_tz 2. round_calendar( date , rounding , unit , origin , i64 , date ): -> date 3. round_calendar( time , rounding , unit , origin , i64 , time ): -> time Round a given timestamp/date/time to a multiple of a time unit. If the given timestamp is not already an exact multiple from the last origin unit in the given timezone, the resulting point is chosen as one of the two nearest multiples. Which of these is chosen is governed by rounding: FLOOR means to use the earlier one, CEIL means to use the later one, ROUND_TIE_DOWN means to choose the nearest and tie to the earlier one if equidistant, ROUND_TIE_UP means to choose the nearest and tie to the later one if equidistant. Timezone strings must be as defined by IANA timezone database ( https://www.iana.org/time-zones ). Examples: \u201cPacific/Marquesas\u201d, \u201cEtc/GMT+1\u201d. If timezone is invalid an error is thrown. Options: rounding ['FLOOR', 'CEIL', 'ROUND_TIE_DOWN', 'ROUND_TIE_UP'] unit ['YEAR', 'MONTH', 'WEEK', 'DAY', 'HOUR', 'MINUTE', 'SECOND', 'MILLISECOND', 'MICROSECOND'] origin ['YEAR', 'MONTH', 'MONDAY_WEEK', 'SUNDAY_WEEK', 'ISO_WEEK', 'US_WEEK', 'DAY', 'HOUR', 'MINUTE', 'SECOND', 'MILLISECOND'] rounding ['YEAR', 'MONTH', 'WEEK', 'DAY'] unit ['YEAR', 'MONTH', 'MONDAY_WEEK', 'SUNDAY_WEEK', 'ISO_WEEK', 'US_WEEK', 'DAY'] origin ['DAY', 'HOUR', 'MINUTE', 'SECOND', 'MILLISECOND', 'MICROSECOND'] rounding ['DAY', 'HOUR', 'MINUTE', 'SECOND', 'MILLISECOND']","title":"functions_datetime.yaml"},{"location":"extensions/functions_datetime/#functions_datetimeyaml","text":"This document file is generated for functions_datetime.yaml","title":"functions_datetime.yaml"},{"location":"extensions/functions_datetime/#scalar-functions","text":"","title":"Scalar Functions"},{"location":"extensions/functions_datetime/#extract","text":"Implementations: extract( component , x , timezone ): -> return_type x: Timezone string from IANA tzdb. 0. extract( component , timestamp_tz , string ): -> i64 1. extract( component , timestamp ): -> i64 2. extract( component , date ): -> i64 3. extract( component , time ): -> i64 Extract portion of a date/time value. * YEAR Return the year of the value. * ISO_YEAR Return the ISO 8601 week-numbering year. First week of an ISO year has the majority (4 or more) of its days in January. * US_YEAR Return US epidemiological year. First week of US epidemiological year has the majority (4 or more) of its days in January. Last week of US epidemiological year has the year\u2019s last Wednesday in it. US epidemiological week starts on Sunday. * QUARTER Return the quarter from the value (1-4). * MONTH Return the month from value (1-12). * DAY Return the day of the month (1-31). * DAY_OF_YEAR Return the day of year (1 to 366). January 1 st maps to day number 1, February 1 st to 32, etc. * MONDAY_DAY_OF_WEEK Return the day of week from Monday (1) to Sunday (7). * SUNDAY_DAY_OF_WEEK Return the day of week from Sunday (1) to Saturday (7). * MONDAY_WEEK Return week of year number (1-53). First week starts on first Monday of January. * SUNDAY_WEEK Return week of year number (1-53). First week starts on first Sunday of January. * ISO_WEEK Return ISO week of year number (1-53). First ISO calendar week has the majority (4 or more) of its days in January. ISO week starts on Monday. * US_WEEK Return ISO-like week of year number (1-53). First US calendar week has the majority (4 or more) of its days in January. US week starts on Sunday. * HOUR Return the hour (0-23). * MINUTE Return the minute (0-59). * SECOND Return the second (0-59). * MILLISECOND Return number of milliseconds since the last full second. * MICROSECOND Return number of microseconds since the last full millisecond. * SUBSECOND Return number of microseconds since the last full second of the given timestamp. * UNIX_TIME Return number of seconds that have elapsed since 1970-01-01 00:00:00 UTC, ignoring leap seconds. * TIMEZONE_OFFSET Return number of seconds of timezone offset to UTC. Timezone strings must be as defined by IANA timezone database ( https://www.iana.org/time-zones ). Examples: \u201cPacific/Marquesas\u201d, \u201cEtc/GMT+1\u201d. If timezone is invalid an error is thrown. Options: component ['YEAR', 'ISO_YEAR', 'US_YEAR', 'QUARTER', 'MONTH', 'DAY', 'DAY_OF_YEAR', 'MONDAY_DAY_OF_WEEK', 'SUNDAY_DAY_OF_WEEK', 'MONDAY_WEEK', 'SUNDAY_WEEK', 'ISO_WEEK', 'US_WEEK', 'HOUR', 'MINUTE', 'SECOND', 'MILLISECOND', 'MICROSECOND', 'SUBSECOND', 'UNIX_TIME', 'TIMEZONE_OFFSET'] component ['YEAR', 'ISO_YEAR', 'US_YEAR', 'QUARTER', 'MONTH', 'DAY', 'DAY_OF_YEAR', 'MONDAY_DAY_OF_WEEK', 'SUNDAY_DAY_OF_WEEK', 'MONDAY_WEEK', 'SUNDAY_WEEK', 'ISO_WEEK', 'US_WEEK', 'HOUR', 'MINUTE', 'SECOND', 'MILLISECOND', 'MICROSECOND', 'SUBSECOND', 'UNIX_TIME'] component ['YEAR', 'ISO_YEAR', 'US_YEAR', 'QUARTER', 'MONTH', 'DAY', 'DAY_OF_YEAR', 'MONDAY_DAY_OF_WEEK', 'SUNDAY_DAY_OF_WEEK', 'MONDAY_WEEK', 'SUNDAY_WEEK', 'ISO_WEEK', 'US_WEEK', 'UNIX_TIME'] component ['HOUR', 'MINUTE', 'SECOND', 'MILLISECOND', 'MICROSECOND', 'SUBSECOND']","title":"extract"},{"location":"extensions/functions_datetime/#extract_boolean","text":"Implementations: extract_boolean( component , x ): -> return_type 0. extract_boolean( component , timestamp ): -> boolean 1. extract_boolean( component , timestamp_tz , string ): -> boolean 2. extract_boolean( component , date ): -> boolean *Extract boolean values of a date/time value. * IS_LEAP_YEAR Return true if year of the given value is a leap year and false otherwise. * IS_DST Return true if DST (Daylight Savings Time) is observed at the given value in the given timezone. Timezone strings must be as defined by IANA timezone database ( https://www.iana.org/time-zones ). Examples: \u201cPacific/Marquesas\u201d, \u201cEtc/GMT+1\u201d. If timezone is invalid an error is thrown.* Options: component ['IS_LEAP_YEAR'] component ['IS_LEAP_YEAR', 'IS_DST']","title":"extract_boolean"},{"location":"extensions/functions_datetime/#add","text":"Implementations: add( x , y ): -> return_type 0. add( timestamp , interval_year ): -> timestamp 1. add( timestamp_tz , interval_year , string ): -> timestamp_tz 2. add( date , interval_year ): -> timestamp 3. add( timestamp , interval_day ): -> timestamp 4. add( timestamp_tz , interval_day ): -> timestamp_tz 5. add( date , interval_day ): -> timestamp Add an interval to a date/time type. Timezone strings must be as defined by IANA timezone database ( https://www.iana.org/time-zones ). Examples: \u201cPacific/Marquesas\u201d, \u201cEtc/GMT+1\u201d. If timezone is invalid an error is thrown.","title":"add"},{"location":"extensions/functions_datetime/#add_intervals","text":"Implementations: add_intervals( x , y ): -> return_type 0. add_intervals( interval_day , interval_day ): -> interval_day 1. add_intervals( interval_year , interval_year ): -> interval_year Add two intervals together.","title":"add_intervals"},{"location":"extensions/functions_datetime/#subtract","text":"Implementations: subtract( x , y ): -> return_type 0. subtract( timestamp , interval_year ): -> timestamp 1. subtract( timestamp_tz , interval_year ): -> timestamp_tz 2. subtract( timestamp_tz , interval_year , string ): -> timestamp_tz 3. subtract( date , interval_year ): -> date 4. subtract( timestamp , interval_day ): -> timestamp 5. subtract( timestamp_tz , interval_day ): -> timestamp_tz 6. subtract( date , interval_day ): -> date Subtract an interval from a date/time type. Timezone strings must be as defined by IANA timezone database ( https://www.iana.org/time-zones ). Examples: \u201cPacific/Marquesas\u201d, \u201cEtc/GMT+1\u201d. If timezone is invalid an error is thrown.","title":"subtract"},{"location":"extensions/functions_datetime/#lte","text":"Implementations: lte( x , y ): -> return_type 0. lte( timestamp , timestamp ): -> boolean 1. lte( timestamp_tz , timestamp_tz ): -> boolean 2. lte( date , date ): -> boolean 3. lte( interval_day , interval_day ): -> boolean 4. lte( interval_year , interval_year ): -> boolean less than or equal to","title":"lte"},{"location":"extensions/functions_datetime/#lt","text":"Implementations: lt( x , y ): -> return_type 0. lt( timestamp , timestamp ): -> boolean 1. lt( timestamp_tz , timestamp_tz ): -> boolean 2. lt( date , date ): -> boolean 3. lt( interval_day , interval_day ): -> boolean 4. lt( interval_year , interval_year ): -> boolean less than","title":"lt"},{"location":"extensions/functions_datetime/#gte","text":"Implementations: gte( x , y ): -> return_type 0. gte( timestamp , timestamp ): -> boolean 1. gte( timestamp_tz , timestamp_tz ): -> boolean 2. gte( date , date ): -> boolean 3. gte( interval_day , interval_day ): -> boolean 4. gte( interval_year , interval_year ): -> boolean greater than or equal to","title":"gte"},{"location":"extensions/functions_datetime/#gt","text":"Implementations: gt( x , y ): -> return_type 0. gt( timestamp , timestamp ): -> boolean 1. gt( timestamp_tz , timestamp_tz ): -> boolean 2. gt( date , date ): -> boolean 3. gt( interval_day , interval_day ): -> boolean 4. gt( interval_year , interval_year ): -> boolean greater than","title":"gt"},{"location":"extensions/functions_datetime/#assume_timezone","text":"Implementations: assume_timezone( x , timezone ): -> return_type x: Timezone string from IANA tzdb. 0. assume_timezone( timestamp , string ): -> timestamp_tz 1. assume_timezone( date , string ): -> timestamp_tz Convert local timestamp to UTC-relative timestamp_tz using given local time\u2019s timezone. Timezone strings must be as defined by IANA timezone database ( https://www.iana.org/time-zones ). Examples: \u201cPacific/Marquesas\u201d, \u201cEtc/GMT+1\u201d. If timezone is invalid an error is thrown.","title":"assume_timezone"},{"location":"extensions/functions_datetime/#local_timestamp","text":"Implementations: local_timestamp( x , timezone ): -> return_type x: Timezone string from IANA tzdb. 0. local_timestamp( timestamp_tz , string ): -> timestamp Convert UTC-relative timestamp_tz to local timestamp using given local time\u2019s timezone. Timezone strings must be as defined by IANA timezone database ( https://www.iana.org/time-zones ). Examples: \u201cPacific/Marquesas\u201d, \u201cEtc/GMT+1\u201d. If timezone is invalid an error is thrown.","title":"local_timestamp"},{"location":"extensions/functions_datetime/#strptime","text":"Implementations: strptime( timestamp_string , format , timezone ): -> return_type timestamp_string: Timezone string from IANA tzdb. 0. strptime( string , string , string ): -> timestamp_tz 1. strptime( string , string ): -> timestamp_tz 2. strptime( string , string ): -> date 3. strptime( string , string ): -> time Parse string into timestamp/date/time using provided format, see https://man7.org/linux/man-pages/man3/strptime.3.html for reference. If timezone is present in timestamp and provided as parameter an error is thrown. Timezone strings must be as defined by IANA timezone database ( https://www.iana.org/time-zones ). Examples: \u201cPacific/Marquesas\u201d, \u201cEtc/GMT+1\u201d. If timezone is supplied as parameter and present in the parsed string the parsed timezone is used. If parameter supplied timezone is invalid an error is thrown.","title":"strptime"},{"location":"extensions/functions_datetime/#strftime","text":"Implementations: strftime( x , format ): -> return_type 0. strftime( timestamp , string ): -> string 1. strftime( timestamp_tz , string , string ): -> string 2. strftime( date , string ): -> string 3. strftime( time , string ): -> string Convert timestamp/date/time to string using provided format, see https://man7.org/linux/man-pages/man3/strftime.3.html for reference. Timezone strings must be as defined by IANA timezone database ( https://www.iana.org/time-zones ). Examples: \u201cPacific/Marquesas\u201d, \u201cEtc/GMT+1\u201d. If timezone is invalid an error is thrown.","title":"strftime"},{"location":"extensions/functions_datetime/#round_temporal","text":"Implementations: round_temporal( x , rounding , unit , multiple , origin ): -> return_type 0. round_temporal( timestamp , rounding , unit , i64 , timestamp ): -> timestamp 1. round_temporal( timestamp_tz , rounding , unit , i64 , string , timestamp_tz ): -> timestamp_tz 2. round_temporal( date , rounding , unit , i64 , date ): -> date 3. round_temporal( time , rounding , unit , i64 , time ): -> time Round a given timestamp/date/time to a multiple of a time unit. If the given timestamp is not already an exact multiple from the origin in the given timezone, the resulting point is chosen as one of the two nearest multiples. Which of these is chosen is governed by rounding: FLOOR means to use the earlier one, CEIL means to use the later one, ROUND_TIE_DOWN means to choose the nearest and tie to the earlier one if equidistant, ROUND_TIE_UP means to choose the nearest and tie to the later one if equidistant. Timezone strings must be as defined by IANA timezone database ( https://www.iana.org/time-zones ). Examples: \u201cPacific/Marquesas\u201d, \u201cEtc/GMT+1\u201d. If timezone is invalid an error is thrown. Options: rounding ['FLOOR', 'CEIL', 'ROUND_TIE_DOWN', 'ROUND_TIE_UP'] unit ['YEAR', 'MONTH', 'WEEK', 'DAY', 'HOUR', 'MINUTE', 'SECOND', 'MILLISECOND', 'MICROSECOND'] rounding ['YEAR', 'MONTH', 'WEEK', 'DAY'] unit ['HOUR', 'MINUTE', 'SECOND', 'MILLISECOND', 'MICROSECOND']","title":"round_temporal"},{"location":"extensions/functions_datetime/#round_calendar","text":"Implementations: round_calendar( x , rounding , unit , origin , multiple ): -> return_type 0. round_calendar( timestamp , rounding , unit , origin , i64 ): -> timestamp 1. round_calendar( timestamp_tz , rounding , unit , origin , i64 , string ): -> timestamp_tz 2. round_calendar( date , rounding , unit , origin , i64 , date ): -> date 3. round_calendar( time , rounding , unit , origin , i64 , time ): -> time Round a given timestamp/date/time to a multiple of a time unit. If the given timestamp is not already an exact multiple from the last origin unit in the given timezone, the resulting point is chosen as one of the two nearest multiples. Which of these is chosen is governed by rounding: FLOOR means to use the earlier one, CEIL means to use the later one, ROUND_TIE_DOWN means to choose the nearest and tie to the earlier one if equidistant, ROUND_TIE_UP means to choose the nearest and tie to the later one if equidistant. Timezone strings must be as defined by IANA timezone database ( https://www.iana.org/time-zones ). Examples: \u201cPacific/Marquesas\u201d, \u201cEtc/GMT+1\u201d. If timezone is invalid an error is thrown. Options: rounding ['FLOOR', 'CEIL', 'ROUND_TIE_DOWN', 'ROUND_TIE_UP'] unit ['YEAR', 'MONTH', 'WEEK', 'DAY', 'HOUR', 'MINUTE', 'SECOND', 'MILLISECOND', 'MICROSECOND'] origin ['YEAR', 'MONTH', 'MONDAY_WEEK', 'SUNDAY_WEEK', 'ISO_WEEK', 'US_WEEK', 'DAY', 'HOUR', 'MINUTE', 'SECOND', 'MILLISECOND'] rounding ['YEAR', 'MONTH', 'WEEK', 'DAY'] unit ['YEAR', 'MONTH', 'MONDAY_WEEK', 'SUNDAY_WEEK', 'ISO_WEEK', 'US_WEEK', 'DAY'] origin ['DAY', 'HOUR', 'MINUTE', 'SECOND', 'MILLISECOND', 'MICROSECOND'] rounding ['DAY', 'HOUR', 'MINUTE', 'SECOND', 'MILLISECOND']","title":"round_calendar"},{"location":"extensions/functions_logarithmic/","text":"functions_logarithmic.yaml \u00b6 This document file is generated for functions_logarithmic.yaml Scalar Functions \u00b6 ln \u00b6 Implementations: ln( x , option:rounding , option:on_domain_error , option:on_log_zero ): -> return_type 0. ln( fp32 , option:rounding , option:on_domain_error , option:on_log_zero ): -> fp32 1. ln( fp64 , option:rounding , option:on_domain_error , option:on_log_zero ): -> fp64 Natural logarithm of the value Options: rounding ['TIE_TO_EVEN', 'TIE_AWAY_FROM_ZERO', 'TRUNCATE', 'CEILING', 'FLOOR'] on_domain_error ['NAN', 'ERROR'] on_log_zero ['NAN', 'ERROR', 'MINUS_INFINITY'] log10 \u00b6 Implementations: log10( x , option:rounding , option:on_domain_error , option:on_log_zero ): -> return_type 0. log10( fp32 , option:rounding , option:on_domain_error , option:on_log_zero ): -> fp32 1. log10( fp64 , option:rounding , option:on_domain_error , option:on_log_zero ): -> fp64 Logarithm to base 10 of the value Options: rounding ['TIE_TO_EVEN', 'TIE_AWAY_FROM_ZERO', 'TRUNCATE', 'CEILING', 'FLOOR'] on_domain_error ['NAN', 'ERROR'] on_log_zero ['NAN', 'ERROR', 'MINUS_INFINITY'] log2 \u00b6 Implementations: log2( x , option:rounding , option:on_domain_error , option:on_log_zero ): -> return_type 0. log2( fp32 , option:rounding , option:on_domain_error , option:on_log_zero ): -> fp32 1. log2( fp64 , option:rounding , option:on_domain_error , option:on_log_zero ): -> fp64 Logarithm to base 2 of the value Options: rounding ['TIE_TO_EVEN', 'TIE_AWAY_FROM_ZERO', 'TRUNCATE', 'CEILING', 'FLOOR'] on_domain_error ['NAN', 'ERROR'] on_log_zero ['NAN', 'ERROR', 'MINUS_INFINITY'] logb \u00b6 Implementations: logb( x , base , option:rounding , option:on_domain_error , option:on_log_zero ): -> return_type x: The number `x` to compute the logarithm of base: The logarithm base `b` to use 0. logb( fp32 , fp32 , option:rounding , option:on_domain_error , option:on_log_zero ): -> fp32 1. logb( fp64 , fp64 , option:rounding , option:on_domain_error , option:on_log_zero ): -> fp64 *Logarithm of the value with the given base logb(x, b) => log_{b} (x) * Options: rounding ['TIE_TO_EVEN', 'TIE_AWAY_FROM_ZERO', 'TRUNCATE', 'CEILING', 'FLOOR'] on_domain_error ['NAN', 'ERROR'] on_log_zero ['NAN', 'ERROR', 'MINUS_INFINITY'] log1p \u00b6 Implementations: log1p( x , option:rounding , option:on_domain_error , option:on_log_zero ): -> return_type 0. log1p( fp32 , option:rounding , option:on_domain_error , option:on_log_zero ): -> fp32 1. log1p( fp64 , option:rounding , option:on_domain_error , option:on_log_zero ): -> fp64 *Natural logarithm (base e) of 1 + x log1p(x) => log(1+x) * Options: rounding ['TIE_TO_EVEN', 'TIE_AWAY_FROM_ZERO', 'TRUNCATE', 'CEILING', 'FLOOR'] on_domain_error ['NAN', 'ERROR'] on_log_zero ['NAN', 'ERROR', 'MINUS_INFINITY']","title":"functions_logarithmic.yaml"},{"location":"extensions/functions_logarithmic/#functions_logarithmicyaml","text":"This document file is generated for functions_logarithmic.yaml","title":"functions_logarithmic.yaml"},{"location":"extensions/functions_logarithmic/#scalar-functions","text":"","title":"Scalar Functions"},{"location":"extensions/functions_logarithmic/#ln","text":"Implementations: ln( x , option:rounding , option:on_domain_error , option:on_log_zero ): -> return_type 0. ln( fp32 , option:rounding , option:on_domain_error , option:on_log_zero ): -> fp32 1. ln( fp64 , option:rounding , option:on_domain_error , option:on_log_zero ): -> fp64 Natural logarithm of the value Options: rounding ['TIE_TO_EVEN', 'TIE_AWAY_FROM_ZERO', 'TRUNCATE', 'CEILING', 'FLOOR'] on_domain_error ['NAN', 'ERROR'] on_log_zero ['NAN', 'ERROR', 'MINUS_INFINITY']","title":"ln"},{"location":"extensions/functions_logarithmic/#log10","text":"Implementations: log10( x , option:rounding , option:on_domain_error , option:on_log_zero ): -> return_type 0. log10( fp32 , option:rounding , option:on_domain_error , option:on_log_zero ): -> fp32 1. log10( fp64 , option:rounding , option:on_domain_error , option:on_log_zero ): -> fp64 Logarithm to base 10 of the value Options: rounding ['TIE_TO_EVEN', 'TIE_AWAY_FROM_ZERO', 'TRUNCATE', 'CEILING', 'FLOOR'] on_domain_error ['NAN', 'ERROR'] on_log_zero ['NAN', 'ERROR', 'MINUS_INFINITY']","title":"log10"},{"location":"extensions/functions_logarithmic/#log2","text":"Implementations: log2( x , option:rounding , option:on_domain_error , option:on_log_zero ): -> return_type 0. log2( fp32 , option:rounding , option:on_domain_error , option:on_log_zero ): -> fp32 1. log2( fp64 , option:rounding , option:on_domain_error , option:on_log_zero ): -> fp64 Logarithm to base 2 of the value Options: rounding ['TIE_TO_EVEN', 'TIE_AWAY_FROM_ZERO', 'TRUNCATE', 'CEILING', 'FLOOR'] on_domain_error ['NAN', 'ERROR'] on_log_zero ['NAN', 'ERROR', 'MINUS_INFINITY']","title":"log2"},{"location":"extensions/functions_logarithmic/#logb","text":"Implementations: logb( x , base , option:rounding , option:on_domain_error , option:on_log_zero ): -> return_type x: The number `x` to compute the logarithm of base: The logarithm base `b` to use 0. logb( fp32 , fp32 , option:rounding , option:on_domain_error , option:on_log_zero ): -> fp32 1. logb( fp64 , fp64 , option:rounding , option:on_domain_error , option:on_log_zero ): -> fp64 *Logarithm of the value with the given base logb(x, b) => log_{b} (x) * Options: rounding ['TIE_TO_EVEN', 'TIE_AWAY_FROM_ZERO', 'TRUNCATE', 'CEILING', 'FLOOR'] on_domain_error ['NAN', 'ERROR'] on_log_zero ['NAN', 'ERROR', 'MINUS_INFINITY']","title":"logb"},{"location":"extensions/functions_logarithmic/#log1p","text":"Implementations: log1p( x , option:rounding , option:on_domain_error , option:on_log_zero ): -> return_type 0. log1p( fp32 , option:rounding , option:on_domain_error , option:on_log_zero ): -> fp32 1. log1p( fp64 , option:rounding , option:on_domain_error , option:on_log_zero ): -> fp64 *Natural logarithm (base e) of 1 + x log1p(x) => log(1+x) * Options: rounding ['TIE_TO_EVEN', 'TIE_AWAY_FROM_ZERO', 'TRUNCATE', 'CEILING', 'FLOOR'] on_domain_error ['NAN', 'ERROR'] on_log_zero ['NAN', 'ERROR', 'MINUS_INFINITY']","title":"log1p"},{"location":"extensions/functions_rounding/","text":"functions_rounding.yaml \u00b6 This document file is generated for functions_rounding.yaml Scalar Functions \u00b6 ceil \u00b6 Implementations: ceil( x ): -> return_type 0. ceil( fp32 ): -> fp32 1. ceil( fp64 ): -> fp64 *Rounding to the ceiling of the value x . * floor \u00b6 Implementations: floor( x ): -> return_type 0. floor( fp32 ): -> fp32 1. floor( fp64 ): -> fp64 *Rounding to the floor of the value x . * round \u00b6 Implementations: round( x , s , option:rounding ): -> return_type x: Numerical expression to be rounded. s: Number of decimal places to be rounded to. When `s` is a positive number, nothing will happen since `x` is an integer value. When `s` is a negative number, the rounding is performed to the nearest multiple of `10^(-s)`. 0. round( i8 , i32 , option:rounding ): -> i8? 1. round( i16 , i32 , option:rounding ): -> i16? 2. round( i32 , i32 , option:rounding ): -> i32? 3. round( i64 , i32 , option:rounding ): -> i64? 4. round( fp32 , i32 , option:rounding ): -> fp32? 5. round( fp64 , i32 , option:rounding ): -> fp64? *Rounding the value x to s decimal places. * Options: rounding ['TIE_TO_EVEN', 'TIE_AWAY_FROM_ZERO', 'TRUNCATE', 'CEILING', 'FLOOR', 'AWAY_FROM_ZERO', 'TIE_DOWN', 'TIE_UP', 'TIE_TOWARDS_ZERO', 'TIE_TO_ODD']","title":"functions_rounding.yaml"},{"location":"extensions/functions_rounding/#functions_roundingyaml","text":"This document file is generated for functions_rounding.yaml","title":"functions_rounding.yaml"},{"location":"extensions/functions_rounding/#scalar-functions","text":"","title":"Scalar Functions"},{"location":"extensions/functions_rounding/#ceil","text":"Implementations: ceil( x ): -> return_type 0. ceil( fp32 ): -> fp32 1. ceil( fp64 ): -> fp64 *Rounding to the ceiling of the value x . *","title":"ceil"},{"location":"extensions/functions_rounding/#floor","text":"Implementations: floor( x ): -> return_type 0. floor( fp32 ): -> fp32 1. floor( fp64 ): -> fp64 *Rounding to the floor of the value x . *","title":"floor"},{"location":"extensions/functions_rounding/#round","text":"Implementations: round( x , s , option:rounding ): -> return_type x: Numerical expression to be rounded. s: Number of decimal places to be rounded to. When `s` is a positive number, nothing will happen since `x` is an integer value. When `s` is a negative number, the rounding is performed to the nearest multiple of `10^(-s)`. 0. round( i8 , i32 , option:rounding ): -> i8? 1. round( i16 , i32 , option:rounding ): -> i16? 2. round( i32 , i32 , option:rounding ): -> i32? 3. round( i64 , i32 , option:rounding ): -> i64? 4. round( fp32 , i32 , option:rounding ): -> fp32? 5. round( fp64 , i32 , option:rounding ): -> fp64? *Rounding the value x to s decimal places. * Options: rounding ['TIE_TO_EVEN', 'TIE_AWAY_FROM_ZERO', 'TRUNCATE', 'CEILING', 'FLOOR', 'AWAY_FROM_ZERO', 'TIE_DOWN', 'TIE_UP', 'TIE_TOWARDS_ZERO', 'TIE_TO_ODD']","title":"round"},{"location":"extensions/functions_set/","text":"functions_set.yaml \u00b6 This document file is generated for functions_set.yaml Scalar Functions \u00b6 index_in \u00b6 Implementations: index_in( x , y , option:nan_equality ): -> return_type 0. index_in( T , List<T> , option:nan_equality ): -> int64? *Checks the membership of a value in a list of values Returns the first 0-based index value of some input T if T is equal to any element in List<T> . Returns NULL if not found. If T is NULL , returns NULL . If T is NaN : - Returns 0-based index of NaN in List<T> (default) - Returns NULL (if NAN_IS_NOT_NAN is specified) * Options: nan_equality ['NAN_IS_NAN', 'NAN_IS_NOT_NAN']","title":"functions_set.yaml"},{"location":"extensions/functions_set/#functions_setyaml","text":"This document file is generated for functions_set.yaml","title":"functions_set.yaml"},{"location":"extensions/functions_set/#scalar-functions","text":"","title":"Scalar Functions"},{"location":"extensions/functions_set/#index_in","text":"Implementations: index_in( x , y , option:nan_equality ): -> return_type 0. index_in( T , List<T> , option:nan_equality ): -> int64? *Checks the membership of a value in a list of values Returns the first 0-based index value of some input T if T is equal to any element in List<T> . Returns NULL if not found. If T is NULL , returns NULL . If T is NaN : - Returns 0-based index of NaN in List<T> (default) - Returns NULL (if NAN_IS_NOT_NAN is specified) * Options: nan_equality ['NAN_IS_NAN', 'NAN_IS_NOT_NAN']","title":"index_in"},{"location":"extensions/functions_string/","text":"functions_string.yaml \u00b6 This document file is generated for functions_string.yaml Scalar Functions \u00b6 concat \u00b6 Implementations: concat( input ): -> return_type 0. concat( varchar<L1> ): -> varchar<L1> 1. concat( string ): -> string Concatenate strings. like \u00b6 Implementations: like( input , match , option:case_sensitivity ): -> return_type input: The input string. match: The string to match against the input string. 0. like( varchar<L1> , varchar<L2> , option:case_sensitivity ): -> BOOLEAN 1. like( string , string , option:case_sensitivity ): -> BOOLEAN Are two strings like each other. The case_sensitivity option applies to the match argument. Options: case_sensitivity ['CASE_SENSITIVE', 'CASE_INSENSITIVE', 'CASE_INSENSITIVE_ASCII'] substring \u00b6 Implementations: substring( input , start , length ): -> return_type 0. substring( varchar<L1> , i32 , i32 ): -> varchar<L1> 1. substring( string , i32 , i32 ): -> string 2. substring( fixedchar<l1> , i32 , i32 ): -> string Extract a substring of a specified length starting from position start . A start value of 1 refers to the first characters of the string. regexp_match_substring \u00b6 Implementations: regexp_match_substring( input , pattern , position , occurrence , group , option:case_sensitivity , option:multiline , option:dotall ): -> return_type 0. regexp_match_substring( varchar<L1> , varchar<L2> , i64 , i64 , i64 , option:case_sensitivity , option:multiline , option:dotall ): -> varchar<L1> 1. regexp_match_substring( string , string , i64 , i64 , i64 , option:case_sensitivity , option:multiline , option:dotall ): -> string Extract a substring that matches the given regular expression pattern. The regular expression pattern should follow the International Components for Unicode implementation ( https://unicode-org.github.io/icu/userguide/strings/regexp.html ). The occurrence of the pattern to be extracted is specified using the occurrence argument. Specifying 1 means the first occurrence will be extracted, 2 means the second occurrence, and so on. The occurrence argument should be a positive non-zero integer. The number of characters from the beginning of the string to begin starting to search for pattern matches can be specified using the position argument. Specifying 1 means to search for matches starting at the first character of the input string, 2 means the second character, and so on. The position argument should be a positive non-zero integer. The regular expression capture group can be specified using the group argument. Specifying 0 will return the substring matching the full regular expression. Specifying 1 will return the substring matching only the first capture group, and so on. The group argument should be a non-negative integer. The case_sensitivity option specifies case-sensitive or case-insensitive matching. Enabling the multiline option will treat the input string as multiple lines. This makes the ^ and $ characters match at the beginning and end of any line, instead of just the beginning and end of the input string. Enabling the dotall option makes the . character match line terminator characters in a string. Behavior is undefined if the regex fails to compile, the occurrence value is out of range, the position value is out of range, or the group value is out of range. Options: case_sensitivity ['CASE_SENSITIVE', 'CASE_INSENSITIVE', 'CASE_INSENSITIVE_ASCII'] multiline ['MULTILINE_DISABLED', 'MULTILINE_ENABLED'] dotall ['DOTALL_DISABLED', 'DOTALL_ENABLED'] regexp_match_substring_all \u00b6 Implementations: regexp_match_substring_all( input , pattern , position , group , option:case_sensitivity , option:multiline , option:dotall ): -> return_type 0. regexp_match_substring_all( varchar<L1> , varchar<L2> , i64 , i64 , option:case_sensitivity , option:multiline , option:dotall ): -> List<varchar<L1>> 1. regexp_match_substring_all( string , string , i64 , i64 , option:case_sensitivity , option:multiline , option:dotall ): -> List<string> Extract all substrings that match the given regular expression pattern. This will return a list of extracted strings with one value for each occurrence of a match. The regular expression pattern should follow the International Components for Unicode implementation ( https://unicode-org.github.io/icu/userguide/strings/regexp.html ). The number of characters from the beginning of the string to begin starting to search for pattern matches can be specified using the position argument. Specifying 1 means to search for matches starting at the first character of the input string, 2 means the second character, and so on. The position argument should be a positive non-zero integer. The regular expression capture group can be specified using the group argument. Specifying 0 will return substrings matching the full regular expression. Specifying 1 will return substrings matching only the first capture group, and so on. The group argument should be a non-negative integer. The case_sensitivity option specifies case-sensitive or case-insensitive matching. Enabling the multiline option will treat the input string as multiple lines. This makes the ^ and $ characters match at the beginning and end of any line, instead of just the beginning and end of the input string. Enabling the dotall option makes the . character match line terminator characters in a string. Behavior is undefined if the regex fails to compile, the position value is out of range, or the group value is out of range. Options: case_sensitivity ['CASE_SENSITIVE', 'CASE_INSENSITIVE', 'CASE_INSENSITIVE_ASCII'] multiline ['MULTILINE_DISABLED', 'MULTILINE_ENABLED'] dotall ['DOTALL_DISABLED', 'DOTALL_ENABLED'] starts_with \u00b6 Implementations: starts_with( input , substring , option:case_sensitivity ): -> return_type input: The input string. substring: The substring to search for. 0. starts_with( varchar<L1> , varchar<L2> , option:case_sensitivity ): -> BOOLEAN 1. starts_with( varchar<L1> , string , option:case_sensitivity ): -> BOOLEAN 2. starts_with( varchar<L1> , fixedchar<L2> , option:case_sensitivity ): -> BOOLEAN 3. starts_with( string , string , option:case_sensitivity ): -> BOOLEAN 4. starts_with( string , varchar<L1> , option:case_sensitivity ): -> BOOLEAN 5. starts_with( string , fixedchar<L1> , option:case_sensitivity ): -> BOOLEAN 6. starts_with( fixedchar<L1> , fixedchar<L2> , option:case_sensitivity ): -> BOOLEAN 7. starts_with( fixedchar<L1> , string , option:case_sensitivity ): -> BOOLEAN 8. starts_with( fixedchar<L1> , varchar<L2> , option:case_sensitivity ): -> BOOLEAN Whether the input string starts with the substring . The case_sensitivity option applies to the substring argument. Options: case_sensitivity ['CASE_SENSITIVE', 'CASE_INSENSITIVE', 'CASE_INSENSITIVE_ASCII'] ends_with \u00b6 Implementations: ends_with( input , substring , option:case_sensitivity ): -> return_type input: The input string. substring: The substring to search for. 0. ends_with( varchar<L1> , varchar<L2> , option:case_sensitivity ): -> BOOLEAN 1. ends_with( varchar<L1> , string , option:case_sensitivity ): -> BOOLEAN 2. ends_with( varchar<L1> , fixedchar<L2> , option:case_sensitivity ): -> BOOLEAN 3. ends_with( string , string , option:case_sensitivity ): -> BOOLEAN 4. ends_with( string , varchar<L1> , option:case_sensitivity ): -> BOOLEAN 5. ends_with( string , fixedchar<L1> , option:case_sensitivity ): -> BOOLEAN 6. ends_with( fixedchar<L1> , fixedchar<L2> , option:case_sensitivity ): -> BOOLEAN 7. ends_with( fixedchar<L1> , string , option:case_sensitivity ): -> BOOLEAN 8. ends_with( fixedchar<L1> , varchar<L2> , option:case_sensitivity ): -> BOOLEAN Whether input string ends with the substring. The case_sensitivity option applies to the substring argument. Options: case_sensitivity ['CASE_SENSITIVE', 'CASE_INSENSITIVE', 'CASE_INSENSITIVE_ASCII'] contains \u00b6 Implementations: contains( input , substring , option:case_sensitivity ): -> return_type input: The input string. substring: The substring to search for. 0. contains( varchar<L1> , varchar<L2> , option:case_sensitivity ): -> BOOLEAN 1. contains( varchar<L1> , string , option:case_sensitivity ): -> BOOLEAN 2. contains( varchar<L1> , fixedchar<L2> , option:case_sensitivity ): -> BOOLEAN 3. contains( string , string , option:case_sensitivity ): -> BOOLEAN 4. contains( string , varchar<L1> , option:case_sensitivity ): -> BOOLEAN 5. contains( string , fixedchar<L1> , option:case_sensitivity ): -> BOOLEAN 6. contains( fixedchar<L1> , fixedchar<L2> , option:case_sensitivity ): -> BOOLEAN 7. contains( fixedchar<L1> , string , option:case_sensitivity ): -> BOOLEAN 8. contains( fixedchar<L1> , varchar<L2> , option:case_sensitivity ): -> BOOLEAN Whether the input string contains the substring . The case_sensitivity option applies to the substring argument. Options: case_sensitivity ['CASE_SENSITIVE', 'CASE_INSENSITIVE', 'CASE_INSENSITIVE_ASCII'] strpos \u00b6 Implementations: strpos( input , substring , option:case_sensitivity ): -> return_type input: The input string. substring: The substring to search for. 0. strpos( string , string , option:case_sensitivity ): -> i64 1. strpos( varchar<L1> , varchar<L1> , option:case_sensitivity ): -> i64 2. strpos( fixedchar<L1> , fixedchar<L2> , option:case_sensitivity ): -> i64 Return the position of the first occurrence of a string in another string. The first character of the string is at position 1. If no occurrence is found, 0 is returned. The case_sensitivity option applies to the substring argument. Options: case_sensitivity ['CASE_SENSITIVE', 'CASE_INSENSITIVE', 'CASE_INSENSITIVE_ASCII'] regexp_strpos \u00b6 Implementations: regexp_strpos( input , pattern , position , occurrence , option:case_sensitivity , option:multiline , option:dotall ): -> return_type 0. regexp_strpos( varchar<L1> , varchar<L2> , i64 , i64 , option:case_sensitivity , option:multiline , option:dotall ): -> i64 1. regexp_strpos( string , string , i64 , i64 , option:case_sensitivity , option:multiline , option:dotall ): -> i64 Return the position of an occurrence of the given regular expression pattern in a string. The first character of the string is at position 1. The regular expression pattern should follow the International Components for Unicode implementation ( https://unicode-org.github.io/icu/userguide/strings/regexp.html ). The number of characters from the beginning of the string to begin starting to search for pattern matches can be specified using the position argument. Specifying 1 means to search for matches starting at the first character of the input string, 2 means the second character, and so on. The position argument should be a positive non-zero integer. Which occurrence to return the position of is specified using the occurrence argument. Specifying 1 means the position first occurrence will be returned, 2 means the position of the second occurrence, and so on. The occurrence argument should be a positive non-zero integer. If no occurrence is found, 0 is returned. The case_sensitivity option specifies case-sensitive or case-insensitive matching. Enabling the multiline option will treat the input string as multiple lines. This makes the ^ and $ characters match at the beginning and end of any line, instead of just the beginning and end of the input string. Enabling the dotall option makes the . character match line terminator characters in a string. Behavior is undefined if the regex fails to compile, the occurrence value is out of range, or the position value is out of range. Options: case_sensitivity ['CASE_SENSITIVE', 'CASE_INSENSITIVE', 'CASE_INSENSITIVE_ASCII'] multiline ['MULTILINE_DISABLED', 'MULTILINE_ENABLED'] dotall ['DOTALL_DISABLED', 'DOTALL_ENABLED'] count_substring \u00b6 Implementations: count_substring( input , substring , option:case_sensitivity ): -> return_type input: The input string. substring: The substring to count. 0. count_substring( string , string , option:case_sensitivity ): -> i64 1. count_substring( varchar<L1> , varchar<L2> , option:case_sensitivity ): -> i64 2. count_substring( fixedchar<L1> , fixedchar<L2> , option:case_sensitivity ): -> i64 Return the number of non-overlapping occurrences of a substring in an input string. The case_sensitivity option applies to the substring argument. Options: case_sensitivity ['CASE_SENSITIVE', 'CASE_INSENSITIVE', 'CASE_INSENSITIVE_ASCII'] regexp_count_substring \u00b6 Implementations: regexp_count_substring( input , pattern , position , option:case_sensitivity , option:multiline , option:dotall ): -> return_type 0. regexp_count_substring( string , string , i64 , option:case_sensitivity , option:multiline , option:dotall ): -> i64 1. regexp_count_substring( varchar<L1> , varchar<L2> , i64 , option:case_sensitivity , option:multiline , option:dotall ): -> i64 2. regexp_count_substring( fixedchar<L1> , fixedchar<L2> , i64 , option:case_sensitivity , option:multiline , option:dotall ): -> i64 Return the number of non-overlapping occurrences of a regular expression pattern in an input string. The regular expression pattern should follow the International Components for Unicode implementation ( https://unicode-org.github.io/icu/userguide/strings/regexp.html ). The number of characters from the beginning of the string to begin starting to search for pattern matches can be specified using the position argument. Specifying 1 means to search for matches starting at the first character of the input string, 2 means the second character, and so on. The position argument should be a positive non-zero integer. The case_sensitivity option specifies case-sensitive or case-insensitive matching. Enabling the multiline option will treat the input string as multiple lines. This makes the ^ and $ characters match at the beginning and end of any line, instead of just the beginning and end of the input string. Enabling the dotall option makes the . character match line terminator characters in a string. Behavior is undefined if the regex fails to compile or the position value is out of range. Options: case_sensitivity ['CASE_SENSITIVE', 'CASE_INSENSITIVE', 'CASE_INSENSITIVE_ASCII'] multiline ['MULTILINE_DISABLED', 'MULTILINE_ENABLED'] dotall ['DOTALL_DISABLED', 'DOTALL_ENABLED'] replace \u00b6 Implementations: replace( input , substring , replacement , option:case_sensitivity ): -> return_type input: Input string. substring: The substring to replace. replacement: The replacement string. 0. replace( string , string , string , option:case_sensitivity ): -> string 1. replace( varchar<L1> , varchar<L2> , varchar<L3> , option:case_sensitivity ): -> varchar<L1> Replace all occurrences of the substring with the replacement string. The case_sensitivity option applies to the substring argument. Options: case_sensitivity ['CASE_SENSITIVE', 'CASE_INSENSITIVE', 'CASE_INSENSITIVE_ASCII'] concat_ws \u00b6 Implementations: concat_ws( separator , string_arguments ): -> return_type separator: Character to separate strings by. string_arguments: Strings to be concatenated. 0. concat_ws( string , string ): -> string 1. concat_ws( varchar<L2> , varchar<L1> ): -> varchar<L1> Concatenate strings together separated by a separator. repeat \u00b6 Implementations: repeat( input , count ): -> return_type 0. repeat( string , i64 ): -> string 1. repeat( varchar<L1> , i64 , i64 ): -> varchar<L1> Repeat a string count number of times. reverse \u00b6 Implementations: reverse( input ): -> return_type 0. reverse( string ): -> string 1. reverse( varchar<L1> ): -> varchar<L1> 2. reverse( fixedchar<L1> ): -> fixedchar<L1> Returns the string in reverse order. replace_slice \u00b6 Implementations: replace_slice( input , start , length , replacement ): -> return_type input: Input string. start: The position in the string to start deleting/inserting characters. length: The number of characters to delete from the input string. replacement: The new string to insert at the start position. 0. replace_slice( string , i64 , i64 , string ): -> string 1. replace_slice( varchar<L1> , i64 , i64 , varchar<L2> ): -> varchar<L1> Replace a slice of the input string. A specified \u2018length\u2019 of characters will be deleted from the input string beginning at the \u2018start\u2019 position and will be replaced by a new string. A start value of 1 indicates the first character of the input string. If start is negative or zero, or greater than the length of the input string, a null string is returned. If \u2018length\u2019 is negative, a null string is returned. If \u2018length\u2019 is zero, inserting of the new string occurs at the specified \u2018start\u2019 position and no characters are deleted. If \u2018length\u2019 is greater than the input string, deletion will occur up to the last character of the input string. lower \u00b6 Implementations: lower( input , option:char_set ): -> return_type 0. lower( string , option:char_set ): -> string 1. lower( varchar<L1> , option:char_set ): -> varchar<L1> 2. lower( fixedchar<L1> , option:char_set ): -> fixedchar<L1> Transform the string to lower case characters. Implementation should follow the utf8_unicode_ci collations according to the Unicode Collation Algorithm described at http://www.unicode.org/reports/tr10/ . Options: char_set ['UTF8', 'ASCII_ONLY'] upper \u00b6 Implementations: upper( input , option:char_set ): -> return_type 0. upper( string , option:char_set ): -> string 1. upper( varchar<L1> , option:char_set ): -> varchar<L1> 2. upper( fixedchar<L1> , option:char_set ): -> fixedchar<L1> Transform the string to upper case characters. Implementation should follow the utf8_unicode_ci collations according to the Unicode Collation Algorithm described at http://www.unicode.org/reports/tr10/ . Options: char_set ['UTF8', 'ASCII_ONLY'] swapcase \u00b6 Implementations: swapcase( input , option:char_set ): -> return_type 0. swapcase( string , option:char_set ): -> string 1. swapcase( varchar<L1> , option:char_set ): -> varchar<L1> 2. swapcase( fixedchar<L1> , option:char_set ): -> fixedchar<L1> Transform the string\u2019s lowercase characters to uppercase and uppercase characters to lowercase. Implementation should follow the utf8_unicode_ci collations according to the Unicode Collation Algorithm described at http://www.unicode.org/reports/tr10/ . Options: char_set ['UTF8', 'ASCII_ONLY'] capitalize \u00b6 Implementations: capitalize( input , option:char_set ): -> return_type 0. capitalize( string , option:char_set ): -> string 1. capitalize( varchar<L1> , option:char_set ): -> varchar<L1> 2. capitalize( fixedchar<L1> , option:char_set ): -> fixedchar<L1> Capitalize the first character of the input string. Implementation should follow the utf8_unicode_ci collations according to the Unicode Collation Algorithm described at http://www.unicode.org/reports/tr10/ . Options: char_set ['UTF8', 'ASCII_ONLY'] title \u00b6 Implementations: title( input , option:char_set ): -> return_type 0. title( string , option:char_set ): -> string 1. title( varchar<L1> , option:char_set ): -> varchar<L1> 2. title( fixedchar<L1> , option:char_set ): -> fixedchar<L1> Converts the input string into titlecase. Capitalize the first character of each word in the input string except for articles (a, an, the). Implementation should follow the utf8_unicode_ci collations according to the Unicode Collation Algorithm described at http://www.unicode.org/reports/tr10/ . Options: char_set ['UTF8', 'ASCII_ONLY'] char_length \u00b6 Implementations: char_length( input ): -> return_type 0. char_length( string ): -> i64 1. char_length( varchar<L1> ): -> i64 2. char_length( fixedchar<L1> ): -> i64 Return the number of characters in the input string. The length includes trailing spaces. bit_length \u00b6 Implementations: bit_length( input ): -> return_type 0. bit_length( string ): -> i64 1. bit_length( varchar<L1> ): -> i64 2. bit_length( fixedchar<L1> ): -> i64 Return the number of bits in the input string. octet_length \u00b6 Implementations: octet_length( input ): -> return_type 0. octet_length( string ): -> i64 1. octet_length( varchar<L1> ): -> i64 2. octet_length( fixedchar<L1> ): -> i64 Return the number of bytes in the input string. regexp_replace \u00b6 Implementations: regexp_replace( input , pattern , replacement , position , occurrence , option:case_sensitivity , option:multiline , option:dotall ): -> return_type input: The input string. pattern: The regular expression to search for within the input string. replacement: The replacement string. position: The position to start the search. occurrence: Which occurrence of the match to replace. 0. regexp_replace( string , string , string , i64 , i64 , option:case_sensitivity , option:multiline , option:dotall ): -> string 1. regexp_replace( varchar<L1> , varchar<L2> , varchar<L3> , i64 , i64 , option:case_sensitivity , option:multiline , option:dotall ): -> varchar<L1> Search a string for a substring that matches a given regular expression pattern and replace it with a replacement string. The regular expression pattern should follow the International Components for Unicode implementation ( https://unicode-org.github .io/icu/userguide/strings/regexp.html). The occurrence of the pattern to be replaced is specified using the occurrence argument. Specifying 1 means only the first occurrence will be replaced, 2 means the second occurrence, and so on. Specifying 0 means all occurrences will be replaced. The number of characters from the beginning of the string to begin starting to search for pattern matches can be specified using the position argument. Specifying 1 means to search for matches starting at the first character of the input string, 2 means the second character, and so on. The position argument should be a positive non-zero integer. The replacement string can capture groups using numbered backreferences. The case_sensitivity option specifies case-sensitive or case-insensitive matching. Enabling the multiline option will treat the input string as multiple lines. This makes the ^ and $ characters match at the beginning and end of any line, instead of just the beginning and end of the input string. Enabling the dotall option makes the . character match line terminator characters in a string. Behavior is undefined if the regex fails to compile, the replacement contains an illegal back-reference, the occurrence value is out of range, or the position value is out of range. Options: case_sensitivity ['CASE_SENSITIVE', 'CASE_INSENSITIVE', 'CASE_INSENSITIVE_ASCII'] multiline ['MULTILINE_DISABLED', 'MULTILINE_ENABLED'] dotall ['DOTALL_DISABLED', 'DOTALL_ENABLED'] ltrim \u00b6 Implementations: ltrim( input , characters ): -> return_type input: The string to remove characters from. characters: The set of characters to remove. 0. ltrim( varchar<L1> , varchar<L2> ): -> varchar<L1> 1. ltrim( string , string ): -> string Remove any occurrence of the characters from the left side of the string. If no characters are specified, spaces are removed. rtrim \u00b6 Implementations: rtrim( input , characters ): -> return_type input: The string to remove characters from. characters: The set of characters to remove. 0. rtrim( varchar<L1> , varchar<L2> ): -> varchar<L1> 1. rtrim( string , string ): -> string Remove any occurrence of the characters from the right side of the string. If no characters are specified, spaces are removed. trim \u00b6 Implementations: trim( input , characters ): -> return_type input: The string to remove characters from. characters: The set of characters to remove. 0. trim( varchar<L1> , varchar<L2> ): -> varchar<L1> 1. trim( string , string ): -> string Remove any occurrence of the characters from the left and right sides of the string. If no characters are specified, spaces are removed. lpad \u00b6 Implementations: lpad( input , length , characters ): -> return_type input: The string to pad. length: The length of the output string. characters: The string of characters to use for padding. 0. lpad( varchar<L1> , i32 , varchar<L2> ): -> varchar<L1> 1. lpad( string , i32 , string ): -> string Left-pad the input string with the string of \u2018characters\u2019 until the specified length of the string has been reached. If the input string is longer than \u2018length\u2019, remove characters from the right-side to shorten it to \u2018length\u2019 characters. If the string of \u2018characters\u2019 is longer than the remaining \u2018length\u2019 needed to be filled, only pad until \u2018length\u2019 has been reached. If \u2018characters\u2019 is not specified, the default value is a single space. rpad \u00b6 Implementations: rpad( input , length , characters ): -> return_type input: The string to pad. length: The length of the output string. characters: The string of characters to use for padding. 0. rpad( varchar<L1> , i32 , varchar<L2> ): -> varchar<L1> 1. rpad( string , i32 , string ): -> string Right-pad the input string with the string of \u2018characters\u2019 until the specified length of the string has been reached. If the input string is longer than \u2018length\u2019, remove characters from the left-side to shorten it to \u2018length\u2019 characters. If the string of \u2018characters\u2019 is longer than the remaining \u2018length\u2019 needed to be filled, only pad until \u2018length\u2019 has been reached. If \u2018characters\u2019 is not specified, the default value is a single space. center \u00b6 Implementations: center( input , length , character , option:padding ): -> return_type input: The string to pad. length: The length of the output string. character: The character to use for padding. 0. center( varchar<L1> , i32 , varchar<L1> , option:padding ): -> varchar<L1> 1. center( string , i32 , string , option:padding ): -> string Center the input string by padding the sides with a single character until the specified length of the string has been reached. By default, if the length will be reached with an uneven number of padding, the extra padding will be applied to the right side. The side with extra padding can be controlled with the padding option. Behavior is undefined if the number of characters passed to the character argument is not 1. Options: padding ['RIGHT', 'LEFT'] left \u00b6 Implementations: left( input , count ): -> return_type 0. left( varchar<L1> , i32 ): -> varchar<L1> 1. left( string , i32 ): -> string Extract count characters starting from the left of the string. right \u00b6 Implementations: right( input , count ): -> return_type 0. right( varchar<L1> , i32 ): -> varchar<L1> 1. right( string , i32 ): -> string Extract count characters starting from the right of the string. string_split \u00b6 Implementations: string_split( input , separator ): -> return_type input: The input string. separator: A character used for splitting the string. 0. string_split( varchar<L1> , varchar<L2> ): -> List<varchar<L1>> 1. string_split( string , string ): -> List<string> Split a string into a list of strings, based on a specified separator character. regexp_string_split \u00b6 Implementations: regexp_string_split( input , pattern , option:case_sensitivity , option:multiline , option:dotall ): -> return_type input: The input string. pattern: The regular expression to search for within the input string. 0. regexp_string_split( varchar<L1> , varchar<L2> , option:case_sensitivity , option:multiline , option:dotall ): -> List<varchar<L1>> 1. regexp_string_split( string , string , option:case_sensitivity , option:multiline , option:dotall ): -> List<string> Split a string into a list of strings, based on a regular expression pattern. The substrings matched by the pattern will be used as the separators to split the input string and will not be included in the resulting list. The regular expression pattern should follow the International Components for Unicode implementation ( https://unicode-org.github.io/icu/userguide/strings/regexp.html ). The case_sensitivity option specifies case-sensitive or case-insensitive matching. Enabling the multiline option will treat the input string as multiple lines. This makes the ^ and $ characters match at the beginning and end of any line, instead of just the beginning and end of the input string. Enabling the dotall option makes the . character match line terminator characters in a string. Options: case_sensitivity ['CASE_SENSITIVE', 'CASE_INSENSITIVE', 'CASE_INSENSITIVE_ASCII'] multiline ['MULTILINE_DISABLED', 'MULTILINE_ENABLED'] dotall ['DOTALL_DISABLED', 'DOTALL_ENABLED'] Aggregate Functions \u00b6 string_agg \u00b6 Implementations: string_agg( input , separator ): -> return_type input: Column of string values. separator: Separator for concatenated strings 0. string_agg( string , string ): -> string Concatenates a column of string values with a separator.","title":"functions_string.yaml"},{"location":"extensions/functions_string/#functions_stringyaml","text":"This document file is generated for functions_string.yaml","title":"functions_string.yaml"},{"location":"extensions/functions_string/#scalar-functions","text":"","title":"Scalar Functions"},{"location":"extensions/functions_string/#concat","text":"Implementations: concat( input ): -> return_type 0. concat( varchar<L1> ): -> varchar<L1> 1. concat( string ): -> string Concatenate strings.","title":"concat"},{"location":"extensions/functions_string/#like","text":"Implementations: like( input , match , option:case_sensitivity ): -> return_type input: The input string. match: The string to match against the input string. 0. like( varchar<L1> , varchar<L2> , option:case_sensitivity ): -> BOOLEAN 1. like( string , string , option:case_sensitivity ): -> BOOLEAN Are two strings like each other. The case_sensitivity option applies to the match argument. Options: case_sensitivity ['CASE_SENSITIVE', 'CASE_INSENSITIVE', 'CASE_INSENSITIVE_ASCII']","title":"like"},{"location":"extensions/functions_string/#substring","text":"Implementations: substring( input , start , length ): -> return_type 0. substring( varchar<L1> , i32 , i32 ): -> varchar<L1> 1. substring( string , i32 , i32 ): -> string 2. substring( fixedchar<l1> , i32 , i32 ): -> string Extract a substring of a specified length starting from position start . A start value of 1 refers to the first characters of the string.","title":"substring"},{"location":"extensions/functions_string/#regexp_match_substring","text":"Implementations: regexp_match_substring( input , pattern , position , occurrence , group , option:case_sensitivity , option:multiline , option:dotall ): -> return_type 0. regexp_match_substring( varchar<L1> , varchar<L2> , i64 , i64 , i64 , option:case_sensitivity , option:multiline , option:dotall ): -> varchar<L1> 1. regexp_match_substring( string , string , i64 , i64 , i64 , option:case_sensitivity , option:multiline , option:dotall ): -> string Extract a substring that matches the given regular expression pattern. The regular expression pattern should follow the International Components for Unicode implementation ( https://unicode-org.github.io/icu/userguide/strings/regexp.html ). The occurrence of the pattern to be extracted is specified using the occurrence argument. Specifying 1 means the first occurrence will be extracted, 2 means the second occurrence, and so on. The occurrence argument should be a positive non-zero integer. The number of characters from the beginning of the string to begin starting to search for pattern matches can be specified using the position argument. Specifying 1 means to search for matches starting at the first character of the input string, 2 means the second character, and so on. The position argument should be a positive non-zero integer. The regular expression capture group can be specified using the group argument. Specifying 0 will return the substring matching the full regular expression. Specifying 1 will return the substring matching only the first capture group, and so on. The group argument should be a non-negative integer. The case_sensitivity option specifies case-sensitive or case-insensitive matching. Enabling the multiline option will treat the input string as multiple lines. This makes the ^ and $ characters match at the beginning and end of any line, instead of just the beginning and end of the input string. Enabling the dotall option makes the . character match line terminator characters in a string. Behavior is undefined if the regex fails to compile, the occurrence value is out of range, the position value is out of range, or the group value is out of range. Options: case_sensitivity ['CASE_SENSITIVE', 'CASE_INSENSITIVE', 'CASE_INSENSITIVE_ASCII'] multiline ['MULTILINE_DISABLED', 'MULTILINE_ENABLED'] dotall ['DOTALL_DISABLED', 'DOTALL_ENABLED']","title":"regexp_match_substring"},{"location":"extensions/functions_string/#regexp_match_substring_all","text":"Implementations: regexp_match_substring_all( input , pattern , position , group , option:case_sensitivity , option:multiline , option:dotall ): -> return_type 0. regexp_match_substring_all( varchar<L1> , varchar<L2> , i64 , i64 , option:case_sensitivity , option:multiline , option:dotall ): -> List<varchar<L1>> 1. regexp_match_substring_all( string , string , i64 , i64 , option:case_sensitivity , option:multiline , option:dotall ): -> List<string> Extract all substrings that match the given regular expression pattern. This will return a list of extracted strings with one value for each occurrence of a match. The regular expression pattern should follow the International Components for Unicode implementation ( https://unicode-org.github.io/icu/userguide/strings/regexp.html ). The number of characters from the beginning of the string to begin starting to search for pattern matches can be specified using the position argument. Specifying 1 means to search for matches starting at the first character of the input string, 2 means the second character, and so on. The position argument should be a positive non-zero integer. The regular expression capture group can be specified using the group argument. Specifying 0 will return substrings matching the full regular expression. Specifying 1 will return substrings matching only the first capture group, and so on. The group argument should be a non-negative integer. The case_sensitivity option specifies case-sensitive or case-insensitive matching. Enabling the multiline option will treat the input string as multiple lines. This makes the ^ and $ characters match at the beginning and end of any line, instead of just the beginning and end of the input string. Enabling the dotall option makes the . character match line terminator characters in a string. Behavior is undefined if the regex fails to compile, the position value is out of range, or the group value is out of range. Options: case_sensitivity ['CASE_SENSITIVE', 'CASE_INSENSITIVE', 'CASE_INSENSITIVE_ASCII'] multiline ['MULTILINE_DISABLED', 'MULTILINE_ENABLED'] dotall ['DOTALL_DISABLED', 'DOTALL_ENABLED']","title":"regexp_match_substring_all"},{"location":"extensions/functions_string/#starts_with","text":"Implementations: starts_with( input , substring , option:case_sensitivity ): -> return_type input: The input string. substring: The substring to search for. 0. starts_with( varchar<L1> , varchar<L2> , option:case_sensitivity ): -> BOOLEAN 1. starts_with( varchar<L1> , string , option:case_sensitivity ): -> BOOLEAN 2. starts_with( varchar<L1> , fixedchar<L2> , option:case_sensitivity ): -> BOOLEAN 3. starts_with( string , string , option:case_sensitivity ): -> BOOLEAN 4. starts_with( string , varchar<L1> , option:case_sensitivity ): -> BOOLEAN 5. starts_with( string , fixedchar<L1> , option:case_sensitivity ): -> BOOLEAN 6. starts_with( fixedchar<L1> , fixedchar<L2> , option:case_sensitivity ): -> BOOLEAN 7. starts_with( fixedchar<L1> , string , option:case_sensitivity ): -> BOOLEAN 8. starts_with( fixedchar<L1> , varchar<L2> , option:case_sensitivity ): -> BOOLEAN Whether the input string starts with the substring . The case_sensitivity option applies to the substring argument. Options: case_sensitivity ['CASE_SENSITIVE', 'CASE_INSENSITIVE', 'CASE_INSENSITIVE_ASCII']","title":"starts_with"},{"location":"extensions/functions_string/#ends_with","text":"Implementations: ends_with( input , substring , option:case_sensitivity ): -> return_type input: The input string. substring: The substring to search for. 0. ends_with( varchar<L1> , varchar<L2> , option:case_sensitivity ): -> BOOLEAN 1. ends_with( varchar<L1> , string , option:case_sensitivity ): -> BOOLEAN 2. ends_with( varchar<L1> , fixedchar<L2> , option:case_sensitivity ): -> BOOLEAN 3. ends_with( string , string , option:case_sensitivity ): -> BOOLEAN 4. ends_with( string , varchar<L1> , option:case_sensitivity ): -> BOOLEAN 5. ends_with( string , fixedchar<L1> , option:case_sensitivity ): -> BOOLEAN 6. ends_with( fixedchar<L1> , fixedchar<L2> , option:case_sensitivity ): -> BOOLEAN 7. ends_with( fixedchar<L1> , string , option:case_sensitivity ): -> BOOLEAN 8. ends_with( fixedchar<L1> , varchar<L2> , option:case_sensitivity ): -> BOOLEAN Whether input string ends with the substring. The case_sensitivity option applies to the substring argument. Options: case_sensitivity ['CASE_SENSITIVE', 'CASE_INSENSITIVE', 'CASE_INSENSITIVE_ASCII']","title":"ends_with"},{"location":"extensions/functions_string/#contains","text":"Implementations: contains( input , substring , option:case_sensitivity ): -> return_type input: The input string. substring: The substring to search for. 0. contains( varchar<L1> , varchar<L2> , option:case_sensitivity ): -> BOOLEAN 1. contains( varchar<L1> , string , option:case_sensitivity ): -> BOOLEAN 2. contains( varchar<L1> , fixedchar<L2> , option:case_sensitivity ): -> BOOLEAN 3. contains( string , string , option:case_sensitivity ): -> BOOLEAN 4. contains( string , varchar<L1> , option:case_sensitivity ): -> BOOLEAN 5. contains( string , fixedchar<L1> , option:case_sensitivity ): -> BOOLEAN 6. contains( fixedchar<L1> , fixedchar<L2> , option:case_sensitivity ): -> BOOLEAN 7. contains( fixedchar<L1> , string , option:case_sensitivity ): -> BOOLEAN 8. contains( fixedchar<L1> , varchar<L2> , option:case_sensitivity ): -> BOOLEAN Whether the input string contains the substring . The case_sensitivity option applies to the substring argument. Options: case_sensitivity ['CASE_SENSITIVE', 'CASE_INSENSITIVE', 'CASE_INSENSITIVE_ASCII']","title":"contains"},{"location":"extensions/functions_string/#strpos","text":"Implementations: strpos( input , substring , option:case_sensitivity ): -> return_type input: The input string. substring: The substring to search for. 0. strpos( string , string , option:case_sensitivity ): -> i64 1. strpos( varchar<L1> , varchar<L1> , option:case_sensitivity ): -> i64 2. strpos( fixedchar<L1> , fixedchar<L2> , option:case_sensitivity ): -> i64 Return the position of the first occurrence of a string in another string. The first character of the string is at position 1. If no occurrence is found, 0 is returned. The case_sensitivity option applies to the substring argument. Options: case_sensitivity ['CASE_SENSITIVE', 'CASE_INSENSITIVE', 'CASE_INSENSITIVE_ASCII']","title":"strpos"},{"location":"extensions/functions_string/#regexp_strpos","text":"Implementations: regexp_strpos( input , pattern , position , occurrence , option:case_sensitivity , option:multiline , option:dotall ): -> return_type 0. regexp_strpos( varchar<L1> , varchar<L2> , i64 , i64 , option:case_sensitivity , option:multiline , option:dotall ): -> i64 1. regexp_strpos( string , string , i64 , i64 , option:case_sensitivity , option:multiline , option:dotall ): -> i64 Return the position of an occurrence of the given regular expression pattern in a string. The first character of the string is at position 1. The regular expression pattern should follow the International Components for Unicode implementation ( https://unicode-org.github.io/icu/userguide/strings/regexp.html ). The number of characters from the beginning of the string to begin starting to search for pattern matches can be specified using the position argument. Specifying 1 means to search for matches starting at the first character of the input string, 2 means the second character, and so on. The position argument should be a positive non-zero integer. Which occurrence to return the position of is specified using the occurrence argument. Specifying 1 means the position first occurrence will be returned, 2 means the position of the second occurrence, and so on. The occurrence argument should be a positive non-zero integer. If no occurrence is found, 0 is returned. The case_sensitivity option specifies case-sensitive or case-insensitive matching. Enabling the multiline option will treat the input string as multiple lines. This makes the ^ and $ characters match at the beginning and end of any line, instead of just the beginning and end of the input string. Enabling the dotall option makes the . character match line terminator characters in a string. Behavior is undefined if the regex fails to compile, the occurrence value is out of range, or the position value is out of range. Options: case_sensitivity ['CASE_SENSITIVE', 'CASE_INSENSITIVE', 'CASE_INSENSITIVE_ASCII'] multiline ['MULTILINE_DISABLED', 'MULTILINE_ENABLED'] dotall ['DOTALL_DISABLED', 'DOTALL_ENABLED']","title":"regexp_strpos"},{"location":"extensions/functions_string/#count_substring","text":"Implementations: count_substring( input , substring , option:case_sensitivity ): -> return_type input: The input string. substring: The substring to count. 0. count_substring( string , string , option:case_sensitivity ): -> i64 1. count_substring( varchar<L1> , varchar<L2> , option:case_sensitivity ): -> i64 2. count_substring( fixedchar<L1> , fixedchar<L2> , option:case_sensitivity ): -> i64 Return the number of non-overlapping occurrences of a substring in an input string. The case_sensitivity option applies to the substring argument. Options: case_sensitivity ['CASE_SENSITIVE', 'CASE_INSENSITIVE', 'CASE_INSENSITIVE_ASCII']","title":"count_substring"},{"location":"extensions/functions_string/#regexp_count_substring","text":"Implementations: regexp_count_substring( input , pattern , position , option:case_sensitivity , option:multiline , option:dotall ): -> return_type 0. regexp_count_substring( string , string , i64 , option:case_sensitivity , option:multiline , option:dotall ): -> i64 1. regexp_count_substring( varchar<L1> , varchar<L2> , i64 , option:case_sensitivity , option:multiline , option:dotall ): -> i64 2. regexp_count_substring( fixedchar<L1> , fixedchar<L2> , i64 , option:case_sensitivity , option:multiline , option:dotall ): -> i64 Return the number of non-overlapping occurrences of a regular expression pattern in an input string. The regular expression pattern should follow the International Components for Unicode implementation ( https://unicode-org.github.io/icu/userguide/strings/regexp.html ). The number of characters from the beginning of the string to begin starting to search for pattern matches can be specified using the position argument. Specifying 1 means to search for matches starting at the first character of the input string, 2 means the second character, and so on. The position argument should be a positive non-zero integer. The case_sensitivity option specifies case-sensitive or case-insensitive matching. Enabling the multiline option will treat the input string as multiple lines. This makes the ^ and $ characters match at the beginning and end of any line, instead of just the beginning and end of the input string. Enabling the dotall option makes the . character match line terminator characters in a string. Behavior is undefined if the regex fails to compile or the position value is out of range. Options: case_sensitivity ['CASE_SENSITIVE', 'CASE_INSENSITIVE', 'CASE_INSENSITIVE_ASCII'] multiline ['MULTILINE_DISABLED', 'MULTILINE_ENABLED'] dotall ['DOTALL_DISABLED', 'DOTALL_ENABLED']","title":"regexp_count_substring"},{"location":"extensions/functions_string/#replace","text":"Implementations: replace( input , substring , replacement , option:case_sensitivity ): -> return_type input: Input string. substring: The substring to replace. replacement: The replacement string. 0. replace( string , string , string , option:case_sensitivity ): -> string 1. replace( varchar<L1> , varchar<L2> , varchar<L3> , option:case_sensitivity ): -> varchar<L1> Replace all occurrences of the substring with the replacement string. The case_sensitivity option applies to the substring argument. Options: case_sensitivity ['CASE_SENSITIVE', 'CASE_INSENSITIVE', 'CASE_INSENSITIVE_ASCII']","title":"replace"},{"location":"extensions/functions_string/#concat_ws","text":"Implementations: concat_ws( separator , string_arguments ): -> return_type separator: Character to separate strings by. string_arguments: Strings to be concatenated. 0. concat_ws( string , string ): -> string 1. concat_ws( varchar<L2> , varchar<L1> ): -> varchar<L1> Concatenate strings together separated by a separator.","title":"concat_ws"},{"location":"extensions/functions_string/#repeat","text":"Implementations: repeat( input , count ): -> return_type 0. repeat( string , i64 ): -> string 1. repeat( varchar<L1> , i64 , i64 ): -> varchar<L1> Repeat a string count number of times.","title":"repeat"},{"location":"extensions/functions_string/#reverse","text":"Implementations: reverse( input ): -> return_type 0. reverse( string ): -> string 1. reverse( varchar<L1> ): -> varchar<L1> 2. reverse( fixedchar<L1> ): -> fixedchar<L1> Returns the string in reverse order.","title":"reverse"},{"location":"extensions/functions_string/#replace_slice","text":"Implementations: replace_slice( input , start , length , replacement ): -> return_type input: Input string. start: The position in the string to start deleting/inserting characters. length: The number of characters to delete from the input string. replacement: The new string to insert at the start position. 0. replace_slice( string , i64 , i64 , string ): -> string 1. replace_slice( varchar<L1> , i64 , i64 , varchar<L2> ): -> varchar<L1> Replace a slice of the input string. A specified \u2018length\u2019 of characters will be deleted from the input string beginning at the \u2018start\u2019 position and will be replaced by a new string. A start value of 1 indicates the first character of the input string. If start is negative or zero, or greater than the length of the input string, a null string is returned. If \u2018length\u2019 is negative, a null string is returned. If \u2018length\u2019 is zero, inserting of the new string occurs at the specified \u2018start\u2019 position and no characters are deleted. If \u2018length\u2019 is greater than the input string, deletion will occur up to the last character of the input string.","title":"replace_slice"},{"location":"extensions/functions_string/#lower","text":"Implementations: lower( input , option:char_set ): -> return_type 0. lower( string , option:char_set ): -> string 1. lower( varchar<L1> , option:char_set ): -> varchar<L1> 2. lower( fixedchar<L1> , option:char_set ): -> fixedchar<L1> Transform the string to lower case characters. Implementation should follow the utf8_unicode_ci collations according to the Unicode Collation Algorithm described at http://www.unicode.org/reports/tr10/ . Options: char_set ['UTF8', 'ASCII_ONLY']","title":"lower"},{"location":"extensions/functions_string/#upper","text":"Implementations: upper( input , option:char_set ): -> return_type 0. upper( string , option:char_set ): -> string 1. upper( varchar<L1> , option:char_set ): -> varchar<L1> 2. upper( fixedchar<L1> , option:char_set ): -> fixedchar<L1> Transform the string to upper case characters. Implementation should follow the utf8_unicode_ci collations according to the Unicode Collation Algorithm described at http://www.unicode.org/reports/tr10/ . Options: char_set ['UTF8', 'ASCII_ONLY']","title":"upper"},{"location":"extensions/functions_string/#swapcase","text":"Implementations: swapcase( input , option:char_set ): -> return_type 0. swapcase( string , option:char_set ): -> string 1. swapcase( varchar<L1> , option:char_set ): -> varchar<L1> 2. swapcase( fixedchar<L1> , option:char_set ): -> fixedchar<L1> Transform the string\u2019s lowercase characters to uppercase and uppercase characters to lowercase. Implementation should follow the utf8_unicode_ci collations according to the Unicode Collation Algorithm described at http://www.unicode.org/reports/tr10/ . Options: char_set ['UTF8', 'ASCII_ONLY']","title":"swapcase"},{"location":"extensions/functions_string/#capitalize","text":"Implementations: capitalize( input , option:char_set ): -> return_type 0. capitalize( string , option:char_set ): -> string 1. capitalize( varchar<L1> , option:char_set ): -> varchar<L1> 2. capitalize( fixedchar<L1> , option:char_set ): -> fixedchar<L1> Capitalize the first character of the input string. Implementation should follow the utf8_unicode_ci collations according to the Unicode Collation Algorithm described at http://www.unicode.org/reports/tr10/ . Options: char_set ['UTF8', 'ASCII_ONLY']","title":"capitalize"},{"location":"extensions/functions_string/#title","text":"Implementations: title( input , option:char_set ): -> return_type 0. title( string , option:char_set ): -> string 1. title( varchar<L1> , option:char_set ): -> varchar<L1> 2. title( fixedchar<L1> , option:char_set ): -> fixedchar<L1> Converts the input string into titlecase. Capitalize the first character of each word in the input string except for articles (a, an, the). Implementation should follow the utf8_unicode_ci collations according to the Unicode Collation Algorithm described at http://www.unicode.org/reports/tr10/ . Options: char_set ['UTF8', 'ASCII_ONLY']","title":"title"},{"location":"extensions/functions_string/#char_length","text":"Implementations: char_length( input ): -> return_type 0. char_length( string ): -> i64 1. char_length( varchar<L1> ): -> i64 2. char_length( fixedchar<L1> ): -> i64 Return the number of characters in the input string. The length includes trailing spaces.","title":"char_length"},{"location":"extensions/functions_string/#bit_length","text":"Implementations: bit_length( input ): -> return_type 0. bit_length( string ): -> i64 1. bit_length( varchar<L1> ): -> i64 2. bit_length( fixedchar<L1> ): -> i64 Return the number of bits in the input string.","title":"bit_length"},{"location":"extensions/functions_string/#octet_length","text":"Implementations: octet_length( input ): -> return_type 0. octet_length( string ): -> i64 1. octet_length( varchar<L1> ): -> i64 2. octet_length( fixedchar<L1> ): -> i64 Return the number of bytes in the input string.","title":"octet_length"},{"location":"extensions/functions_string/#regexp_replace","text":"Implementations: regexp_replace( input , pattern , replacement , position , occurrence , option:case_sensitivity , option:multiline , option:dotall ): -> return_type input: The input string. pattern: The regular expression to search for within the input string. replacement: The replacement string. position: The position to start the search. occurrence: Which occurrence of the match to replace. 0. regexp_replace( string , string , string , i64 , i64 , option:case_sensitivity , option:multiline , option:dotall ): -> string 1. regexp_replace( varchar<L1> , varchar<L2> , varchar<L3> , i64 , i64 , option:case_sensitivity , option:multiline , option:dotall ): -> varchar<L1> Search a string for a substring that matches a given regular expression pattern and replace it with a replacement string. The regular expression pattern should follow the International Components for Unicode implementation ( https://unicode-org.github .io/icu/userguide/strings/regexp.html). The occurrence of the pattern to be replaced is specified using the occurrence argument. Specifying 1 means only the first occurrence will be replaced, 2 means the second occurrence, and so on. Specifying 0 means all occurrences will be replaced. The number of characters from the beginning of the string to begin starting to search for pattern matches can be specified using the position argument. Specifying 1 means to search for matches starting at the first character of the input string, 2 means the second character, and so on. The position argument should be a positive non-zero integer. The replacement string can capture groups using numbered backreferences. The case_sensitivity option specifies case-sensitive or case-insensitive matching. Enabling the multiline option will treat the input string as multiple lines. This makes the ^ and $ characters match at the beginning and end of any line, instead of just the beginning and end of the input string. Enabling the dotall option makes the . character match line terminator characters in a string. Behavior is undefined if the regex fails to compile, the replacement contains an illegal back-reference, the occurrence value is out of range, or the position value is out of range. Options: case_sensitivity ['CASE_SENSITIVE', 'CASE_INSENSITIVE', 'CASE_INSENSITIVE_ASCII'] multiline ['MULTILINE_DISABLED', 'MULTILINE_ENABLED'] dotall ['DOTALL_DISABLED', 'DOTALL_ENABLED']","title":"regexp_replace"},{"location":"extensions/functions_string/#ltrim","text":"Implementations: ltrim( input , characters ): -> return_type input: The string to remove characters from. characters: The set of characters to remove. 0. ltrim( varchar<L1> , varchar<L2> ): -> varchar<L1> 1. ltrim( string , string ): -> string Remove any occurrence of the characters from the left side of the string. If no characters are specified, spaces are removed.","title":"ltrim"},{"location":"extensions/functions_string/#rtrim","text":"Implementations: rtrim( input , characters ): -> return_type input: The string to remove characters from. characters: The set of characters to remove. 0. rtrim( varchar<L1> , varchar<L2> ): -> varchar<L1> 1. rtrim( string , string ): -> string Remove any occurrence of the characters from the right side of the string. If no characters are specified, spaces are removed.","title":"rtrim"},{"location":"extensions/functions_string/#trim","text":"Implementations: trim( input , characters ): -> return_type input: The string to remove characters from. characters: The set of characters to remove. 0. trim( varchar<L1> , varchar<L2> ): -> varchar<L1> 1. trim( string , string ): -> string Remove any occurrence of the characters from the left and right sides of the string. If no characters are specified, spaces are removed.","title":"trim"},{"location":"extensions/functions_string/#lpad","text":"Implementations: lpad( input , length , characters ): -> return_type input: The string to pad. length: The length of the output string. characters: The string of characters to use for padding. 0. lpad( varchar<L1> , i32 , varchar<L2> ): -> varchar<L1> 1. lpad( string , i32 , string ): -> string Left-pad the input string with the string of \u2018characters\u2019 until the specified length of the string has been reached. If the input string is longer than \u2018length\u2019, remove characters from the right-side to shorten it to \u2018length\u2019 characters. If the string of \u2018characters\u2019 is longer than the remaining \u2018length\u2019 needed to be filled, only pad until \u2018length\u2019 has been reached. If \u2018characters\u2019 is not specified, the default value is a single space.","title":"lpad"},{"location":"extensions/functions_string/#rpad","text":"Implementations: rpad( input , length , characters ): -> return_type input: The string to pad. length: The length of the output string. characters: The string of characters to use for padding. 0. rpad( varchar<L1> , i32 , varchar<L2> ): -> varchar<L1> 1. rpad( string , i32 , string ): -> string Right-pad the input string with the string of \u2018characters\u2019 until the specified length of the string has been reached. If the input string is longer than \u2018length\u2019, remove characters from the left-side to shorten it to \u2018length\u2019 characters. If the string of \u2018characters\u2019 is longer than the remaining \u2018length\u2019 needed to be filled, only pad until \u2018length\u2019 has been reached. If \u2018characters\u2019 is not specified, the default value is a single space.","title":"rpad"},{"location":"extensions/functions_string/#center","text":"Implementations: center( input , length , character , option:padding ): -> return_type input: The string to pad. length: The length of the output string. character: The character to use for padding. 0. center( varchar<L1> , i32 , varchar<L1> , option:padding ): -> varchar<L1> 1. center( string , i32 , string , option:padding ): -> string Center the input string by padding the sides with a single character until the specified length of the string has been reached. By default, if the length will be reached with an uneven number of padding, the extra padding will be applied to the right side. The side with extra padding can be controlled with the padding option. Behavior is undefined if the number of characters passed to the character argument is not 1. Options: padding ['RIGHT', 'LEFT']","title":"center"},{"location":"extensions/functions_string/#left","text":"Implementations: left( input , count ): -> return_type 0. left( varchar<L1> , i32 ): -> varchar<L1> 1. left( string , i32 ): -> string Extract count characters starting from the left of the string.","title":"left"},{"location":"extensions/functions_string/#right","text":"Implementations: right( input , count ): -> return_type 0. right( varchar<L1> , i32 ): -> varchar<L1> 1. right( string , i32 ): -> string Extract count characters starting from the right of the string.","title":"right"},{"location":"extensions/functions_string/#string_split","text":"Implementations: string_split( input , separator ): -> return_type input: The input string. separator: A character used for splitting the string. 0. string_split( varchar<L1> , varchar<L2> ): -> List<varchar<L1>> 1. string_split( string , string ): -> List<string> Split a string into a list of strings, based on a specified separator character.","title":"string_split"},{"location":"extensions/functions_string/#regexp_string_split","text":"Implementations: regexp_string_split( input , pattern , option:case_sensitivity , option:multiline , option:dotall ): -> return_type input: The input string. pattern: The regular expression to search for within the input string. 0. regexp_string_split( varchar<L1> , varchar<L2> , option:case_sensitivity , option:multiline , option:dotall ): -> List<varchar<L1>> 1. regexp_string_split( string , string , option:case_sensitivity , option:multiline , option:dotall ): -> List<string> Split a string into a list of strings, based on a regular expression pattern. The substrings matched by the pattern will be used as the separators to split the input string and will not be included in the resulting list. The regular expression pattern should follow the International Components for Unicode implementation ( https://unicode-org.github.io/icu/userguide/strings/regexp.html ). The case_sensitivity option specifies case-sensitive or case-insensitive matching. Enabling the multiline option will treat the input string as multiple lines. This makes the ^ and $ characters match at the beginning and end of any line, instead of just the beginning and end of the input string. Enabling the dotall option makes the . character match line terminator characters in a string. Options: case_sensitivity ['CASE_SENSITIVE', 'CASE_INSENSITIVE', 'CASE_INSENSITIVE_ASCII'] multiline ['MULTILINE_DISABLED', 'MULTILINE_ENABLED'] dotall ['DOTALL_DISABLED', 'DOTALL_ENABLED']","title":"regexp_string_split"},{"location":"extensions/functions_string/#aggregate-functions","text":"","title":"Aggregate Functions"},{"location":"extensions/functions_string/#string_agg","text":"Implementations: string_agg( input , separator ): -> return_type input: Column of string values. separator: Separator for concatenated strings 0. string_agg( string , string ): -> string Concatenates a column of string values with a separator.","title":"string_agg"},{"location":"relations/basics/","text":"Basics \u00b6 Substrait is designed to allow a user to construct an arbitrarily complex data transformation plan. The plan is composed of one or more relational operations. Relational operations are well-defined transformation operations that work by taking zero or more input datasets and transforming them into zero or more output transformations. Substrait defines a core set of transformations, but users are also able to extend the operations with their own specialized operations. Each relational operation is composed of several properties. Common properties for relational operations include the following: Property Description Type Emit The set of columns output from this operation and the order of those columns. Logical & Physical Hints A set of optionally provided, optionally consumed information about an operation that better informs execution. These might include estimated number of input and output records, estimated record size, likely filter reduction, estimated dictionary size, etc. These can also include implementation specific pieces of execution information. Physical Constraint A set of runtime constraints around the operation, limiting its consumption based on real-world resources (CPU, memory) as well as virtual resources like number of records produced, the largest record size, etc. Physical Relational Signatures \u00b6 In functions, function signatures are declared externally to the use of those signatures (function bindings). In the case of relational operations, signatures are declared directly in the specification. This is due to the speed of change and number of total operations. Relational operations in the specification are expected to be <100 for several years with additions being infrequent. On the other hand, there is an expectation of both a much larger number of functions (1,000s) and a much higher velocity of additions. Each relational operation must declare the following: Transformation logic around properties of the data. For example, does a relational operation maintain sortedness of a field? Does an operation change the distribution of data? How many input sets does an operation produce? Does the operator produce an output (by specification, we limit relational operations to a single output at this time) What is the schema and field ordering of an output (see emit below)? Emit: Output Ordering \u00b6 A relational operation uses field references to access specific fields of the input stream. Field references are always ordinal based on the order of the incoming streams. Each relational operation must declare the order of its output data. To simplify things, each relational operation can be in one of two modes: Direct output : The order of outputs is based on the definition declared by the relational operation. Remap : A listed ordering of the direct outputs. This remapping can be also used to drop columns no longer used (such as a filter field or join keys after a join). Note that remapping/exclusion can only be done at the outputs root struct. Filtering of compound values or extracting subsets must be done through other operation types (e.g. projection). Relation Properties \u00b6 There are a number of predefined properties that exist in Substrait relations. These include the following. Distribution \u00b6 When data is partitioned across multiple sibling sets, distribution describes that set of properties that apply to any one partition. This is based on a set of distribution expression properties. A distribution is declared as a set of one or more fields and a distribution type across all fields. Property Description Required Distribution Fields List of fields references that describe distribution (e.g. [0,2:4,5:0:0]). The order of these references do not impact results. Required for partitioned distribution type. Disallowed for singleton distribution type. Distribution Type PARTITIONED: For a discrete tuple of values for the declared distribution fields, all records with that tuple are located in the same partition. SINGLETON: there will only be a single partition for this operation. Required Orderedness \u00b6 A guarantee that data output from this operation is provided with a sort order. The sort order will be declared based on a set of sort field definitions based on the emitted output of this operation. Property Description Required Sort Fields A list of fields that the data are ordered by. The list is in order of the sort. If sort by [0,1] this means we only consider the data for field 1 is only ordered within each discrete value of field 0. At least one required. Per - Sort Field A field reference that the data is sorted by. Required Per - Sort Direction The direction of the data. See direction options below. Required Ordering Directions \u00b6 Direction Descriptions Nulls Position Ascending Returns data in ascending order based on the quality function associated with the type. Nulls are included before any values. First Descending Returns data in descending order based on the quality function associated with the type. Nulls are included before any values. First Ascending Returns data in ascending order based on the quality function associated with the type. Nulls are included after any values. Last Descending Returns data in descending order based on the quality function associated with the type. Nulls are included after any values. Last Custom function identifier Returns data using a custom function that returns -1, 0, or 1 depending on the order of the data. Per Function Clustered Ensures that all equal values are coalesced (but no ordering between values is defined). E.g, for values 1,2,3,1,2,3, output could be any of the following 1,1,2,2,3,3 or 2,2,3,3,1,1 or 3,3,2,2,1,1 or 3,3,1,1,2,2. N/A, may appear anywhere but will be coalesced. Discussion Points \u00b6 Do we try to make read definition types more extensible \u00e0 la function signatures? Is that necessary if we have a custom relational operator? How do we express decomposed types. For example, the Iceberg type above is for early logical planning. Once we do some operations, it may produce a list of Iceberg file reads. This is likely a secondary type of object. We currently include a \u201cgeneric properties\u201d property on read type. Do we want this dumping ground?","title":"Basics"},{"location":"relations/basics/#basics","text":"Substrait is designed to allow a user to construct an arbitrarily complex data transformation plan. The plan is composed of one or more relational operations. Relational operations are well-defined transformation operations that work by taking zero or more input datasets and transforming them into zero or more output transformations. Substrait defines a core set of transformations, but users are also able to extend the operations with their own specialized operations. Each relational operation is composed of several properties. Common properties for relational operations include the following: Property Description Type Emit The set of columns output from this operation and the order of those columns. Logical & Physical Hints A set of optionally provided, optionally consumed information about an operation that better informs execution. These might include estimated number of input and output records, estimated record size, likely filter reduction, estimated dictionary size, etc. These can also include implementation specific pieces of execution information. Physical Constraint A set of runtime constraints around the operation, limiting its consumption based on real-world resources (CPU, memory) as well as virtual resources like number of records produced, the largest record size, etc. Physical","title":"Basics"},{"location":"relations/basics/#relational-signatures","text":"In functions, function signatures are declared externally to the use of those signatures (function bindings). In the case of relational operations, signatures are declared directly in the specification. This is due to the speed of change and number of total operations. Relational operations in the specification are expected to be <100 for several years with additions being infrequent. On the other hand, there is an expectation of both a much larger number of functions (1,000s) and a much higher velocity of additions. Each relational operation must declare the following: Transformation logic around properties of the data. For example, does a relational operation maintain sortedness of a field? Does an operation change the distribution of data? How many input sets does an operation produce? Does the operator produce an output (by specification, we limit relational operations to a single output at this time) What is the schema and field ordering of an output (see emit below)?","title":"Relational Signatures"},{"location":"relations/basics/#emit-output-ordering","text":"A relational operation uses field references to access specific fields of the input stream. Field references are always ordinal based on the order of the incoming streams. Each relational operation must declare the order of its output data. To simplify things, each relational operation can be in one of two modes: Direct output : The order of outputs is based on the definition declared by the relational operation. Remap : A listed ordering of the direct outputs. This remapping can be also used to drop columns no longer used (such as a filter field or join keys after a join). Note that remapping/exclusion can only be done at the outputs root struct. Filtering of compound values or extracting subsets must be done through other operation types (e.g. projection).","title":"Emit: Output Ordering"},{"location":"relations/basics/#relation-properties","text":"There are a number of predefined properties that exist in Substrait relations. These include the following.","title":"Relation Properties"},{"location":"relations/basics/#distribution","text":"When data is partitioned across multiple sibling sets, distribution describes that set of properties that apply to any one partition. This is based on a set of distribution expression properties. A distribution is declared as a set of one or more fields and a distribution type across all fields. Property Description Required Distribution Fields List of fields references that describe distribution (e.g. [0,2:4,5:0:0]). The order of these references do not impact results. Required for partitioned distribution type. Disallowed for singleton distribution type. Distribution Type PARTITIONED: For a discrete tuple of values for the declared distribution fields, all records with that tuple are located in the same partition. SINGLETON: there will only be a single partition for this operation. Required","title":"Distribution"},{"location":"relations/basics/#orderedness","text":"A guarantee that data output from this operation is provided with a sort order. The sort order will be declared based on a set of sort field definitions based on the emitted output of this operation. Property Description Required Sort Fields A list of fields that the data are ordered by. The list is in order of the sort. If sort by [0,1] this means we only consider the data for field 1 is only ordered within each discrete value of field 0. At least one required. Per - Sort Field A field reference that the data is sorted by. Required Per - Sort Direction The direction of the data. See direction options below. Required","title":"Orderedness"},{"location":"relations/basics/#ordering-directions","text":"Direction Descriptions Nulls Position Ascending Returns data in ascending order based on the quality function associated with the type. Nulls are included before any values. First Descending Returns data in descending order based on the quality function associated with the type. Nulls are included before any values. First Ascending Returns data in ascending order based on the quality function associated with the type. Nulls are included after any values. Last Descending Returns data in descending order based on the quality function associated with the type. Nulls are included after any values. Last Custom function identifier Returns data using a custom function that returns -1, 0, or 1 depending on the order of the data. Per Function Clustered Ensures that all equal values are coalesced (but no ordering between values is defined). E.g, for values 1,2,3,1,2,3, output could be any of the following 1,1,2,2,3,3 or 2,2,3,3,1,1 or 3,3,2,2,1,1 or 3,3,1,1,2,2. N/A, may appear anywhere but will be coalesced.","title":"Ordering Directions"},{"location":"relations/basics/#discussion-points","text":"Do we try to make read definition types more extensible \u00e0 la function signatures? Is that necessary if we have a custom relational operator? How do we express decomposed types. For example, the Iceberg type above is for early logical planning. Once we do some operations, it may produce a list of Iceberg file reads. This is likely a secondary type of object. We currently include a \u201cgeneric properties\u201d property on read type. Do we want this dumping ground?","title":"Discussion Points"},{"location":"relations/embedded_relations/","text":"Embedded Relations \u00b6 Pending. Embedded relations allow a Substrait producer to define a set operation that will be embedded in the plan. TODO: define lots of details about what interfaces, languages, formats, etc. Should reasonably be an extension of embedded user defined table functions.","title":"Embedded Relations"},{"location":"relations/embedded_relations/#embedded-relations","text":"Pending. Embedded relations allow a Substrait producer to define a set operation that will be embedded in the plan. TODO: define lots of details about what interfaces, languages, formats, etc. Should reasonably be an extension of embedded user defined table functions.","title":"Embedded Relations"},{"location":"relations/logical_relations/","text":"Logical Relations \u00b6 Read Operator \u00b6 The read operator is an operator that produces one output. A simple example would be the reading of a Parquet file. It is expected that many types of reads will be added over time. Signature Value Inputs 0 Outputs 1 Property Maintenance N/A (no inputs) Direct Output Order Defaults to the schema of the data read after the optional projection (masked complex expression) is applied. Read Properties \u00b6 Property Description Required Definition The contents of the read property definition. Required Direct Schema Defines the schema of the output of the read (before any projection or emit remapping/hiding). Required Filter A boolean Substrait expression that describes a filter that must be applied to the data. The filter should be interpreted against the direct schema. Optional, defaults to none. Best Effort Filter A boolean Substrait expression that describes a filter that may be applied to the data. The filter should be interpreted against the direct schema. Optional, defaults to none. Projection A masked complex expression describing the portions of the content that should be read Optional, defaults to all of schema Output Properties Declaration of orderedness and/or distribution properties this read produces. Optional, defaults to no properties. Properties A list of name/value pairs associated with the read. Optional, defaults to empty Read Filtering \u00b6 The read relation has two different filter properties. A filter, which must be satisfied by the operator and a best effort filter, which does not have to be satisfied. This reflects the way that consumers are often implemented. A consumer is often only able to fully apply a limited set of operations in the scan. There can then be an extended set of operations which a consumer can apply in a best effort fashion. A producer, when setting these two fields, should take care to only use expressions that the consumer is capable of handling. As an example, a consumer may only be able to fully apply (in the read relation) <, =, and > on integral types. The consumer may be able to apply <, =, and > in a best effort fashion on decimal and string types. Consider the filter expression my_int < 10 && my_string < \"x\" && upper(my_string) > \"B\" . In this case the filter should be set to my_int < 10 and the best_effort_filter should be set to my_string < \"x\" and the remaining portion ( upper(my_string) > \"B\" ) should be put into a filter relation. A filter expression must be interpreted against the direct schema before the projection expression has been applied. As a result, fields may be referenced by the filter expression which are not included in the relation\u2019s output. Read Definition Types \u00b6 Read definition types are built by the community and added to the specification. This is a portion of specification that is expected to grow rapidly. Virtual Table \u00b6 A virtual table is a table whose contents are embedded in the plan itself. The table data is encoded as records consisting of literal values. Property Description Required Data Required Required Named Table \u00b6 A named table is a reference to data defined elsewhere. For example, there may be a catalog of tables with unique names that both the producer and consumer agree on. This catalog would provide the consumer with more information on how to retrieve the data. Property Description Required Names A list of namespaced strings that, together, form the table name Required (at least one) Files Type \u00b6 Property Description Required Items An array of Items (path or path glob) associated with the read. Required Format per item Enumeration of available formats. Only current option is PARQUET. Required Slicing parameters per item Information to use when reading a slice of a file. Optional Slicing Files \u00b6 A read operation is allowed to only read part of a file. This is convenient, for example, when distributing a read operation across several nodes. The slicing parameters are specified as byte offsets into the file. Many file formats consist of indivisible \u201cchunks\u201d of data (e.g. Parquet row groups). If this happens the consumer can determine which slice a particular chunk belongs to. For example, one possible approach is that a chunk should only be read if the midpoint of the chunk (dividing by 2 and rounding down) is contained within the asked-for byte range. ReadRel Message message ReadRel { RelCommon common = 1 ; NamedStruct base_schema = 2 ; Expression filter = 3 ; Expression best_effort_filter = 11 ; Expression.MaskExpression projection = 4 ; substrait.extensions.AdvancedExtension advanced_extension = 10 ; // Definition of which type of scan operation is to be performed oneof read_type { VirtualTable virtual_table = 5 ; LocalFiles local_files = 6 ; NamedTable named_table = 7 ; ExtensionTable extension_table = 8 ; } // A base table. The list of string is used to represent namespacing (e.g., mydb.mytable). // This assumes shared catalog between systems exchanging a message. message NamedTable { repeated string names = 1 ; substrait.extensions.AdvancedExtension advanced_extension = 10 ; } // A table composed of literals. message VirtualTable { repeated Expression.Literal.Struct values = 1 ; } // A stub type that can be used to extend/introduce new table types outside // the specification. message ExtensionTable { google.protobuf.Any detail = 1 ; } // Represents a list of files in input of a scan operation message LocalFiles { repeated FileOrFiles items = 1 ; substrait.extensions.AdvancedExtension advanced_extension = 10 ; // Many files consist of indivisible chunks (e.g. parquet row groups // or CSV rows). If a slice partially selects an indivisible chunk // then the consumer should employ some rule to decide which slice to // include the chunk in (e.g. include it in the slice that contains // the midpoint of the chunk) message FileOrFiles { oneof path_type { // A URI that can refer to either a single folder or a single file string uri_path = 1 ; // A URI where the path portion is a glob expression that can // identify zero or more paths. // Consumers should support the POSIX syntax. The recursive // globstar (**) may not be supported. string uri_path_glob = 2 ; // A URI that refers to a single file string uri_file = 3 ; // A URI that refers to a single folder string uri_folder = 4 ; } // Original file format enum, superseded by the file_format oneof. reserved 5 ; reserved \"format\" ; // The index of the partition this item belongs to uint64 partition_index = 6 ; // The start position in byte to read from this item uint64 start = 7 ; // The length in byte to read from this item uint64 length = 8 ; message ParquetReadOptions {} message ArrowReadOptions {} message OrcReadOptions {} message DwrfReadOptions {} // The format of the files. oneof file_format { ParquetReadOptions parquet = 9 ; ArrowReadOptions arrow = 10 ; OrcReadOptions orc = 11 ; google.protobuf.Any extension = 12 ; DwrfReadOptions dwrf = 13 ; } } } } Filter Operation \u00b6 The filter operator eliminates one or more records from the input data based on a boolean filter expression. Signature Value Inputs 1 Outputs 1 Property Maintenance Orderedness, Distribution, remapped by emit Direct Output Order The field order as the input. Filter Properties \u00b6 Property Description Required Input The relational input. Required Expression A boolean expression which describes which records are included/excluded. Required FilterRel Message message FilterRel { RelCommon common = 1 ; Rel input = 2 ; Expression condition = 3 ; substrait.extensions.AdvancedExtension advanced_extension = 10 ; } Sort Operation \u00b6 The sort operator reorders a dataset based on one or more identified sort fields and a sorting function for each. Signature Value Inputs 1 Outputs 1 Property Maintenance Will update orderedness property to the output of the sort operation. Distribution property only remapped based on emit. Direct Output Order The field order of the input. Sort Properties \u00b6 Property Description Required Input The relational input. Required Sort Fields List of one or more fields to sort by. Uses the same properties as the orderedness property. One sort field required SortRel Message message SortRel { RelCommon common = 1 ; Rel input = 2 ; repeated SortField sorts = 3 ; substrait.extensions.AdvancedExtension advanced_extension = 10 ; } Project Operation \u00b6 The project operation will produce one or more additional expressions based on the inputs of the dataset. Signature Value Inputs 1 Outputs 1 Property Maintenance Distribution maintained, mapped by emit. Orderedness: Maintained if no window operations. Extended to include projection fields if fields are direct references. If window operations are present, no orderedness is maintained. Direct Output Order The field order of the input + the list of new expressions in the order they are declared in the expressions list. Project Properties \u00b6 Property Description Required Input The relational input. Required Expressions List of one or more expressions to add to the input. At least one expression required ProjectRel Message message ProjectRel { RelCommon common = 1 ; Rel input = 2 ; repeated Expression expressions = 3 ; substrait.extensions.AdvancedExtension advanced_extension = 10 ; } Cross Product Operation \u00b6 The cross product operation will combine two separate inputs into a single output. It pairs every record from the left input with every record of the right input. Signature Value Inputs 2 Outputs 1 Property Maintenance Distribution is maintained. Orderedness is empty post operation. Direct Output Order The emit order of the left input followed by the emit order of the right input. Cross Product Properties \u00b6 Property Description Required Left Input A relational input. Required Right Input A relational input. Required CrossRel Message message CrossRel { RelCommon common = 1 ; Rel left = 2 ; Rel right = 3 ; substrait.extensions.AdvancedExtension advanced_extension = 10 ; } Join Operation \u00b6 The join operation will combine two separate inputs into a single output, based on a join expression. A common subtype of joins is an equality join where the join expression is constrained to a list of equality (or equality + null equality) conditions between the two inputs of the join. Signature Value Inputs 2 Outputs 1 Property Maintenance Distribution is maintained. Orderedness is empty post operation. Physical relations may provide better property maintenance. Direct Output Order The emit order of the left input followed by the emit order of the right input. Join Properties \u00b6 Property Description Required Left Input A relational input. Required Right Input A relational input. Required Join Expression A boolean condition that describes whether each record from the left set \u201cmatch\u201d the record from the right set. Field references correspond to the direct output order of the data. Required. Can be the literal True. Join Type One of the join types defined below. Required Join Types \u00b6 Type Description Inner Return records from the left side only if they match the right side. Return records from the right side only when they match the left side. For each cross input match, return a record including the data from both sides. Non-matching records are ignored. Outer Return all records from both the left and right inputs. For each cross input match, return a record including the data from both sides. For any remaining non-match records, return the record from the corresponding input along with nulls for the opposite input. Left Return all records from the left input. For each cross input match, return a record including the data from both sides. For any remaining non-matching records from the left input, return the left record along with nulls for the right input. Right Return all records from the right input. For each cross input match, return a record including the data from both sides. For any remaining non-matching records from the right input, return the left record along with nulls for the right input. Semi Returns records from the left input. These are returned only if the records have a join partner on the right side. Anti Return records from the left input. These are returned only if the records do not have a join partner on the right side. Single Returns one join partner per entry on the left input. If more than one join partner exists, there are two valid semantics. 1) Only the first match is returned. 2) The system throws an error. If there is no match between the left and right inputs, NULL is returned. JoinRel Message message JoinRel { RelCommon common = 1 ; Rel left = 2 ; Rel right = 3 ; Expression expression = 4 ; Expression post_join_filter = 5 ; JoinType type = 6 ; enum JoinType { JOIN_TYPE_UNSPECIFIED = 0 ; JOIN_TYPE_INNER = 1 ; JOIN_TYPE_OUTER = 2 ; JOIN_TYPE_LEFT = 3 ; JOIN_TYPE_RIGHT = 4 ; JOIN_TYPE_SEMI = 5 ; JOIN_TYPE_ANTI = 6 ; // This join is useful for nested sub-queries where we need exactly one tuple in output (or throw exception) // See Section 3.2 of https://15721.courses.cs.cmu.edu/spring2018/papers/16-optimizer2/hyperjoins-btw2017.pdf JOIN_TYPE_SINGLE = 7 ; } substrait.extensions.AdvancedExtension advanced_extension = 10 ; } Set Operation \u00b6 The set operation encompasses several set-level operations that support combining datasets, possibly excluding records based on various types of record level matching. Signature Value Inputs 2 or more Outputs 1 Property Maintenance Maintains distribution if all inputs have the same ordinal distribution. Orderedness is not maintained. Direct Output Order The field order of the inputs. All inputs must have identical fields. Set Properties \u00b6 Property Description Required Primary Input The primary input of the dataset. Required Secondary Inputs One or more relational inputs. At least one required Set Operation Type From list below. Required Set Operation Types \u00b6 Property Description Minus (Primary) Returns the primary input excluding any matching records from secondary inputs. Minus (Multiset) Returns the primary input minus any records that are included in all sets. Intersection (Primary) Returns all rows primary rows that intersect at least one secondary input. Intersection (Multiset) Returns all rows that intersect at least one record from each secondary inputs. Union Distinct Returns all the records from each set, removing any rows that are duplicated (within or across sets). Union All Returns all records from each set, allowing duplicates. SetRel Message message SetRel { RelCommon common = 1 ; // The first input is the primary input, the remaining are secondary // inputs. There must be at least two inputs. repeated Rel inputs = 2 ; SetOp op = 3 ; substrait.extensions.AdvancedExtension advanced_extension = 10 ; enum SetOp { SET_OP_UNSPECIFIED = 0 ; SET_OP_MINUS_PRIMARY = 1 ; SET_OP_MINUS_MULTISET = 2 ; SET_OP_INTERSECTION_PRIMARY = 3 ; SET_OP_INTERSECTION_MULTISET = 4 ; SET_OP_UNION_DISTINCT = 5 ; SET_OP_UNION_ALL = 6 ; } } Fetch Operation \u00b6 The fetch operation eliminates records outside a desired window. Typically corresponds to a fetch/offset SQL clause. Will only returns records between the start offset and the end offset. Signature Value Inputs 1 Outputs 1 Property Maintenance Maintains distribution and orderedness. Direct Output Order Unchanged from input. Fetch Properties \u00b6 Property Description Required Input A relational input, typically with a desired orderedness property. Required Offset A positive integer. Declares the offset for retrieval of records. Optional, defaults to 0. Count A positive integer. Declares the number of records that should be returned. Required FetchRel Message message FetchRel { RelCommon common = 1 ; Rel input = 2 ; // the offset expressed in number of records int64 offset = 3 ; // the amount of records to return int64 count = 4 ; substrait.extensions.AdvancedExtension advanced_extension = 10 ; } Aggregate Operation \u00b6 The aggregate operation groups input data on one or more sets of grouping keys, calculating each measure for each combination of grouping key. Signature Value Inputs 1 Outputs 1 Property Maintenance Maintains distribution if all distribution fields are contained in every grouping set. No orderedness guaranteed. Direct Output Order The list of distinct columns from each grouping set (ordered by their first appearance) followed by the list of measures in declaration order, followed by an i32 describing the associated particular grouping set the value is derived from (if applicable). In its simplest form, an aggregation has only measures. In this case, all records are folded into one, and a column is returned for each aggregate expression in the measures list. Grouping sets can be used for finer-grained control over which records are folded. Within a grouping set, two records will be folded together if and only if each expressions in the grouping set yields the same value for each. The values returned by the grouping sets will be returned as columns to the left of the columns for the aggregate expressions. If a grouping set contains no grouping expressions, all rows will be folded for that grouping set. It\u2019s possible to specify multiple grouping sets in a single aggregate operation. The grouping sets behave more or less independently, with each returned record belonging to one of the grouping sets. The values for the grouping expression columns that are not part of the grouping set for a particular record will be set to null. Two grouping expressions will be returned using the same column if they represent the protobuf messages describing the expressions are equal. The columns for grouping expressions that do not appear in all grouping sets will be nullable (regardless of the nullability of the type returned by the grouping expression) to accomodate the null insertion. To further disambiguate which record belongs to which grouping set, an aggregate relation with more than one grouping set receives an extra i32 column on the right-hand side. The value of this field will be the zero-based index of the grouping set that yielded the record. If at least one grouping expression is present, the aggregation is allowed to not have any aggregate expressions. An aggregate relation is invalid if it would yield zero columns. Aggregate Properties \u00b6 Property Description Required Input The relational input. Required Grouping Sets One or more grouping sets. Optional, required if no measures. Per Grouping Set A list of expression grouping that the aggregation measured should be calculated for. Optional. Measures A list of one or more aggregate expressions along with an optional filter. Optional, required if no grouping sets. AggregateRel Message message AggregateRel { RelCommon common = 1 ; // Input of the aggregation Rel input = 2 ; // A list of expression grouping that the aggregation measured should be calculated for. repeated Grouping groupings = 3 ; // A list of one or more aggregate expressions along with an optional filter. repeated Measure measures = 4 ; substrait.extensions.AdvancedExtension advanced_extension = 10 ; message Grouping { repeated Expression grouping_expressions = 1 ; } message Measure { AggregateFunction measure = 1 ; // An optional boolean expression that acts to filter which records are // included in the measure. True means include this record for calculation // within the measure. // Helps to support SUM(<c>) FILTER(WHERE...) syntax without masking opportunities for optimization Expression filter = 2 ; } } Reference Operator \u00b6 The reference operator is used to construct DAGs of operations. In a Plan we can have multiple Rel representing various computations with potentially multiple outputs. The ReferenceRel is used to express the fact that multiple Rel might be sharing subtrees of computation. This can be used to express arbitrary DAGs as well as represent multi-query optimizations. As a concrete example think about two queries SELECT * FROM A JOIN B JOIN C and SELECT * FROM A JOIN B JOIN D , We could use the ReferenceRel to highlight the shared A JOIN B between the two queries, by creating a plan with 3 Rel . One expressing A JOIN B (in position 0 in the plan), one using reference as follows: ReferenceRel(0) JOIN C and a third one doing ReferenceRel(0) JOIN D . This allows to avoid the redundancy of A JOIN B . Signature Value Inputs 1 Outputs 1 Property Maintenance Maintains all properties of the input Direct Output Order Maintains order Reference Properties \u00b6 Property Description Required Referred Rel A zero-indexed positional reference to a Rel defined within the same Plan . Required ReferenceRel Message message ReferenceRel { int32 subtree_ordinal = 1 ; } Write Operator \u00b6 The write operator is an operator that consumes one output and writes it to storage. This can range from writing to a Parquet file, to INSERT/DELETE/UPDATE in a database. Signature Value Inputs 1 Outputs 1 Property Maintenance Output depends on OutputMode (none, or modified tuples) Direct Output Order Unchanged from input Write Properties \u00b6 Property Description Required Write Type Definition of which object we are operating on (e.g., a fully-qualified table name). Required CTAS Schema The names of all the columns and their type for a CREATE TABLE AS. Required only for CTAS Write Operator Which type of operation we are performing (INSERT/DELETE/UPDATE/CTAS). Required Rel Input The Rel representing which tuples we will be operating on (e.g., VALUES for an INSERT, or which tuples to DELETE, or tuples and after-image of their values for UPDATE). Required Output Mode For views that modify a DB it is important to control, which tuples to \u201creturn\u201d. Common default is NO_OUTPUT where we return nothing. Alternatively, we can return MODIFIED_TUPLES, that can be further manipulated by layering more rels ontop of this WriteRel (e.g., to \u201ccount how many tuples were updated\u201d). This also allows to return the after-image of the change. To return before-image (or both) one can use the reference mechanisms and have multiple return values. Required for VIEW CREATE/CREATE_OR_REPLACE/ALTER Write Definition Types \u00b6 Write definition types are built by the community and added to the specification. This is a portion of specification that is expected to grow rapidly. WriteRel Message message WriteRel { // Definition of which TABLE we are operating on oneof write_type { NamedObjectWrite named_table = 1 ; ExtensionObject extension_table = 2 ; } // The schema of the table (must align with Rel input (e.g., number of leaf fields must match)) NamedStruct table_schema = 3 ; // The type of operation to perform WriteOp op = 4 ; // The relation that determines the tuples to add/remove/modify // the schema must match with table_schema. Default values must be explicitly stated // in a ProjectRel at the top of the input. The match must also // occur in case of DELETE to ensure multi-engine plans are unequivocal. Rel input = 5 ; // Output mode determines what is the output of executing this rel OutputMode output = 6 ; enum WriteOp { WRITE_OP_UNSPECIFIED = 0 ; // The insert of new tuples in a table WRITE_OP_INSERT = 1 ; // The removal of tuples from a table WRITE_OP_DELETE = 2 ; // The modification of existing tuples within a table WRITE_OP_UPDATE = 3 ; // The Creation of a new table, and the insert of new tuples in the table WRITE_OP_CTAS = 4 ; } enum OutputMode { OUTPUT_MODE_UNSPECIFIED = 0 ; // return no tuples at all OUTPUT_MODE_NO_OUTPUT = 1 ; // this mode makes the operator return all the tuple INSERTED/DELETED/UPDATED by the operator. // The operator returns the AFTER-image of any change. This can be further manipulated by operators upstreams // (e.g., retunring the typical \"count of modified tuples\"). // For scenarios in which the BEFORE image is required, the user must implement a spool (via references to // subplans in the body of the Rel input) and return those with anounter PlanRel.relations. OUTPUT_MODE_MODIFIED_TUPLES = 2 ; } } Virtual Table \u00b6 Property Description Required Name The in-memory name to give the dataset. Required Pin Whether it is okay to remove this dataset from memory or it should be kept in memory. Optional, defaults to false. Files Type \u00b6 Property Description Required Path A URI to write the data to. Supports the inclusion of field references that are listed as available in properties as a \u201crotation description field\u201d. Required Format Enumeration of available formats. Only current option is PARQUET. Required DDL Operator \u00b6 The operator that defines modifications of a database schema (CREATE/DROP/ALTER for TABLE and VIEWS). Signature Value Inputs 1 Outputs 0 Property Maintenance N/A (no output) Direct Output Order N/A DDL Properties \u00b6 Property Description Required Write Type Definition of which type of object we are operating on. Required Table Schema The names of all the columns and their type. Required (except for DROP operations) Table Defaults The set of default values for this table. Required (except for DROP operations) DDL Object Which type of object we are operating on (e.g., TABLE or VIEW). Required DDL Operator The operation to be performed (e.g., CREATE/ALTER/DROP). Required View Definition A Rel representing the \u201cbody\u201d of a VIEW. Required for VIEW CREATE/CREATE_OR_REPLACE/ALTER DdlRel Message message DdlRel { // Definition of which type of object we are operating on oneof write_type { NamedObjectWrite named_object = 1 ; ExtensionObject extension_object = 2 ; } // The columns that will be modified (representing after-image of a schema change) NamedStruct table_schema = 3 ; // The default values for the columns (representing after-image of a schema change) // E.g., in case of an ALTER TABLE that changes some of the column default values, we expect // the table_defaults Struct to report a full list of default values reflecting the result of applying // the ALTER TABLE operator successfully Expression.Literal.Struct table_defaults = 4 ; // Which type of object we operate on DdlObject object = 5 ; // The type of operation to perform DdlOp op = 6 ; // The body of the CREATE VIEW Rel view_definition = 7 ; enum DdlObject { DDL_OBJECT_UNSPECIFIED = 0 ; // A Table object in the system DDL_OBJECT_TABLE = 1 ; // A View object in the system DDL_OBJECT_VIEW = 2 ; } enum DdlOp { DDL_OP_UNSPECIFIED = 0 ; // A create operation (for any object) DDL_OP_CREATE = 1 ; // A create operation if the object does not exist, or replaces it (equivalent to a DROP + CREATE) if the object already exists DDL_OP_CREATE_OR_REPLACE = 2 ; // An operation that modifies the schema (e.g., column names, types, default values) for the target object DDL_OP_ALTER = 3 ; // An operation that removes an object from the system DDL_OP_DROP = 4 ; // An operation that removes an object from the system (without throwing an exception if the object did not exist) DDL_OP_DROP_IF_EXIST = 5 ; } //TODO add PK/constraints/indexes/etc..? } Discussion Points \u00b6 How to handle correlated operations?","title":"Logical Relations"},{"location":"relations/logical_relations/#logical-relations","text":"","title":"Logical Relations"},{"location":"relations/logical_relations/#read-operator","text":"The read operator is an operator that produces one output. A simple example would be the reading of a Parquet file. It is expected that many types of reads will be added over time. Signature Value Inputs 0 Outputs 1 Property Maintenance N/A (no inputs) Direct Output Order Defaults to the schema of the data read after the optional projection (masked complex expression) is applied.","title":"Read Operator"},{"location":"relations/logical_relations/#read-properties","text":"Property Description Required Definition The contents of the read property definition. Required Direct Schema Defines the schema of the output of the read (before any projection or emit remapping/hiding). Required Filter A boolean Substrait expression that describes a filter that must be applied to the data. The filter should be interpreted against the direct schema. Optional, defaults to none. Best Effort Filter A boolean Substrait expression that describes a filter that may be applied to the data. The filter should be interpreted against the direct schema. Optional, defaults to none. Projection A masked complex expression describing the portions of the content that should be read Optional, defaults to all of schema Output Properties Declaration of orderedness and/or distribution properties this read produces. Optional, defaults to no properties. Properties A list of name/value pairs associated with the read. Optional, defaults to empty","title":"Read Properties"},{"location":"relations/logical_relations/#read-filtering","text":"The read relation has two different filter properties. A filter, which must be satisfied by the operator and a best effort filter, which does not have to be satisfied. This reflects the way that consumers are often implemented. A consumer is often only able to fully apply a limited set of operations in the scan. There can then be an extended set of operations which a consumer can apply in a best effort fashion. A producer, when setting these two fields, should take care to only use expressions that the consumer is capable of handling. As an example, a consumer may only be able to fully apply (in the read relation) <, =, and > on integral types. The consumer may be able to apply <, =, and > in a best effort fashion on decimal and string types. Consider the filter expression my_int < 10 && my_string < \"x\" && upper(my_string) > \"B\" . In this case the filter should be set to my_int < 10 and the best_effort_filter should be set to my_string < \"x\" and the remaining portion ( upper(my_string) > \"B\" ) should be put into a filter relation. A filter expression must be interpreted against the direct schema before the projection expression has been applied. As a result, fields may be referenced by the filter expression which are not included in the relation\u2019s output.","title":"Read Filtering"},{"location":"relations/logical_relations/#read-definition-types","text":"Read definition types are built by the community and added to the specification. This is a portion of specification that is expected to grow rapidly.","title":"Read Definition Types"},{"location":"relations/logical_relations/#virtual-table","text":"A virtual table is a table whose contents are embedded in the plan itself. The table data is encoded as records consisting of literal values. Property Description Required Data Required Required","title":"Virtual Table"},{"location":"relations/logical_relations/#named-table","text":"A named table is a reference to data defined elsewhere. For example, there may be a catalog of tables with unique names that both the producer and consumer agree on. This catalog would provide the consumer with more information on how to retrieve the data. Property Description Required Names A list of namespaced strings that, together, form the table name Required (at least one)","title":"Named Table"},{"location":"relations/logical_relations/#files-type","text":"Property Description Required Items An array of Items (path or path glob) associated with the read. Required Format per item Enumeration of available formats. Only current option is PARQUET. Required Slicing parameters per item Information to use when reading a slice of a file. Optional","title":"Files Type"},{"location":"relations/logical_relations/#slicing-files","text":"A read operation is allowed to only read part of a file. This is convenient, for example, when distributing a read operation across several nodes. The slicing parameters are specified as byte offsets into the file. Many file formats consist of indivisible \u201cchunks\u201d of data (e.g. Parquet row groups). If this happens the consumer can determine which slice a particular chunk belongs to. For example, one possible approach is that a chunk should only be read if the midpoint of the chunk (dividing by 2 and rounding down) is contained within the asked-for byte range. ReadRel Message message ReadRel { RelCommon common = 1 ; NamedStruct base_schema = 2 ; Expression filter = 3 ; Expression best_effort_filter = 11 ; Expression.MaskExpression projection = 4 ; substrait.extensions.AdvancedExtension advanced_extension = 10 ; // Definition of which type of scan operation is to be performed oneof read_type { VirtualTable virtual_table = 5 ; LocalFiles local_files = 6 ; NamedTable named_table = 7 ; ExtensionTable extension_table = 8 ; } // A base table. The list of string is used to represent namespacing (e.g., mydb.mytable). // This assumes shared catalog between systems exchanging a message. message NamedTable { repeated string names = 1 ; substrait.extensions.AdvancedExtension advanced_extension = 10 ; } // A table composed of literals. message VirtualTable { repeated Expression.Literal.Struct values = 1 ; } // A stub type that can be used to extend/introduce new table types outside // the specification. message ExtensionTable { google.protobuf.Any detail = 1 ; } // Represents a list of files in input of a scan operation message LocalFiles { repeated FileOrFiles items = 1 ; substrait.extensions.AdvancedExtension advanced_extension = 10 ; // Many files consist of indivisible chunks (e.g. parquet row groups // or CSV rows). If a slice partially selects an indivisible chunk // then the consumer should employ some rule to decide which slice to // include the chunk in (e.g. include it in the slice that contains // the midpoint of the chunk) message FileOrFiles { oneof path_type { // A URI that can refer to either a single folder or a single file string uri_path = 1 ; // A URI where the path portion is a glob expression that can // identify zero or more paths. // Consumers should support the POSIX syntax. The recursive // globstar (**) may not be supported. string uri_path_glob = 2 ; // A URI that refers to a single file string uri_file = 3 ; // A URI that refers to a single folder string uri_folder = 4 ; } // Original file format enum, superseded by the file_format oneof. reserved 5 ; reserved \"format\" ; // The index of the partition this item belongs to uint64 partition_index = 6 ; // The start position in byte to read from this item uint64 start = 7 ; // The length in byte to read from this item uint64 length = 8 ; message ParquetReadOptions {} message ArrowReadOptions {} message OrcReadOptions {} message DwrfReadOptions {} // The format of the files. oneof file_format { ParquetReadOptions parquet = 9 ; ArrowReadOptions arrow = 10 ; OrcReadOptions orc = 11 ; google.protobuf.Any extension = 12 ; DwrfReadOptions dwrf = 13 ; } } } }","title":"Slicing Files"},{"location":"relations/logical_relations/#filter-operation","text":"The filter operator eliminates one or more records from the input data based on a boolean filter expression. Signature Value Inputs 1 Outputs 1 Property Maintenance Orderedness, Distribution, remapped by emit Direct Output Order The field order as the input.","title":"Filter Operation"},{"location":"relations/logical_relations/#filter-properties","text":"Property Description Required Input The relational input. Required Expression A boolean expression which describes which records are included/excluded. Required FilterRel Message message FilterRel { RelCommon common = 1 ; Rel input = 2 ; Expression condition = 3 ; substrait.extensions.AdvancedExtension advanced_extension = 10 ; }","title":"Filter Properties"},{"location":"relations/logical_relations/#sort-operation","text":"The sort operator reorders a dataset based on one or more identified sort fields and a sorting function for each. Signature Value Inputs 1 Outputs 1 Property Maintenance Will update orderedness property to the output of the sort operation. Distribution property only remapped based on emit. Direct Output Order The field order of the input.","title":"Sort Operation"},{"location":"relations/logical_relations/#sort-properties","text":"Property Description Required Input The relational input. Required Sort Fields List of one or more fields to sort by. Uses the same properties as the orderedness property. One sort field required SortRel Message message SortRel { RelCommon common = 1 ; Rel input = 2 ; repeated SortField sorts = 3 ; substrait.extensions.AdvancedExtension advanced_extension = 10 ; }","title":"Sort Properties"},{"location":"relations/logical_relations/#project-operation","text":"The project operation will produce one or more additional expressions based on the inputs of the dataset. Signature Value Inputs 1 Outputs 1 Property Maintenance Distribution maintained, mapped by emit. Orderedness: Maintained if no window operations. Extended to include projection fields if fields are direct references. If window operations are present, no orderedness is maintained. Direct Output Order The field order of the input + the list of new expressions in the order they are declared in the expressions list.","title":"Project Operation"},{"location":"relations/logical_relations/#project-properties","text":"Property Description Required Input The relational input. Required Expressions List of one or more expressions to add to the input. At least one expression required ProjectRel Message message ProjectRel { RelCommon common = 1 ; Rel input = 2 ; repeated Expression expressions = 3 ; substrait.extensions.AdvancedExtension advanced_extension = 10 ; }","title":"Project Properties"},{"location":"relations/logical_relations/#cross-product-operation","text":"The cross product operation will combine two separate inputs into a single output. It pairs every record from the left input with every record of the right input. Signature Value Inputs 2 Outputs 1 Property Maintenance Distribution is maintained. Orderedness is empty post operation. Direct Output Order The emit order of the left input followed by the emit order of the right input.","title":"Cross Product Operation"},{"location":"relations/logical_relations/#cross-product-properties","text":"Property Description Required Left Input A relational input. Required Right Input A relational input. Required CrossRel Message message CrossRel { RelCommon common = 1 ; Rel left = 2 ; Rel right = 3 ; substrait.extensions.AdvancedExtension advanced_extension = 10 ; }","title":"Cross Product Properties"},{"location":"relations/logical_relations/#join-operation","text":"The join operation will combine two separate inputs into a single output, based on a join expression. A common subtype of joins is an equality join where the join expression is constrained to a list of equality (or equality + null equality) conditions between the two inputs of the join. Signature Value Inputs 2 Outputs 1 Property Maintenance Distribution is maintained. Orderedness is empty post operation. Physical relations may provide better property maintenance. Direct Output Order The emit order of the left input followed by the emit order of the right input.","title":"Join Operation"},{"location":"relations/logical_relations/#join-properties","text":"Property Description Required Left Input A relational input. Required Right Input A relational input. Required Join Expression A boolean condition that describes whether each record from the left set \u201cmatch\u201d the record from the right set. Field references correspond to the direct output order of the data. Required. Can be the literal True. Join Type One of the join types defined below. Required","title":"Join Properties"},{"location":"relations/logical_relations/#join-types","text":"Type Description Inner Return records from the left side only if they match the right side. Return records from the right side only when they match the left side. For each cross input match, return a record including the data from both sides. Non-matching records are ignored. Outer Return all records from both the left and right inputs. For each cross input match, return a record including the data from both sides. For any remaining non-match records, return the record from the corresponding input along with nulls for the opposite input. Left Return all records from the left input. For each cross input match, return a record including the data from both sides. For any remaining non-matching records from the left input, return the left record along with nulls for the right input. Right Return all records from the right input. For each cross input match, return a record including the data from both sides. For any remaining non-matching records from the right input, return the left record along with nulls for the right input. Semi Returns records from the left input. These are returned only if the records have a join partner on the right side. Anti Return records from the left input. These are returned only if the records do not have a join partner on the right side. Single Returns one join partner per entry on the left input. If more than one join partner exists, there are two valid semantics. 1) Only the first match is returned. 2) The system throws an error. If there is no match between the left and right inputs, NULL is returned. JoinRel Message message JoinRel { RelCommon common = 1 ; Rel left = 2 ; Rel right = 3 ; Expression expression = 4 ; Expression post_join_filter = 5 ; JoinType type = 6 ; enum JoinType { JOIN_TYPE_UNSPECIFIED = 0 ; JOIN_TYPE_INNER = 1 ; JOIN_TYPE_OUTER = 2 ; JOIN_TYPE_LEFT = 3 ; JOIN_TYPE_RIGHT = 4 ; JOIN_TYPE_SEMI = 5 ; JOIN_TYPE_ANTI = 6 ; // This join is useful for nested sub-queries where we need exactly one tuple in output (or throw exception) // See Section 3.2 of https://15721.courses.cs.cmu.edu/spring2018/papers/16-optimizer2/hyperjoins-btw2017.pdf JOIN_TYPE_SINGLE = 7 ; } substrait.extensions.AdvancedExtension advanced_extension = 10 ; }","title":"Join Types"},{"location":"relations/logical_relations/#set-operation","text":"The set operation encompasses several set-level operations that support combining datasets, possibly excluding records based on various types of record level matching. Signature Value Inputs 2 or more Outputs 1 Property Maintenance Maintains distribution if all inputs have the same ordinal distribution. Orderedness is not maintained. Direct Output Order The field order of the inputs. All inputs must have identical fields.","title":"Set Operation"},{"location":"relations/logical_relations/#set-properties","text":"Property Description Required Primary Input The primary input of the dataset. Required Secondary Inputs One or more relational inputs. At least one required Set Operation Type From list below. Required","title":"Set Properties"},{"location":"relations/logical_relations/#set-operation-types","text":"Property Description Minus (Primary) Returns the primary input excluding any matching records from secondary inputs. Minus (Multiset) Returns the primary input minus any records that are included in all sets. Intersection (Primary) Returns all rows primary rows that intersect at least one secondary input. Intersection (Multiset) Returns all rows that intersect at least one record from each secondary inputs. Union Distinct Returns all the records from each set, removing any rows that are duplicated (within or across sets). Union All Returns all records from each set, allowing duplicates. SetRel Message message SetRel { RelCommon common = 1 ; // The first input is the primary input, the remaining are secondary // inputs. There must be at least two inputs. repeated Rel inputs = 2 ; SetOp op = 3 ; substrait.extensions.AdvancedExtension advanced_extension = 10 ; enum SetOp { SET_OP_UNSPECIFIED = 0 ; SET_OP_MINUS_PRIMARY = 1 ; SET_OP_MINUS_MULTISET = 2 ; SET_OP_INTERSECTION_PRIMARY = 3 ; SET_OP_INTERSECTION_MULTISET = 4 ; SET_OP_UNION_DISTINCT = 5 ; SET_OP_UNION_ALL = 6 ; } }","title":"Set Operation Types"},{"location":"relations/logical_relations/#fetch-operation","text":"The fetch operation eliminates records outside a desired window. Typically corresponds to a fetch/offset SQL clause. Will only returns records between the start offset and the end offset. Signature Value Inputs 1 Outputs 1 Property Maintenance Maintains distribution and orderedness. Direct Output Order Unchanged from input.","title":"Fetch Operation"},{"location":"relations/logical_relations/#fetch-properties","text":"Property Description Required Input A relational input, typically with a desired orderedness property. Required Offset A positive integer. Declares the offset for retrieval of records. Optional, defaults to 0. Count A positive integer. Declares the number of records that should be returned. Required FetchRel Message message FetchRel { RelCommon common = 1 ; Rel input = 2 ; // the offset expressed in number of records int64 offset = 3 ; // the amount of records to return int64 count = 4 ; substrait.extensions.AdvancedExtension advanced_extension = 10 ; }","title":"Fetch Properties"},{"location":"relations/logical_relations/#aggregate-operation","text":"The aggregate operation groups input data on one or more sets of grouping keys, calculating each measure for each combination of grouping key. Signature Value Inputs 1 Outputs 1 Property Maintenance Maintains distribution if all distribution fields are contained in every grouping set. No orderedness guaranteed. Direct Output Order The list of distinct columns from each grouping set (ordered by their first appearance) followed by the list of measures in declaration order, followed by an i32 describing the associated particular grouping set the value is derived from (if applicable). In its simplest form, an aggregation has only measures. In this case, all records are folded into one, and a column is returned for each aggregate expression in the measures list. Grouping sets can be used for finer-grained control over which records are folded. Within a grouping set, two records will be folded together if and only if each expressions in the grouping set yields the same value for each. The values returned by the grouping sets will be returned as columns to the left of the columns for the aggregate expressions. If a grouping set contains no grouping expressions, all rows will be folded for that grouping set. It\u2019s possible to specify multiple grouping sets in a single aggregate operation. The grouping sets behave more or less independently, with each returned record belonging to one of the grouping sets. The values for the grouping expression columns that are not part of the grouping set for a particular record will be set to null. Two grouping expressions will be returned using the same column if they represent the protobuf messages describing the expressions are equal. The columns for grouping expressions that do not appear in all grouping sets will be nullable (regardless of the nullability of the type returned by the grouping expression) to accomodate the null insertion. To further disambiguate which record belongs to which grouping set, an aggregate relation with more than one grouping set receives an extra i32 column on the right-hand side. The value of this field will be the zero-based index of the grouping set that yielded the record. If at least one grouping expression is present, the aggregation is allowed to not have any aggregate expressions. An aggregate relation is invalid if it would yield zero columns.","title":"Aggregate Operation"},{"location":"relations/logical_relations/#aggregate-properties","text":"Property Description Required Input The relational input. Required Grouping Sets One or more grouping sets. Optional, required if no measures. Per Grouping Set A list of expression grouping that the aggregation measured should be calculated for. Optional. Measures A list of one or more aggregate expressions along with an optional filter. Optional, required if no grouping sets. AggregateRel Message message AggregateRel { RelCommon common = 1 ; // Input of the aggregation Rel input = 2 ; // A list of expression grouping that the aggregation measured should be calculated for. repeated Grouping groupings = 3 ; // A list of one or more aggregate expressions along with an optional filter. repeated Measure measures = 4 ; substrait.extensions.AdvancedExtension advanced_extension = 10 ; message Grouping { repeated Expression grouping_expressions = 1 ; } message Measure { AggregateFunction measure = 1 ; // An optional boolean expression that acts to filter which records are // included in the measure. True means include this record for calculation // within the measure. // Helps to support SUM(<c>) FILTER(WHERE...) syntax without masking opportunities for optimization Expression filter = 2 ; } }","title":"Aggregate Properties"},{"location":"relations/logical_relations/#reference-operator","text":"The reference operator is used to construct DAGs of operations. In a Plan we can have multiple Rel representing various computations with potentially multiple outputs. The ReferenceRel is used to express the fact that multiple Rel might be sharing subtrees of computation. This can be used to express arbitrary DAGs as well as represent multi-query optimizations. As a concrete example think about two queries SELECT * FROM A JOIN B JOIN C and SELECT * FROM A JOIN B JOIN D , We could use the ReferenceRel to highlight the shared A JOIN B between the two queries, by creating a plan with 3 Rel . One expressing A JOIN B (in position 0 in the plan), one using reference as follows: ReferenceRel(0) JOIN C and a third one doing ReferenceRel(0) JOIN D . This allows to avoid the redundancy of A JOIN B . Signature Value Inputs 1 Outputs 1 Property Maintenance Maintains all properties of the input Direct Output Order Maintains order","title":"Reference Operator"},{"location":"relations/logical_relations/#reference-properties","text":"Property Description Required Referred Rel A zero-indexed positional reference to a Rel defined within the same Plan . Required ReferenceRel Message message ReferenceRel { int32 subtree_ordinal = 1 ; }","title":"Reference Properties"},{"location":"relations/logical_relations/#write-operator","text":"The write operator is an operator that consumes one output and writes it to storage. This can range from writing to a Parquet file, to INSERT/DELETE/UPDATE in a database. Signature Value Inputs 1 Outputs 1 Property Maintenance Output depends on OutputMode (none, or modified tuples) Direct Output Order Unchanged from input","title":"Write Operator"},{"location":"relations/logical_relations/#write-properties","text":"Property Description Required Write Type Definition of which object we are operating on (e.g., a fully-qualified table name). Required CTAS Schema The names of all the columns and their type for a CREATE TABLE AS. Required only for CTAS Write Operator Which type of operation we are performing (INSERT/DELETE/UPDATE/CTAS). Required Rel Input The Rel representing which tuples we will be operating on (e.g., VALUES for an INSERT, or which tuples to DELETE, or tuples and after-image of their values for UPDATE). Required Output Mode For views that modify a DB it is important to control, which tuples to \u201creturn\u201d. Common default is NO_OUTPUT where we return nothing. Alternatively, we can return MODIFIED_TUPLES, that can be further manipulated by layering more rels ontop of this WriteRel (e.g., to \u201ccount how many tuples were updated\u201d). This also allows to return the after-image of the change. To return before-image (or both) one can use the reference mechanisms and have multiple return values. Required for VIEW CREATE/CREATE_OR_REPLACE/ALTER","title":"Write Properties"},{"location":"relations/logical_relations/#write-definition-types","text":"Write definition types are built by the community and added to the specification. This is a portion of specification that is expected to grow rapidly. WriteRel Message message WriteRel { // Definition of which TABLE we are operating on oneof write_type { NamedObjectWrite named_table = 1 ; ExtensionObject extension_table = 2 ; } // The schema of the table (must align with Rel input (e.g., number of leaf fields must match)) NamedStruct table_schema = 3 ; // The type of operation to perform WriteOp op = 4 ; // The relation that determines the tuples to add/remove/modify // the schema must match with table_schema. Default values must be explicitly stated // in a ProjectRel at the top of the input. The match must also // occur in case of DELETE to ensure multi-engine plans are unequivocal. Rel input = 5 ; // Output mode determines what is the output of executing this rel OutputMode output = 6 ; enum WriteOp { WRITE_OP_UNSPECIFIED = 0 ; // The insert of new tuples in a table WRITE_OP_INSERT = 1 ; // The removal of tuples from a table WRITE_OP_DELETE = 2 ; // The modification of existing tuples within a table WRITE_OP_UPDATE = 3 ; // The Creation of a new table, and the insert of new tuples in the table WRITE_OP_CTAS = 4 ; } enum OutputMode { OUTPUT_MODE_UNSPECIFIED = 0 ; // return no tuples at all OUTPUT_MODE_NO_OUTPUT = 1 ; // this mode makes the operator return all the tuple INSERTED/DELETED/UPDATED by the operator. // The operator returns the AFTER-image of any change. This can be further manipulated by operators upstreams // (e.g., retunring the typical \"count of modified tuples\"). // For scenarios in which the BEFORE image is required, the user must implement a spool (via references to // subplans in the body of the Rel input) and return those with anounter PlanRel.relations. OUTPUT_MODE_MODIFIED_TUPLES = 2 ; } }","title":"Write Definition Types"},{"location":"relations/logical_relations/#virtual-table_1","text":"Property Description Required Name The in-memory name to give the dataset. Required Pin Whether it is okay to remove this dataset from memory or it should be kept in memory. Optional, defaults to false.","title":"Virtual Table"},{"location":"relations/logical_relations/#files-type_1","text":"Property Description Required Path A URI to write the data to. Supports the inclusion of field references that are listed as available in properties as a \u201crotation description field\u201d. Required Format Enumeration of available formats. Only current option is PARQUET. Required","title":"Files Type"},{"location":"relations/logical_relations/#ddl-operator","text":"The operator that defines modifications of a database schema (CREATE/DROP/ALTER for TABLE and VIEWS). Signature Value Inputs 1 Outputs 0 Property Maintenance N/A (no output) Direct Output Order N/A","title":"DDL Operator"},{"location":"relations/logical_relations/#ddl-properties","text":"Property Description Required Write Type Definition of which type of object we are operating on. Required Table Schema The names of all the columns and their type. Required (except for DROP operations) Table Defaults The set of default values for this table. Required (except for DROP operations) DDL Object Which type of object we are operating on (e.g., TABLE or VIEW). Required DDL Operator The operation to be performed (e.g., CREATE/ALTER/DROP). Required View Definition A Rel representing the \u201cbody\u201d of a VIEW. Required for VIEW CREATE/CREATE_OR_REPLACE/ALTER DdlRel Message message DdlRel { // Definition of which type of object we are operating on oneof write_type { NamedObjectWrite named_object = 1 ; ExtensionObject extension_object = 2 ; } // The columns that will be modified (representing after-image of a schema change) NamedStruct table_schema = 3 ; // The default values for the columns (representing after-image of a schema change) // E.g., in case of an ALTER TABLE that changes some of the column default values, we expect // the table_defaults Struct to report a full list of default values reflecting the result of applying // the ALTER TABLE operator successfully Expression.Literal.Struct table_defaults = 4 ; // Which type of object we operate on DdlObject object = 5 ; // The type of operation to perform DdlOp op = 6 ; // The body of the CREATE VIEW Rel view_definition = 7 ; enum DdlObject { DDL_OBJECT_UNSPECIFIED = 0 ; // A Table object in the system DDL_OBJECT_TABLE = 1 ; // A View object in the system DDL_OBJECT_VIEW = 2 ; } enum DdlOp { DDL_OP_UNSPECIFIED = 0 ; // A create operation (for any object) DDL_OP_CREATE = 1 ; // A create operation if the object does not exist, or replaces it (equivalent to a DROP + CREATE) if the object already exists DDL_OP_CREATE_OR_REPLACE = 2 ; // An operation that modifies the schema (e.g., column names, types, default values) for the target object DDL_OP_ALTER = 3 ; // An operation that removes an object from the system DDL_OP_DROP = 4 ; // An operation that removes an object from the system (without throwing an exception if the object did not exist) DDL_OP_DROP_IF_EXIST = 5 ; } //TODO add PK/constraints/indexes/etc..? }","title":"DDL Properties"},{"location":"relations/logical_relations/#discussion-points","text":"How to handle correlated operations?","title":"Discussion Points"},{"location":"relations/physical_relations/","text":"Physical Relations \u00b6 There is no true distinction between logical and physical operations in Substrait. By convention, certain operations are classified as physical, but all operations can be potentially used in any kind of plan. A particular set of transformations or target operators may (by convention) be considered the \u201cphysical plan\u201d but this is a characteristic of the system consuming substrait as opposed to a definition within Substrait. Hash Equijoin Operator \u00b6 The hash equijoin join operator will build a hash table out of the right input based on a set of join keys. It will then probe that hash table for incoming inputs, finding matches. Signature Value Inputs 2 Outputs 1 Property Maintenance Distribution is maintained. Orderedness of the left set is maintained in INNER join cases, otherwise it is eliminated. Direct Output Order Same as the Join operator. Hash Equijoin Properties \u00b6 Property Description Required Left Input A relational input.(Probe-side) Required Right Input A relational input.(Build-side) Required Left Keys References to the fields to join on in the left input. Required Right Keys References to the fields to join on in the right input. Required Post Join Predicate An additional expression that can be used to reduce the output of the join operation post the equality condition. Minimizes the overhead of secondary join conditions that cannot be evaluated using the equijoin keys. Optional, defaults true. Join Type One of the join types defined in the Join operator. Required NLJ Operator \u00b6 The nested loop join operator does a join by holding the entire right input and then iterating over it using the left input, evaluating the join expression on the Cartesian product of all rows, only outputting rows where the expression is true. Will also include non-matching rows in the OUTER, LEFT and RIGHT operations per the join type requirements. Signature Value Inputs 2 Outputs 1 Property Maintenance Distribution is maintained. Orderedness is eliminated. Direct Output Order Same as the Join operator. NLJ Properties \u00b6 Property Description Required Left Input A relational input. Required Right Input A relational input. Required Join Expression A boolean condition that describes whether each record from the left set \u201cmatch\u201d the record from the right set. Optional. Defaults to true (a Cartesian join). Join Type One of the join types defined in the Join operator. Required Merge Equijoin Operator \u00b6 The merge equijoin does a join by taking advantage of two sets that are sorted on the join keys. This allows the join operation to be done in a streaming fashion. Signature Value Inputs 2 Outputs 1 Property Maintenance Distribution is maintained. Orderedness is eliminated. Direct Output Order Same as the Join operator. Merge Join Properties \u00b6 Property Description Required Left Input A relational input. Required Right Input A relational input. Required Left Keys References to the fields to join on in the left input. Required Right Keys References to the fields to join on in the right input. Reauired Post Join Predicate An additional expression that can be used to reduce the output of the join operation post the equality condition. Minimizes the overhead of secondary join conditions that cannot be evaluated using the equijoin keys. Optional, defaults true. Join Type One of the join types defined in the Join operator. Required Exchange Operator \u00b6 The exchange operator will redistribute data based on an exchange type definition. Applying this operation will lead to an output that presents the desired distribution. Signature Value Inputs 1 Outputs 1 Property Maintenance Orderedness is maintained. Distribution is overwritten based on configuration. Direct Output Order Order of the input. Exchange Types \u00b6 Type Description Scatter Distribute data using a system defined hashing function that considers one or more fields. For the same type of fields and same ordering of values, the same partition target should be identified for different ExchangeRels Single Bucket Define an expression that provides a single i32 bucket number. Optionally define whether the expression will only return values within the valid number of partition counts. If not, the system should modulo the return value to determine a target partition. Multi Bucket Define an expression that provides a List<i32> of bucket numbers. Optionally define whether the expression will only return values within the valid number of partition counts. If not, the system should modulo the return value to determine a target partition. The records should be sent to all bucket numbers provided by the expression. Broadcast Send all records to all partitions. Round Robin Send records to each target in sequence. Can follow either exact or approximate behavior. Approximate will attempt to balance the number of records sent to each destination but may not exactly distribute evenly and may send batches of records to each target before moving to the next. Exchange Properties \u00b6 Property Description Required Input The relational input. Required. Distribution Type One of the distribution types defined above. Required. Partition Count The number of partitions targeted for output. Optional. If not defined, implementation system should decide the number of partitions. Note that when not defined, single or multi bucket expressions should not be constrained to count. Expression Mapping Describes a relationship between each partition ID and the destination that partition should be sent to. Optional. A partition may be sent to 0..N locations. Value can either be a URI or arbitrary value. Merging Capture \u00b6 A receiving operation that will merge multiple ordered streams to maintain orderedness. Signature Value Inputs 1 Outputs 1 Property Maintenance Orderedness and distribution are maintained. Direct Output Order Order of the input. Merging Capture Properties \u00b6 Property Description Required Blocking Whether the merging should block incoming data. Blocking should be used carefully, based on whether a deadlock can be produced. Optional, defaults to false Simple Capture \u00b6 A receiving operation that will merge multiple streams in an arbitrary order. Signature Value Inputs 1 Outputs 1 Property Maintenance Orderness is empty after this operation. Distribution are maintained. Direct Output Order Order of the input. Naive Capture Properties \u00b6 Property Description Required Input The relational input. Required Top-N Operation \u00b6 The top-N operator reorders a dataset based on one or more identified sort fields as well as a sorting function. Rather than sort the entire dataset, the top-N will only maintain the total number of records required to ensure a limited output. A top-n is a combination of a logical sort and logical fetch operations. Signature Value Inputs 1 Outputs 1 Property Maintenance Will update orderedness property to the output of the sort operation. Distribution property only remapped based on emit. Direct Output Order The field order of the input. Top-N Properties \u00b6 Property Description Required Input The relational input. Required Sort Fields List of one or more fields to sort by. Uses the same properties as the orderedness property. One sort field required Offset A positive integer. Declares the offset for retrieval of records. Optional, defaults to 0. Count A positive integer. Declares the number of records that should be returned. Required Hash Aggregate Operation \u00b6 The hash aggregate operation maintains a hash table for each grouping set to coalesce equivalent tuples. Signature Value Inputs 1 Outputs 1 Property Maintenance Maintains distribution if all distribution fields are contained in every grouping set. No orderness guaranteed. Direct Output Order Same as defined by Aggregate operation. Hash Aggregate Properties \u00b6 Property Description Required Input The relational input. Required Grouping Sets One or more grouping sets. Optional, required if no measures. Per Grouping Set A list of expression grouping that the aggregation measured should be calculated for. Optional, defaults to 0. Measures A list of one or more aggregate expressions. Implementations may or may not support aggregate ordering expressions. Optional, required if no grouping sets. Streaming Aggregate Operation \u00b6 The streaming aggregate operation leverages data ordered by the grouping expressions to calculate data each grouping set tuple-by-tuple in streaming fashion. All grouping sets and orderings requested on each aggregate must be compatible to allow multiple grouping sets or aggregate orderings. Signature Value Inputs 1 Outputs 1 Property Maintenance Maintains distribution if all distribution fields are contained in every grouping set. Maintains input ordering. Direct Output Order Same as defined by Aggregate operation. Streaming Aggregate Properties \u00b6 Property Description Required Input The relational input. Required Grouping Sets One or more grouping sets. If multiple grouping sets are declared, sets must all be compatible with the input sortedness. Optional, required if no measures. Per Grouping Set A list of expression grouping that the aggregation measured should be calculated for. Optional, defaults to 0. Measures A list of one or more aggregate expressions. Aggregate expressions ordering requirements must be compatible with expected ordering. Optional, required if no grouping sets. Hashing Window Operation \u00b6 A window aggregate operation that will build hash tables for each distinct partition expression. Signature Value Inputs 1 Outputs 1 Property Maintenance Maintains distribution. Eliminates ordering. Direct Output Order Same as Project operator (input followed by each window expression). Hashing Window Properties \u00b6 Property Description Required Input The relational input. Required Window Expressions One or more window expressions. At least one required. Streaming Window Operation \u00b6 A window aggregate operation that relies on a partition/ordering sorted input. Signature Value Inputs 1 Outputs 1 Property Maintenance Maintains distribution. Eliminates ordering. Direct Output Order Same as Project operator (input followed by each window expression). Streaming Window Properties \u00b6 Property Description Required Input The relational input. Required Window Expressions One or more window expressions. Must be supported by the sortedness of the input. At least one required.","title":"Physical Relations"},{"location":"relations/physical_relations/#physical-relations","text":"There is no true distinction between logical and physical operations in Substrait. By convention, certain operations are classified as physical, but all operations can be potentially used in any kind of plan. A particular set of transformations or target operators may (by convention) be considered the \u201cphysical plan\u201d but this is a characteristic of the system consuming substrait as opposed to a definition within Substrait.","title":"Physical Relations"},{"location":"relations/physical_relations/#hash-equijoin-operator","text":"The hash equijoin join operator will build a hash table out of the right input based on a set of join keys. It will then probe that hash table for incoming inputs, finding matches. Signature Value Inputs 2 Outputs 1 Property Maintenance Distribution is maintained. Orderedness of the left set is maintained in INNER join cases, otherwise it is eliminated. Direct Output Order Same as the Join operator.","title":"Hash Equijoin Operator"},{"location":"relations/physical_relations/#hash-equijoin-properties","text":"Property Description Required Left Input A relational input.(Probe-side) Required Right Input A relational input.(Build-side) Required Left Keys References to the fields to join on in the left input. Required Right Keys References to the fields to join on in the right input. Required Post Join Predicate An additional expression that can be used to reduce the output of the join operation post the equality condition. Minimizes the overhead of secondary join conditions that cannot be evaluated using the equijoin keys. Optional, defaults true. Join Type One of the join types defined in the Join operator. Required","title":"Hash Equijoin Properties"},{"location":"relations/physical_relations/#nlj-operator","text":"The nested loop join operator does a join by holding the entire right input and then iterating over it using the left input, evaluating the join expression on the Cartesian product of all rows, only outputting rows where the expression is true. Will also include non-matching rows in the OUTER, LEFT and RIGHT operations per the join type requirements. Signature Value Inputs 2 Outputs 1 Property Maintenance Distribution is maintained. Orderedness is eliminated. Direct Output Order Same as the Join operator.","title":"NLJ Operator"},{"location":"relations/physical_relations/#nlj-properties","text":"Property Description Required Left Input A relational input. Required Right Input A relational input. Required Join Expression A boolean condition that describes whether each record from the left set \u201cmatch\u201d the record from the right set. Optional. Defaults to true (a Cartesian join). Join Type One of the join types defined in the Join operator. Required","title":"NLJ Properties"},{"location":"relations/physical_relations/#merge-equijoin-operator","text":"The merge equijoin does a join by taking advantage of two sets that are sorted on the join keys. This allows the join operation to be done in a streaming fashion. Signature Value Inputs 2 Outputs 1 Property Maintenance Distribution is maintained. Orderedness is eliminated. Direct Output Order Same as the Join operator.","title":"Merge Equijoin Operator"},{"location":"relations/physical_relations/#merge-join-properties","text":"Property Description Required Left Input A relational input. Required Right Input A relational input. Required Left Keys References to the fields to join on in the left input. Required Right Keys References to the fields to join on in the right input. Reauired Post Join Predicate An additional expression that can be used to reduce the output of the join operation post the equality condition. Minimizes the overhead of secondary join conditions that cannot be evaluated using the equijoin keys. Optional, defaults true. Join Type One of the join types defined in the Join operator. Required","title":"Merge Join Properties"},{"location":"relations/physical_relations/#exchange-operator","text":"The exchange operator will redistribute data based on an exchange type definition. Applying this operation will lead to an output that presents the desired distribution. Signature Value Inputs 1 Outputs 1 Property Maintenance Orderedness is maintained. Distribution is overwritten based on configuration. Direct Output Order Order of the input.","title":"Exchange Operator"},{"location":"relations/physical_relations/#exchange-types","text":"Type Description Scatter Distribute data using a system defined hashing function that considers one or more fields. For the same type of fields and same ordering of values, the same partition target should be identified for different ExchangeRels Single Bucket Define an expression that provides a single i32 bucket number. Optionally define whether the expression will only return values within the valid number of partition counts. If not, the system should modulo the return value to determine a target partition. Multi Bucket Define an expression that provides a List<i32> of bucket numbers. Optionally define whether the expression will only return values within the valid number of partition counts. If not, the system should modulo the return value to determine a target partition. The records should be sent to all bucket numbers provided by the expression. Broadcast Send all records to all partitions. Round Robin Send records to each target in sequence. Can follow either exact or approximate behavior. Approximate will attempt to balance the number of records sent to each destination but may not exactly distribute evenly and may send batches of records to each target before moving to the next.","title":"Exchange Types"},{"location":"relations/physical_relations/#exchange-properties","text":"Property Description Required Input The relational input. Required. Distribution Type One of the distribution types defined above. Required. Partition Count The number of partitions targeted for output. Optional. If not defined, implementation system should decide the number of partitions. Note that when not defined, single or multi bucket expressions should not be constrained to count. Expression Mapping Describes a relationship between each partition ID and the destination that partition should be sent to. Optional. A partition may be sent to 0..N locations. Value can either be a URI or arbitrary value.","title":"Exchange Properties"},{"location":"relations/physical_relations/#merging-capture","text":"A receiving operation that will merge multiple ordered streams to maintain orderedness. Signature Value Inputs 1 Outputs 1 Property Maintenance Orderedness and distribution are maintained. Direct Output Order Order of the input.","title":"Merging Capture"},{"location":"relations/physical_relations/#merging-capture-properties","text":"Property Description Required Blocking Whether the merging should block incoming data. Blocking should be used carefully, based on whether a deadlock can be produced. Optional, defaults to false","title":"Merging Capture Properties"},{"location":"relations/physical_relations/#simple-capture","text":"A receiving operation that will merge multiple streams in an arbitrary order. Signature Value Inputs 1 Outputs 1 Property Maintenance Orderness is empty after this operation. Distribution are maintained. Direct Output Order Order of the input.","title":"Simple Capture"},{"location":"relations/physical_relations/#naive-capture-properties","text":"Property Description Required Input The relational input. Required","title":"Naive Capture Properties"},{"location":"relations/physical_relations/#top-n-operation","text":"The top-N operator reorders a dataset based on one or more identified sort fields as well as a sorting function. Rather than sort the entire dataset, the top-N will only maintain the total number of records required to ensure a limited output. A top-n is a combination of a logical sort and logical fetch operations. Signature Value Inputs 1 Outputs 1 Property Maintenance Will update orderedness property to the output of the sort operation. Distribution property only remapped based on emit. Direct Output Order The field order of the input.","title":"Top-N Operation"},{"location":"relations/physical_relations/#top-n-properties","text":"Property Description Required Input The relational input. Required Sort Fields List of one or more fields to sort by. Uses the same properties as the orderedness property. One sort field required Offset A positive integer. Declares the offset for retrieval of records. Optional, defaults to 0. Count A positive integer. Declares the number of records that should be returned. Required","title":"Top-N Properties"},{"location":"relations/physical_relations/#hash-aggregate-operation","text":"The hash aggregate operation maintains a hash table for each grouping set to coalesce equivalent tuples. Signature Value Inputs 1 Outputs 1 Property Maintenance Maintains distribution if all distribution fields are contained in every grouping set. No orderness guaranteed. Direct Output Order Same as defined by Aggregate operation.","title":"Hash Aggregate Operation"},{"location":"relations/physical_relations/#hash-aggregate-properties","text":"Property Description Required Input The relational input. Required Grouping Sets One or more grouping sets. Optional, required if no measures. Per Grouping Set A list of expression grouping that the aggregation measured should be calculated for. Optional, defaults to 0. Measures A list of one or more aggregate expressions. Implementations may or may not support aggregate ordering expressions. Optional, required if no grouping sets.","title":"Hash Aggregate Properties"},{"location":"relations/physical_relations/#streaming-aggregate-operation","text":"The streaming aggregate operation leverages data ordered by the grouping expressions to calculate data each grouping set tuple-by-tuple in streaming fashion. All grouping sets and orderings requested on each aggregate must be compatible to allow multiple grouping sets or aggregate orderings. Signature Value Inputs 1 Outputs 1 Property Maintenance Maintains distribution if all distribution fields are contained in every grouping set. Maintains input ordering. Direct Output Order Same as defined by Aggregate operation.","title":"Streaming Aggregate Operation"},{"location":"relations/physical_relations/#streaming-aggregate-properties","text":"Property Description Required Input The relational input. Required Grouping Sets One or more grouping sets. If multiple grouping sets are declared, sets must all be compatible with the input sortedness. Optional, required if no measures. Per Grouping Set A list of expression grouping that the aggregation measured should be calculated for. Optional, defaults to 0. Measures A list of one or more aggregate expressions. Aggregate expressions ordering requirements must be compatible with expected ordering. Optional, required if no grouping sets.","title":"Streaming Aggregate Properties"},{"location":"relations/physical_relations/#hashing-window-operation","text":"A window aggregate operation that will build hash tables for each distinct partition expression. Signature Value Inputs 1 Outputs 1 Property Maintenance Maintains distribution. Eliminates ordering. Direct Output Order Same as Project operator (input followed by each window expression).","title":"Hashing Window Operation"},{"location":"relations/physical_relations/#hashing-window-properties","text":"Property Description Required Input The relational input. Required Window Expressions One or more window expressions. At least one required.","title":"Hashing Window Properties"},{"location":"relations/physical_relations/#streaming-window-operation","text":"A window aggregate operation that relies on a partition/ordering sorted input. Signature Value Inputs 1 Outputs 1 Property Maintenance Maintains distribution. Eliminates ordering. Direct Output Order Same as Project operator (input followed by each window expression).","title":"Streaming Window Operation"},{"location":"relations/physical_relations/#streaming-window-properties","text":"Property Description Required Input The relational input. Required Window Expressions One or more window expressions. Must be supported by the sortedness of the input. At least one required.","title":"Streaming Window Properties"},{"location":"relations/user_defined_relations/","text":"User Defined Relations \u00b6 Pending","title":"User Defined Relations"},{"location":"relations/user_defined_relations/#user-defined-relations","text":"Pending","title":"User Defined Relations"},{"location":"serialization/binary_serialization/","text":"Binary Serialization \u00b6 Substrait can be serialized into a protobuf -based binary representation. The proto schema/IDL files can be found on GitHub . Proto files are place in the io.substrait namespace for C++/Java and the Substrait.Protobuf namespace for C#. Plan \u00b6 The main top-level object used to communicate a Substrait plan using protobuf is a Plan message. The plan message is composed of a set of data structures that minimize repetition in the serialization along with one (or more) Relation trees. Plan Message message Plan { // Substrait version of the plan. Optional up to 0.17.0, required for later // versions. Version version = 6 ; // a list of yaml specifications this plan may depend on repeated substrait.extensions.SimpleExtensionURI extension_uris = 1 ; // a list of extensions this plan may depend on repeated substrait.extensions.SimpleExtensionDeclaration extensions = 2 ; // one or more relation trees that are associated with this plan. repeated PlanRel relations = 3 ; // additional extensions associated with this plan. substrait.extensions.AdvancedExtension advanced_extensions = 4 ; // A list of com.google.Any entities that this plan may use. Can be used to // warn if some embedded message types are unknown. Note that this list may // include message types that are ignorable (optimizations) or that are // unused. In many cases, a consumer may be able to work with a plan even if // one or more message types defined here are unknown. repeated string expected_type_urls = 5 ; } Extensions \u00b6 Protobuf supports both simple and advanced extensions. Simple extensions are declared at the plan level and advanced extensions are declared at multiple levels of messages within the plan. Simple Extensions \u00b6 For simple extensions, a plan references the URIs associated with the simple extensions to provide additional plan capabilities. These URIs will list additional relevant information for the plan. Simple extensions within a plan are split into three components: an extension URI, an extension declaration and a number of references. Extension URI : A unique identifier for the extension pointing to a YAML document specifying one or more specific extensions. Declares an anchor that can be used in extension declarations. Extension Declaration : A specific extension within a single YAML document. The declaration combines a reference to the associated Extension URI along with a unique key identifying the specific item within that YAML document (see Function Signature Compound Names ). It also defines a declaration anchor. The anchor is a plan-specific unique value that the producer creates as a key to be referenced elsewhere. Extension Reference : A specific instance or use of an extension declaration within the plan body. Extension URIs and declarations are encapsulated in the top level of the plan. Extension declarations are then referenced throughout the body of the plan itself. The exact structure of these references will depend on the extension point being used, but they will always include the extension\u2019s anchor (or key). For example, all scalar function expressions contain references to an extension declaration which defines the semantics of the function. Simple Extension URI message SimpleExtensionURI { // A surrogate key used in the context of a single plan used to reference the // URI associated with an extension. uint32 extension_uri_anchor = 1 ; // The URI where this extension YAML can be retrieved. This is the \"namespace\" // of this extension. string uri = 2 ; } Once the YAML file URI anchor is defined, the anchor will be referenced by zero or more SimpleExtensionDefinition s. For each simple extension definition, an anchor is defined for that specific extension entity. This anchor is then referenced to within lower-level primitives (functions, etc.) to reference that specific extension. Message properties are named *_anchor where the anchor is defined and *_reference when referencing the anchor. For example function_anchor and function_reference . Simple Extension Declaration message SimpleExtensionDeclaration { oneof mapping_type { ExtensionType extension_type = 1 ; ExtensionTypeVariation extension_type_variation = 2 ; ExtensionFunction extension_function = 3 ; } // Describes a Type message ExtensionType { // references the extension_uri_anchor defined for a specific extension URI. uint32 extension_uri_reference = 1 ; // A surrogate key used in the context of a single plan to reference a // specific extension type uint32 type_anchor = 2 ; // the name of the type in the defined extension YAML. string name = 3 ; } message ExtensionTypeVariation { // references the extension_uri_anchor defined for a specific extension URI. uint32 extension_uri_reference = 1 ; // A surrogate key used in the context of a single plan to reference a // specific type variation uint32 type_variation_anchor = 2 ; // the name of the type in the defined extension YAML. string name = 3 ; } message ExtensionFunction { // references the extension_uri_anchor defined for a specific extension URI. uint32 extension_uri_reference = 1 ; // A surrogate key used in the context of a single plan to reference a // specific function uint32 function_anchor = 2 ; // A simple name if there is only one impl for the function within the YAML. // A compound name, referencing that includes type short names if there is // more than one impl per name in the YAML. string name = 3 ; } } Note Anchors only have meaning within a single plan and exist simply to reduce plan size. They are not some form of global identifier. Different plans may use different anchors for the same specific functions, types, type variations, etc. Note It is valid for a plan to include SimpleExtensionURI s and/or SimpleExtensionDeclaration s that are not referenced directly. Advanced Extensions \u00b6 Substrait protobuf exposes a special object in multiple places in the representation to expose extension capabilities. Extensions are done via this object. Extensions are separated into main concepts: Advanced Extension Type Description Optimization A change to the plan that may help some consumers work more efficiently with the plan. These properties should be propagated through plan pipelines where possible but do not impact the meaning of the plan. A consumer can safely ignore these properties. Enhancement A change to the plan that functionally changes the behavior of the plan. Use these sparingly as they will impact plan interoperability. Advanced Extension Protobuf message AdvancedExtension { // An optimization is helpful information that don't influence semantics. May // be ignored by a consumer. google.protobuf.Any optimization = 1 ; // An enhancement alter semantics. Cannot be ignored by a consumer. google.protobuf.Any enhancement = 2 ; } Capabilities \u00b6 When two systems exchanging Substrait plans want to understand each other\u2019s capabilities, they may exchange a Capabilities message. The capabilities message provides information on the set of simple and advanced extensions that the system supports. Capabilities Message message Capabilities { // List of Substrait versions this system supports repeated string substrait_versions = 1 ; // list of com.google.Any message types this system supports for advanced // extensions. repeated string advanced_extension_type_urls = 2 ; // list of simple extensions this system supports. repeated SimpleExtension simple_extensions = 3 ; message SimpleExtension { string uri = 1 ; repeated string function_keys = 2 ; repeated string type_keys = 3 ; repeated string type_variation_keys = 4 ; } } Protobuf Rationale \u00b6 The binary format of Substrait is designed to be easy to work with in many languages. A key requirement is that someone can take the binary format IDL and use standard tools to build a set of primitives that are easy to work with in any of a number of languages. This allows communities to build and use Substrait using only a binary IDL and the specification (and allows the Substrait project to avoid being required to build libraries for each language to work with the specification). There are several binary IDLs that exist today. The key requirements for Substrait are the following: Strongly typed IDL schema language High-quality well-supported and idiomatic bindings/compilers for key languages (Python, Javascript, C++, Go, Rust, Java) Compact serial representation The primary formats that exist that roughly qualify under these requirements include: Protobuf, Thrift, Flatbuf, Avro, Cap\u2019N\u2019Proto. Protobuf was chosen due to its clean typing system and large number of high quality language bindings. The binary serialization IDLs can be found on GitHub and are sampled throughout the documentation.","title":"Binary Serialization"},{"location":"serialization/binary_serialization/#binary-serialization","text":"Substrait can be serialized into a protobuf -based binary representation. The proto schema/IDL files can be found on GitHub . Proto files are place in the io.substrait namespace for C++/Java and the Substrait.Protobuf namespace for C#.","title":"Binary Serialization"},{"location":"serialization/binary_serialization/#plan","text":"The main top-level object used to communicate a Substrait plan using protobuf is a Plan message. The plan message is composed of a set of data structures that minimize repetition in the serialization along with one (or more) Relation trees. Plan Message message Plan { // Substrait version of the plan. Optional up to 0.17.0, required for later // versions. Version version = 6 ; // a list of yaml specifications this plan may depend on repeated substrait.extensions.SimpleExtensionURI extension_uris = 1 ; // a list of extensions this plan may depend on repeated substrait.extensions.SimpleExtensionDeclaration extensions = 2 ; // one or more relation trees that are associated with this plan. repeated PlanRel relations = 3 ; // additional extensions associated with this plan. substrait.extensions.AdvancedExtension advanced_extensions = 4 ; // A list of com.google.Any entities that this plan may use. Can be used to // warn if some embedded message types are unknown. Note that this list may // include message types that are ignorable (optimizations) or that are // unused. In many cases, a consumer may be able to work with a plan even if // one or more message types defined here are unknown. repeated string expected_type_urls = 5 ; }","title":"Plan"},{"location":"serialization/binary_serialization/#extensions","text":"Protobuf supports both simple and advanced extensions. Simple extensions are declared at the plan level and advanced extensions are declared at multiple levels of messages within the plan.","title":"Extensions"},{"location":"serialization/binary_serialization/#simple-extensions","text":"For simple extensions, a plan references the URIs associated with the simple extensions to provide additional plan capabilities. These URIs will list additional relevant information for the plan. Simple extensions within a plan are split into three components: an extension URI, an extension declaration and a number of references. Extension URI : A unique identifier for the extension pointing to a YAML document specifying one or more specific extensions. Declares an anchor that can be used in extension declarations. Extension Declaration : A specific extension within a single YAML document. The declaration combines a reference to the associated Extension URI along with a unique key identifying the specific item within that YAML document (see Function Signature Compound Names ). It also defines a declaration anchor. The anchor is a plan-specific unique value that the producer creates as a key to be referenced elsewhere. Extension Reference : A specific instance or use of an extension declaration within the plan body. Extension URIs and declarations are encapsulated in the top level of the plan. Extension declarations are then referenced throughout the body of the plan itself. The exact structure of these references will depend on the extension point being used, but they will always include the extension\u2019s anchor (or key). For example, all scalar function expressions contain references to an extension declaration which defines the semantics of the function. Simple Extension URI message SimpleExtensionURI { // A surrogate key used in the context of a single plan used to reference the // URI associated with an extension. uint32 extension_uri_anchor = 1 ; // The URI where this extension YAML can be retrieved. This is the \"namespace\" // of this extension. string uri = 2 ; } Once the YAML file URI anchor is defined, the anchor will be referenced by zero or more SimpleExtensionDefinition s. For each simple extension definition, an anchor is defined for that specific extension entity. This anchor is then referenced to within lower-level primitives (functions, etc.) to reference that specific extension. Message properties are named *_anchor where the anchor is defined and *_reference when referencing the anchor. For example function_anchor and function_reference . Simple Extension Declaration message SimpleExtensionDeclaration { oneof mapping_type { ExtensionType extension_type = 1 ; ExtensionTypeVariation extension_type_variation = 2 ; ExtensionFunction extension_function = 3 ; } // Describes a Type message ExtensionType { // references the extension_uri_anchor defined for a specific extension URI. uint32 extension_uri_reference = 1 ; // A surrogate key used in the context of a single plan to reference a // specific extension type uint32 type_anchor = 2 ; // the name of the type in the defined extension YAML. string name = 3 ; } message ExtensionTypeVariation { // references the extension_uri_anchor defined for a specific extension URI. uint32 extension_uri_reference = 1 ; // A surrogate key used in the context of a single plan to reference a // specific type variation uint32 type_variation_anchor = 2 ; // the name of the type in the defined extension YAML. string name = 3 ; } message ExtensionFunction { // references the extension_uri_anchor defined for a specific extension URI. uint32 extension_uri_reference = 1 ; // A surrogate key used in the context of a single plan to reference a // specific function uint32 function_anchor = 2 ; // A simple name if there is only one impl for the function within the YAML. // A compound name, referencing that includes type short names if there is // more than one impl per name in the YAML. string name = 3 ; } } Note Anchors only have meaning within a single plan and exist simply to reduce plan size. They are not some form of global identifier. Different plans may use different anchors for the same specific functions, types, type variations, etc. Note It is valid for a plan to include SimpleExtensionURI s and/or SimpleExtensionDeclaration s that are not referenced directly.","title":"Simple Extensions"},{"location":"serialization/binary_serialization/#advanced-extensions","text":"Substrait protobuf exposes a special object in multiple places in the representation to expose extension capabilities. Extensions are done via this object. Extensions are separated into main concepts: Advanced Extension Type Description Optimization A change to the plan that may help some consumers work more efficiently with the plan. These properties should be propagated through plan pipelines where possible but do not impact the meaning of the plan. A consumer can safely ignore these properties. Enhancement A change to the plan that functionally changes the behavior of the plan. Use these sparingly as they will impact plan interoperability. Advanced Extension Protobuf message AdvancedExtension { // An optimization is helpful information that don't influence semantics. May // be ignored by a consumer. google.protobuf.Any optimization = 1 ; // An enhancement alter semantics. Cannot be ignored by a consumer. google.protobuf.Any enhancement = 2 ; }","title":"Advanced Extensions"},{"location":"serialization/binary_serialization/#capabilities","text":"When two systems exchanging Substrait plans want to understand each other\u2019s capabilities, they may exchange a Capabilities message. The capabilities message provides information on the set of simple and advanced extensions that the system supports. Capabilities Message message Capabilities { // List of Substrait versions this system supports repeated string substrait_versions = 1 ; // list of com.google.Any message types this system supports for advanced // extensions. repeated string advanced_extension_type_urls = 2 ; // list of simple extensions this system supports. repeated SimpleExtension simple_extensions = 3 ; message SimpleExtension { string uri = 1 ; repeated string function_keys = 2 ; repeated string type_keys = 3 ; repeated string type_variation_keys = 4 ; } }","title":"Capabilities"},{"location":"serialization/binary_serialization/#protobuf-rationale","text":"The binary format of Substrait is designed to be easy to work with in many languages. A key requirement is that someone can take the binary format IDL and use standard tools to build a set of primitives that are easy to work with in any of a number of languages. This allows communities to build and use Substrait using only a binary IDL and the specification (and allows the Substrait project to avoid being required to build libraries for each language to work with the specification). There are several binary IDLs that exist today. The key requirements for Substrait are the following: Strongly typed IDL schema language High-quality well-supported and idiomatic bindings/compilers for key languages (Python, Javascript, C++, Go, Rust, Java) Compact serial representation The primary formats that exist that roughly qualify under these requirements include: Protobuf, Thrift, Flatbuf, Avro, Cap\u2019N\u2019Proto. Protobuf was chosen due to its clean typing system and large number of high quality language bindings. The binary serialization IDLs can be found on GitHub and are sampled throughout the documentation.","title":"Protobuf Rationale"},{"location":"serialization/text_serialization/","text":"Text Serialization \u00b6 To maximize the new user experience, it is important for Substrait to have a text representation of plans. This allows people to experiment with basic tooling. Building simple CLI tools that do things like SQL > Plan and Plan > SQL or REPL plan construction can all be done relatively straightforwardly with a text representation. The recommended text serialization format is JSON. Since the text format is not designed for performance, the format can be produced to maximize readability. This also allows nice symmetry between the construction of plans and the configuration of various extensions such as function signatures and user defined types. To ensure the JSON is valid, the object will be defined using the OpenApi 3.1 specification . This not only allows strong validation, the OpenApi specification enables code generators to be easily used to produce plans in many languages. While JSON will be used for much of the plan serialization, Substrait uses a custom simplistic grammar for record level expressions. While one can construct an equation such as (10 + 5)/2 using a tree of function and literal objects, it is much more human-readable to consume a plan when the information is written similarly to the way one typically consumes scalar expressions. This grammar will be maintained in an ANTLR grammar (targetable to multiple programming languages) and is also planned to be supported via JSON schema definition format tag so that the grammar can be validated as part of the schema validation.","title":"Text Serialization"},{"location":"serialization/text_serialization/#text-serialization","text":"To maximize the new user experience, it is important for Substrait to have a text representation of plans. This allows people to experiment with basic tooling. Building simple CLI tools that do things like SQL > Plan and Plan > SQL or REPL plan construction can all be done relatively straightforwardly with a text representation. The recommended text serialization format is JSON. Since the text format is not designed for performance, the format can be produced to maximize readability. This also allows nice symmetry between the construction of plans and the configuration of various extensions such as function signatures and user defined types. To ensure the JSON is valid, the object will be defined using the OpenApi 3.1 specification . This not only allows strong validation, the OpenApi specification enables code generators to be easily used to produce plans in many languages. While JSON will be used for much of the plan serialization, Substrait uses a custom simplistic grammar for record level expressions. While one can construct an equation such as (10 + 5)/2 using a tree of function and literal objects, it is much more human-readable to consume a plan when the information is written similarly to the way one typically consumes scalar expressions. This grammar will be maintained in an ANTLR grammar (targetable to multiple programming languages) and is also planned to be supported via JSON schema definition format tag so that the grammar can be validated as part of the schema validation.","title":"Text Serialization"},{"location":"spec/specification/","text":"Specification \u00b6 Process \u00b6 The goal of this project is initially to establish a well-defined specification. Once established, new versions of the specification will follow a normal development/release process. To provide something to peruse while clarifying an openness to the community during the initial development of the specification, we plan to follow the following steps for development of the specification. We will use GitHub branches to describe each of these steps and patches will be proposed to be moved from one branch to the next to allow review of documents while still having strawmen to start with. The steps are: Empty - No outline has been produced. A sketch needs to be produced for people to react and iterate on. Sketch - Something has been written but should serve more as a conceptual backing for what should be achieved in this part of the specification. No collaboration or consensus has occurred. This will be discussed and iterated on until an initial WIP version can be patched. The WIP version will be held in a PR to iterate on until it is committed to the WIP branch of the repository. WIP - An initial version that multiple contributors have agreed to has been produced for this portion of the specification. Any user is welcome to propose additional changes or discussions regarding this component, but it now represents a community intention. Commit - Believed to be a well-formed plan for this portion of the specification. Documents that have had no outstanding reviews for 14 days will be moved from WIP to commit. Changes can still be made, but the section should no longer be under constant revision. (This status is more for external observers to understand the progress of the specification than something that influences internal project process.) Once all portions of the specification have been moved to commit (or eliminated), the specification will move to an initial version number. To try to get a working end-to-end model as quickly as possible, a small number of items have been prioritized. The set of components outlined here are proposed as a mechanism for having bite-size review/discussion chunks to make forward progress. Components \u00b6 Priority Status Section Description 1 wip Simple Types A way to describe the set of basic types that will be operated on within a plan. Only includes simple types such as integers and doubles (nothing configurable or compound). wip Compound Types Expression of types that go beyond simple scalar values. Key concepts here include: configurable types such as fixed length and numeric types as well as compound types such as structs, maps, lists, etc. wip Type Variations Physical variations to base types. sketch User Defined Types Extensions that can be defined for specific IR producers/consumers. 2 sketch Field References Expressions to identify which portions of a record should be operated on. 3 sketch Scalar Functions Description of how functions are specified. Concepts include arguments, variadic functions, output type derivation, etc. sketch Scalar Function List A list of well-known canonical functions in YAML format. sketch Specialized Record Expressions Specialized expression types that are more naturally expressed outside the function paradigm. Examples include items such as if/then/else and switch statements. sketch Aggregate Functions Functions that are expressed in aggregation operations. Examples include things such as SUM, COUNT, etc. Operations take many records and collapse them into a single (possibly compound) value. sketch Window Functions Functions that relate a record to a set of encompassing records. Examples in SQL include RANK, NTILE, etc. empty Table Functions Functions that convert one or more values from an input record into 0..N output records. Example include operations such as explode, pos-explode, etc. sketch User Defined Functions Reusable named functions that are built beyond the core specification. Implementations are typically registered thorough external means (drop a file in a directory, send a special command with implementation, etc.) sketch Embedded Functions Functions implementations embedded directly within the plan. Frequently used in data science workflows where business logic is interspersed with standard operations. 4 sketch Relation Basics Basic concepts around relational algebra, record emit and properties. sketch Logical Relations Common relational operations used in compute plans including project, join, aggregation, etc. sketch Physical Relations Specific execution sub-variations of common relational operations that describe have multiple unique physical variants associated with a single logical operation. Examples include hash join, merge join, nested loop join, etc. empty User Defined Relations Installed and reusable relational operations customized to a particular platform. empty Embedded Relations Relational operations where plans contain the \u201cmachine code\u201d to directly execute the necessary operations. 5 sketch Text Serialization A human producible & consumable representation of the plan specification. 6 sketch Binary Serialization A high performance & compact binary representation of the plan specification.","title":"Specification"},{"location":"spec/specification/#specification","text":"","title":"Specification"},{"location":"spec/specification/#process","text":"The goal of this project is initially to establish a well-defined specification. Once established, new versions of the specification will follow a normal development/release process. To provide something to peruse while clarifying an openness to the community during the initial development of the specification, we plan to follow the following steps for development of the specification. We will use GitHub branches to describe each of these steps and patches will be proposed to be moved from one branch to the next to allow review of documents while still having strawmen to start with. The steps are: Empty - No outline has been produced. A sketch needs to be produced for people to react and iterate on. Sketch - Something has been written but should serve more as a conceptual backing for what should be achieved in this part of the specification. No collaboration or consensus has occurred. This will be discussed and iterated on until an initial WIP version can be patched. The WIP version will be held in a PR to iterate on until it is committed to the WIP branch of the repository. WIP - An initial version that multiple contributors have agreed to has been produced for this portion of the specification. Any user is welcome to propose additional changes or discussions regarding this component, but it now represents a community intention. Commit - Believed to be a well-formed plan for this portion of the specification. Documents that have had no outstanding reviews for 14 days will be moved from WIP to commit. Changes can still be made, but the section should no longer be under constant revision. (This status is more for external observers to understand the progress of the specification than something that influences internal project process.) Once all portions of the specification have been moved to commit (or eliminated), the specification will move to an initial version number. To try to get a working end-to-end model as quickly as possible, a small number of items have been prioritized. The set of components outlined here are proposed as a mechanism for having bite-size review/discussion chunks to make forward progress.","title":"Process"},{"location":"spec/specification/#components","text":"Priority Status Section Description 1 wip Simple Types A way to describe the set of basic types that will be operated on within a plan. Only includes simple types such as integers and doubles (nothing configurable or compound). wip Compound Types Expression of types that go beyond simple scalar values. Key concepts here include: configurable types such as fixed length and numeric types as well as compound types such as structs, maps, lists, etc. wip Type Variations Physical variations to base types. sketch User Defined Types Extensions that can be defined for specific IR producers/consumers. 2 sketch Field References Expressions to identify which portions of a record should be operated on. 3 sketch Scalar Functions Description of how functions are specified. Concepts include arguments, variadic functions, output type derivation, etc. sketch Scalar Function List A list of well-known canonical functions in YAML format. sketch Specialized Record Expressions Specialized expression types that are more naturally expressed outside the function paradigm. Examples include items such as if/then/else and switch statements. sketch Aggregate Functions Functions that are expressed in aggregation operations. Examples include things such as SUM, COUNT, etc. Operations take many records and collapse them into a single (possibly compound) value. sketch Window Functions Functions that relate a record to a set of encompassing records. Examples in SQL include RANK, NTILE, etc. empty Table Functions Functions that convert one or more values from an input record into 0..N output records. Example include operations such as explode, pos-explode, etc. sketch User Defined Functions Reusable named functions that are built beyond the core specification. Implementations are typically registered thorough external means (drop a file in a directory, send a special command with implementation, etc.) sketch Embedded Functions Functions implementations embedded directly within the plan. Frequently used in data science workflows where business logic is interspersed with standard operations. 4 sketch Relation Basics Basic concepts around relational algebra, record emit and properties. sketch Logical Relations Common relational operations used in compute plans including project, join, aggregation, etc. sketch Physical Relations Specific execution sub-variations of common relational operations that describe have multiple unique physical variants associated with a single logical operation. Examples include hash join, merge join, nested loop join, etc. empty User Defined Relations Installed and reusable relational operations customized to a particular platform. empty Embedded Relations Relational operations where plans contain the \u201cmachine code\u201d to directly execute the necessary operations. 5 sketch Text Serialization A human producible & consumable representation of the plan specification. 6 sketch Binary Serialization A high performance & compact binary representation of the plan specification.","title":"Components"},{"location":"spec/technology_principles/","text":"Technology Principles \u00b6 Provide a good suite of well-specified common functionality in databases and data science applications. Make it easy for users to privately or publicly extend the representation to support specialized/custom operations. Produce something that is language agnostic and requires minimal work to start developing against in a new language. Drive towards a common format that avoids specialization for single favorite producer or consumer. Establish clear delineation between specifications that MUST be respected to and those that can be optionally ignored. Establish a forgiving compatibility approach and versioning scheme that supports cross-version compatibility in maximum number of cases. Minimize the need for consumer intelligence by excluding concepts like overloading, type coercion, implicit casting, field name handling, etc. (Note: this is weak and should be better stated.) Decomposability/severability: A particular producer or consumer should be able to produce or consume only a subset of the specification and interact well with any other Substrait system as long the specific operations requested fit within the subset of specification supported by the counter system.","title":"Technology Principles"},{"location":"spec/technology_principles/#technology-principles","text":"Provide a good suite of well-specified common functionality in databases and data science applications. Make it easy for users to privately or publicly extend the representation to support specialized/custom operations. Produce something that is language agnostic and requires minimal work to start developing against in a new language. Drive towards a common format that avoids specialization for single favorite producer or consumer. Establish clear delineation between specifications that MUST be respected to and those that can be optionally ignored. Establish a forgiving compatibility approach and versioning scheme that supports cross-version compatibility in maximum number of cases. Minimize the need for consumer intelligence by excluding concepts like overloading, type coercion, implicit casting, field name handling, etc. (Note: this is weak and should be better stated.) Decomposability/severability: A particular producer or consumer should be able to produce or consume only a subset of the specification and interact well with any other Substrait system as long the specific operations requested fit within the subset of specification supported by the counter system.","title":"Technology Principles"},{"location":"spec/versioning/","text":"Versioning \u00b6 As an interface specification, the goal of Substrait is to reach a point where (breaking) changes will never need to happen again, or at least be few and far between. By analogy, Apache Arrow\u2019s in-memory format specification has stayed functionally constant, despite many major library versions being released. However, we\u2019re not there yet. When we believe that we\u2019ve reached this point, we will signal this by releasing version 1.0.0. Until then, we will remain in the 0.x.x version regime. Despite this, we strive to maintain backward compatibility for both the binary representation and the text representation by means of deprecation. When a breaking change cannot be reasonably avoided, we may remove previously deprecated fields. All deprecated fields will be removed for the 1.0.0 release. Substrait uses semantic versioning for its version numbers, with the addition that, during 0.x.y, we increment the x digit for breaking changes and new features, and the y digit for fixes and other nonfunctional changes. The release process is currently automated and makes a new release every week, provided something has changed on the main branch since the previous release. This release cadence will likely be slowed down as stability increases over time. Conventional commits are used to distinguish between breaking changes, new features, and fixes, and GitHub actions are used to verify that there are indeed no breaking protobuf changes in a commit, unless the commit message states this.","title":"Versioning"},{"location":"spec/versioning/#versioning","text":"As an interface specification, the goal of Substrait is to reach a point where (breaking) changes will never need to happen again, or at least be few and far between. By analogy, Apache Arrow\u2019s in-memory format specification has stayed functionally constant, despite many major library versions being released. However, we\u2019re not there yet. When we believe that we\u2019ve reached this point, we will signal this by releasing version 1.0.0. Until then, we will remain in the 0.x.x version regime. Despite this, we strive to maintain backward compatibility for both the binary representation and the text representation by means of deprecation. When a breaking change cannot be reasonably avoided, we may remove previously deprecated fields. All deprecated fields will be removed for the 1.0.0 release. Substrait uses semantic versioning for its version numbers, with the addition that, during 0.x.y, we increment the x digit for breaking changes and new features, and the y digit for fixes and other nonfunctional changes. The release process is currently automated and makes a new release every week, provided something has changed on the main branch since the previous release. This release cadence will likely be slowed down as stability increases over time. Conventional commits are used to distinguish between breaking changes, new features, and fixes, and GitHub actions are used to verify that there are indeed no breaking protobuf changes in a commit, unless the commit message states this.","title":"Versioning"},{"location":"tools/producer_tools/","text":"Producer Tools \u00b6 Isthmus \u00b6 Isthmus is an application that serializes SQL to Substrait Protobuf via the Calcite SQL compiler.","title":"Producer Tools"},{"location":"tools/producer_tools/#producer-tools","text":"","title":"Producer Tools"},{"location":"tools/producer_tools/#isthmus","text":"Isthmus is an application that serializes SQL to Substrait Protobuf via the Calcite SQL compiler.","title":"Isthmus"},{"location":"tools/substrait_validator/","text":"Substrait Validator \u00b6 The Substrait Validator is a tool used to validate substrait plans as well as print diagnostics information regarding the plan validity.","title":"Substrait Validator"},{"location":"tools/substrait_validator/#substrait-validator","text":"The Substrait Validator is a tool used to validate substrait plans as well as print diagnostics information regarding the plan validity.","title":"Substrait Validator"},{"location":"tools/third_party_tools/","text":"Third Party Tools \u00b6 Substrait-tools \u00b6 The substrait-tools python package provides a command line interface for producing/consuming substrait plans by leveraging the APIs from different producers and consumers.","title":"Third Party Tools"},{"location":"tools/third_party_tools/#third-party-tools","text":"","title":"Third Party Tools"},{"location":"tools/third_party_tools/#substrait-tools","text":"The substrait-tools python package provides a command line interface for producing/consuming substrait plans by leveraging the APIs from different producers and consumers.","title":"Substrait-tools"},{"location":"tutorial/sql_to_substrait/","text":"SQL to Substrait tutorial \u00b6 This is an introductory tutorial to learn the basics of Substrait for readers already familiar with SQL. We will look at how to construct a Substrait plan from an example query. We\u2019ll present the Substrait in JSON form to make it relatively readable to newcomers. Typically Substrait is exchanged as a protobuf message, but for debugging purposes it is often helpful to look at a serialized form. Plus, it\u2019s not uncommon for unit tests to represent plans as JSON strings. So if you are developing with Substrait, it\u2019s useful to have experience reading them. Note Substrait is currently only defined with Protobuf. The JSON provided here is the Protobuf JSON output, but it is not the official Substrait text format. Eventually, Substrait will define it\u2019s own human-readable text format, but for now this tutorial will make due with what Protobuf provides. Substrait is designed to communicate plans (mostly logical plans). Those plans contain types, schemas, expressions, extensions, and relations. We\u2019ll look at them in that order, going from simplest to most complex until we can construct full plans. This tutorial won\u2019t cover all the details of each piece, but it will give you an idea of how they connect together. For a detailed reference of each individual field, the best place to look is reading the protobuf definitions . They represent the source-of-truth of the spec and are well-commented to address ambiguities. Problem Set up \u00b6 To learn Substrait, we\u2019ll build up to a specific query. We\u2019ll be using the tables: CREATE TABLE orders ( product_id : i64 NOT NULL , quantity : i32 NOT NULL , order_date : date NOT NULL , price : decimal ( 10 , 2 ) ); CREATE TABLE products ( product_id : i64 NOT NULL , categories : list < string NOT NULL > NOT NULL , details : struct < manufacturer : string , year_created : int32 > , product_name : string ); This orders table represents events where products were sold, recording how many ( quantity ) and at what price ( price ). The products table provides details for each product, with product_id as the primary key. And we\u2019ll try to create the query: SELECT product_name , product_id , sum ( quantity * price ) as sales FROM orders INNER JOIN products ON orders . product_id = products . product_id WHERE -- categories does not contain \"Computers\" INDEX_IN ( \"Computers\" , categories ) IS NULL GROUP BY product_name , product_id The query asked the question: For products that aren\u2019t in the \"Computer\" category, how much has each product generated in sales? However, Substrait doesn\u2019t correspond to SQL as much as it does to logical plans. So to be less ambiguous, the plan we are aiming for looks like: |-+ Aggregate({sales = sum(quantity_price)}, group_by=(product_name, product_id)) |-+ InnerJoin(on=orders.product_id = products.product_id) |- ReadTable(orders) |-+ Filter(INDEX_IN(\"Computers\", categories) IS NULL) |- ReadTable(products) Types and Schemas \u00b6 As part of the Substrait plan, we\u2019ll need to embed the data types of the input tables. In Substrait, each type is a distinct message, which at a minimum contains a field for nullability. For example, a string field looks like: { \"string\" : { \"nullability\" : \"NULLABILITY_NULLABLE\" } } Nullability is an enum not a boolean, since Substrait allows NULLABILITY_UNSPECIFIED as an option, in addition to NULLABILITY_NULLABLE (nullable) and NULLABILITY_REQUIRED (not nullable). Other types such as VarChar and Decimal have other parameters. For example, our orders.price column will be represented as: { \"decimal\" : { \"precision\" : 10 , \"scale\" : 2 , \"nullability\" : \"NULLABILITY_NULLABLE\" } } Finally, there are nested compound types such as structs and list types that have other types as parameters. For example, the products.categories column is a list of strings, so can be represented as: { \"list\" : { \"type\" : { \"string\" : { \"nullability\" : \"NULLABILITY_REQUIRED\" } }, \"nullability\" : \"NULLABILITY_REQUIRED\" } } To know what parameters each type can take, refer to the Protobuf definitions in type.proto . Schemas of tables can be represented with a NamedStruct message, which is the combination of a struct type containing all the columns and a list of column names. For the orders table, this will look like: { \"names\" : [ \"product_id\" , \"quantity\" , \"order_date\" , \"price\" ], \"struct\" : { \"types\" : [ { \"i64\" : { \"nullability\" : \"NULLABILITY_REQUIRED\" } }, { \"i32\" : { \"nullability\" : \"NULLABILITY_REQUIRED\" } }, { \"date\" : { \"nullability\" : \"NULLABILITY_REQUIRED\" } }, { \"decimal\" : { \"precision\" : 10 , \"scale\" : 2 , \"nullability\" : \"NULLABILITY_NULLABLE\" } } ], \"nullability\" : \"NULLABILITY_REQUIRED\" } } Here, names is the names of all fields. In nested schemas, this includes the names of subfields in depth-first order. So for the products table, the details struct field will be included as well as the two subfields ( manufacturer and year_created ) right after. And because it\u2019s depth first, these subfields appear before product_name . The full schema looks like: { \"names\" : [ \"product_id\" , \"categories\" , \"details\" , \"manufacturer\" , \"year_created\" , \"product_name\" ], \"struct\" : { \"types\" : [ { \"i64\" : { \"nullability\" : \"NULLABILITY_REQUIRED\" } }, { \"list\" : { \"type\" : { \"string\" : { \"nullability\" : \"NULLABILITY_REQUIRED\" } }, \"nullability\" : \"NULLABILITY_REQUIRED\" } }, { \"struct\" : { \"types\" : [ { \"string\" : { \"nullability\" : \"NULLABILITY_NULLABLE\" }, \"i32\" : { \"nullability\" : \"NULLABILITY_NULLABLE\" } } ], \"nullability\" : \"NULLABILITY_NULLABLE\" } }, { \"string\" : { \"nullability\" : \"NULLABILITY_NULLABLE\" } } ], \"nullability\" : \"NULLABILITY_REQUIRED\" } } Expressions \u00b6 The next basic building block we will need is expressions. Expressions can be one of several things, including: Field references Literal values Functions Subqueries Window Functions Since some expressions such as functions can contain other expressions, expressions can be represented as a tree. Literal values and field references typically are the leaf nodes. For the expression INDEX_IN(categories, \"Computers\") IS NULL , we have a field reference categories , a literal string \"Computers\" , and two functions\u2014 INDEX_IN and IS NULL . The field reference for categories is represented by: { \"selection\" : { \"directReference\" : { \"structField\" : { \"field\" : 1 } }, \"rootReference\" : {} } } Whereas SQL references field by names, Substrait always references fields numerically. This means that a Substrait expression only makes sense relative to a certain schema. As we\u2019ll see later when we discuss relations, for a filter relation this will be relative to the input schema, so the 1 here is referring to the second field of products . Note Protobuf may not serialize fields with integer type and value 0, since 0 is the default. So if you instead saw \"structField\": {} , know that is is equivalent to \"structField\": { \"field\": 0 } . \"Computers\" will be translated to a literal expression: { \"literal\" : { \"string\" : \"Computers\" } } Both IS NULL and INDEX_IN will be scalar function expressions. Available functions in Substrait are defined in extension YAML files contained in https://github.com/substrait-io/substrait/tree/main/extensions . Additional extensions may be created elsewhere. IS NULL is defined as a is_null function in functions_comparison.yaml and INDEX_IN is defined as index_in function in functions_set.yaml . First, the expression for INDEX_IN(\"Computers\", categories) is: { \"scalarFunction\" : { \"functionReference\" : 1 , \"outputType\" : { \"i64\" : { \"nullability\" : \"NULLABILITY_NULLABLE\" } }, \"arguments\" : [ { \"value\" : { \"literal\" : { \"string\" : \"Computers\" } } }, { \"value\" : { \"selection\" : { \"directReference\" : { \"structField\" : { \"field\" : 1 } }, \"rootReference\" : {} } } } ] } } functionReference will be explained later in the plans section. For now, understand that it\u2019s a ID that corresponds to an entry in a list of function definitions that we will create later. outputType defines the type the function outputs. We know this is a nullable i64 type since that is what the function definition declares in the YAML file. arguments defines the arguments being passed into the function, which are all done positionally based on the function definition in the YAML file. The two arguments will be familiar as the literal and the field reference we constructed earlier. To create the final expression, we just need to wrap this in another scalar function expression for IS NULL . { \"scalarFunction\" : { \"functionReference\" : 2 , \"outputType\" : { \"bool\" : { \"nullability\" : \"NULLABILITY_REQUIRED\" } }, \"arguments\" : [ { \"value\" : { \"scalarFunction\" : { \"functionReference\" : 1 , \"outputType\" : { \"i64\" : { \"nullability\" : \"NULLABILITY_NULLABLE\" } }, \"arguments\" : [ { \"value\" : { \"literal\" : { \"string\" : \"Computers\" } } }, { \"value\" : { \"selection\" : { \"directReference\" : { \"structField\" : { \"field\" : 1 } }, \"rootReference\" : {} } } } ] } } } ] } } To see what other types of expressions are available and what fields they take, see the Expression proto definition in algebra.proto . Relations \u00b6 In most SQL engines, a logical or physical plan is represented as a tree of nodes, such as filter, project, scan, or join. The left diagram below may be a familiar representation of our plan, where nodes feed data into each other moving from left to right. In Substrait, each of these nodes is a Relation . A relation that takes another relation as input will contain (or refer to) that relation. This is usually a field called input , but sometimes different names are used in relations that take multiple inputs. For example, join relations take two inputs, with field names left and right . In JSON, the rough layout for the relations in our plan will look like: { \"aggregate\" : { \"input\" : { \"join\" : { \"left\" : { \"filter\" : { \"input\" : { \"read\" : { ... } }, ... } }, \"right\" : { \"read\" : { ... } }, ... } }, ... } } For our plan, we need to define the read relations for each table, a filter relation to exclude the \"Computer\" category from the products table, a join relation to perform the inner join, and finally an aggregate relation to compute the total sales. The read relations are composed of a baseSchema and a namedTable field. The type of read is a named table, so the namedTable field is present with names containing the list of name segments ( my_database.my_table ). Other types of reads include virtual tables (a table of literal values embedded in the plan) and a list of files. See Read Definition Types for more details. The baseSchema is the schemas we defined earlier and namedTable are just the names of the tables. So for reading the orders table, the relation looks like: { \"read\" : { \"namedTable\" : { \"names\" : [ \"orders\" ] }, \"baseSchema\" : { \"names\" : [ \"product_id\" , \"quantity\" , \"order_date\" , \"price\" ], \"struct\" : { \"types\" : [ { \"i64\" : { \"nullability\" : \"NULLABILITY_REQUIRED\" } }, { \"i32\" : { \"nullability\" : \"NULLABILITY_REQUIRED\" } }, { \"date\" : { \"nullability\" : \"NULLABILITY_REQUIRED\" } }, { \"decimal\" : { \"scale\" : 10 , \"precision\" : 2 , \"nullability\" : \"NULLABILITY_NULLABLE\" } } ], \"nullability\" : \"NULLABILITY_REQUIRED\" } } } } Read relations are leaf nodes. Leaf nodes don\u2019t depend on any other node for data and usually represent a source of data in our plan. Leaf nodes are then typically used as input for other nodes that manipulate the data. For example, our filter node will take the products read relation as an input. The filter node will also take a condition field, which will just be the expression we constructed earlier. { \"filter\" : { \"input\" : { \"read\" : { ... } }, \"condition\" : { \"scalarFunction\" : { \"functionReference\" : 2 , \"outputType\" : { \"bool\" : { \"nullability\" : \"NULLABILITY_REQUIRED\" } }, \"arguments\" : [ { \"value\" : { \"scalarFunction\" : { \"functionReference\" : 1 , \"outputType\" : { \"i64\" : { \"nullability\" : \"NULLABILITY_NULLABLE\" } }, \"arguments\" : [ { \"value\" : { \"literal\" : { \"string\" : \"Computers\" } } }, { \"value\" : { \"selection\" : { \"directReference\" : { \"structField\" : { \"field\" : 1 } }, \"rootReference\" : {} } } } ] } } } ] } } } } The join relation will take two inputs. In the left field will be the read relation for orders and in the right field will be the filter relation (from products ). The type field is an enum that allows us to specify we want an inner join. Finally, the expression field contains the expression to use in the join. Since we haven\u2019t used the equals() function yet, we use the reference number 3 here. (Again, we\u2019ll see at the end with plans how these functions are resolved.) The arguments refer to fields 0 and 4, which are indices into the combined schema formed from the left and right inputs. We\u2019ll discuss later in Field Indices where these come from. { \"join\" : { \"left\" : { ... }, \"right\" : { ... }, \"type\" : \"JOIN_TYPE_INNER\" , \"expression\" : { \"scalarFunction\" : { \"functionReference\" : 3 , \"outputType\" : { \"bool\" : { \"nullability\" : \"NULLABILITY_NULLABLE\" } }, \"arguments\" : [ { \"value\" : { \"selection\" : { \"directReference\" : { \"structField\" : { \"field\" : 0 } }, \"rootReference\" : {} } } }, { \"value\" : { \"selection\" : { \"directReference\" : { \"structField\" : { \"field\" : 4 } }, \"rootReference\" : {} } } } ] } } } } The final aggregation requires two things, other than the input. First is the groupings. We\u2019ll use a single grouping expression containing the references to the fields product_name and product_id . (Multiple grouping expressions can be used to do cube aggregations.) For measures , we\u2019ll need to define sum(quantity * price) as sales . Substrait is stricter about data types, and quantity is an integer while price is a decimal. So we\u2019ll first need to cast quantity to a decimal, making the Substrait expression more like sum(multiply(cast(decimal(10, 2), quantity), price)) . Both sum() and multiply() are functions, defined in functions_arithmetic_demical.yaml . However cast() is a special expression type in Substrait, rather than a function. Finally, the naming with as sales will be handled at the end as part of the plan, so that\u2019s not part of the relation. Since we are always using field indices to refer to fields, Substrait doesn\u2019t record any intermediate field names. { \"aggregate\" : { \"input\" : { ... }, \"groupings\" : [ { \"groupingExpressions\" : [ { \"value\" : { \"selection\" : { \"directReference\" : { \"structField\" : { \"field\" : 0 } }, \"rootReference\" : {} } } }, { \"value\" : { \"selection\" : { \"directReference\" : { \"structField\" : { \"field\" : 7 } }, \"rootReference\" : {} } } }, ] } ], \"measures\" : [ { \"measure\" : { \"functionReference\" : 4 , \"outputType\" : { \"decimal\" : { \"precision\" : 38 , \"scale\" : 2 , \"nullability\" : \"NULLABILITY_NULLABLE\" } }, \"arguments\" : [ { \"value\" : { \"scalarFunction\" : { \"functionReference\" : 5 , \"outputType\" : { \"decimal\" : { \"precision\" : 38 , \"scale\" : 2 , \"nullability\" : \"NULLABILITY_NULLABLE\" } }, \"arguments\" : [ { \"value\" : { \"cast\" : { \"type\" : { \"decimal\" : { \"precision\" : 10 , \"scale\" : 2 , \"nullability\" : \"NULLABILITY_REQUIRED\" } }, \"input\" : { \"selection\" : { \"directReference\" : { \"structField\" : { \"field\" : 1 } }, \"rootReference\" : {} } } } } }, { \"value\" : { \"selection\" : { \"directReference\" : { \"structField\" : { \"field\" : 3 } }, \"rootReference\" : {} } } } ] } } } ] } } ] } } Field indices \u00b6 So far, we have glossed over the field indices. Now that we\u2019ve built up each of the relations, it will be a bit easier to explain them. Throughout the plan, data always has some implicit schema, which is modified by each relation. Often, the schema can change within a relation\u2013we\u2019ll discuss an example in the next section. Each relation has it\u2019s own rules in how schemas are modified, called the output order or emit order. For the purposes of our query, the relevant rules are: For Read relations, their output schema is the schema of the table. For Filter relations, the output schema is the same as in the input schema. For Joins relations, the input schema is the concatenation of the left and then the right schemas. The output schema is the same. For Aggregate relations, the output schema is the group by fields followed by the measures. Note Sometimes it can be hard to tell what the implicit schema is. For help determining that, consider using the substrait-validator tool, described in Next Steps . The diagram below shows the mapping of field indices within each relation and how each of the field references show up in each relations properties. Column selection and emit \u00b6 As written, the aggregate output schema will be: 0: product_id: i64 1: product_name: string 2: sales: decimal(32, 8) But we want product_name to come before product_id in our output. How do we reorder those columns? You might be tempted to add a Project relation at the end. However, the project relation only adds columns; it is not responsible for subsetting or reordering columns. Instead, any relation can reorder or subset columns through the emit property. By default, it is set to direct , which outputs all columns \u201cas is\u201d. But it can also be specified as a sequence of field indices. For simplicity, we will add this to the final aggregate relation. We could also add it to all relations, only selecting the fields we strictly need in later relations. Indeed, a good optimizer would probably do that to our plan. And for some engines, the emit property is only valid within a project relation, so in those cases we would need to add that relation in combination with emit. But to keep things simple, we\u2019ll limit the columns at the end within the aggregation relation. For our final column selection, we\u2019ll modify the top-level relation to be: { \"aggregate\" : { \"input\" : { ... }, \"groupings\" : [ ... ], \"measures\" : [ ... ], \"common\" : { \"emit\" : { \"outputMapping\" : [ 1 , 0 , 2 ] } } } Plans \u00b6 Now that we\u2019ve constructed our relations, we can put it all into a plan. Substrait plans are the only messages that can be sent and received on their own. Recall that earlier, we had function references to those YAML files, but so far there\u2019s been no place to tell a consumer what those function reference IDs mean or which extensions we are using. That information belongs at the plan level. The overall layout for a plan is { \"extensionUris\" : [ ... ], \"extensions\" : [ ... ], \"relations\" : [ { \"root\" : { \"names\" : [ \"product_name\" , \"product_id\" , \"sales\" ], \"input\" : { ... } } } ] } The relations field is a list of Root relations. Most queries only have one root relation, but the spec allows for multiple so a common plan could be referenced by other plans, sort of like a CTE (Common Table Expression) from SQL. The root relation provides the final column names for our query. The input to this relation is our aggregate relation (which contains all the other relations as children). For extensions, we need to provide extensionUris with the locations of the YAML files we used and extensions with the list of functions we used and which extension they come from. In our query, we used: index_in (1), from functions_string.yaml , is_null (2), from functions_comparison.yaml , equal (3), from functions_comparison.yaml , sum (4), from functions_arithmetic_decimal.yaml , multiply (5), from functions_arithmetic_decimal.yaml . So first we can create the three extension uris: [ { \"extensionUriAnchor\" : 1 , \"uri\" : \"https://github.com/substrait-io/substrait/blob/main/extensions/functions_string.yaml\" }, { \"extensionUriAnchor\" : 2 , \"uri\" : \"https://github.com/substrait-io/substrait/blob/main/extensions/functions_comparison.yaml\" }, { \"extensionUriAnchor\" : 3 , \"uri\" : \"https://github.com/substrait-io/substrait/blob/main/extensions/functions_arithmetic_decimal.yaml\" } ] Then we can create the extensions: [ { \"extensionFunction\" : { \"extensionUriReference\" : 1 , \"functionAnchor\" : 1 , \"name\" : \"index_in\" } }, { \"extensionFunction\" : { \"extensionUriReference\" : 2 , \"functionAnchor\" : 2 , \"name\" : \"is_null\" } }, { \"extensionFunction\" : { \"extensionUriReference\" : 2 , \"functionAnchor\" : 3 , \"name\" : \"equal\" } }, { \"extensionFunction\" : { \"extensionUriReference\" : 3 , \"functionAnchor\" : 4 , \"name\" : \"sum\" } }, { \"extensionFunction\" : { \"extensionUriReference\" : 3 , \"functionAnchor\" : 5 , \"name\" : \"multiply\" } } ] Once we\u2019ve added our extensions, the plan is complete. Our plan outputted in full is: final_plan.json . Next steps \u00b6 Validate and introspect plans using substrait-validator . Amongst other things, this tool can show what the current schema and column indices are at each point in the plan. Try downloading the final plan JSON above and generating an HTML report on the plan with: substrait-validator final_plan.json --out-file output.html","title":"SQL to Substrait tutorial"},{"location":"tutorial/sql_to_substrait/#sql-to-substrait-tutorial","text":"This is an introductory tutorial to learn the basics of Substrait for readers already familiar with SQL. We will look at how to construct a Substrait plan from an example query. We\u2019ll present the Substrait in JSON form to make it relatively readable to newcomers. Typically Substrait is exchanged as a protobuf message, but for debugging purposes it is often helpful to look at a serialized form. Plus, it\u2019s not uncommon for unit tests to represent plans as JSON strings. So if you are developing with Substrait, it\u2019s useful to have experience reading them. Note Substrait is currently only defined with Protobuf. The JSON provided here is the Protobuf JSON output, but it is not the official Substrait text format. Eventually, Substrait will define it\u2019s own human-readable text format, but for now this tutorial will make due with what Protobuf provides. Substrait is designed to communicate plans (mostly logical plans). Those plans contain types, schemas, expressions, extensions, and relations. We\u2019ll look at them in that order, going from simplest to most complex until we can construct full plans. This tutorial won\u2019t cover all the details of each piece, but it will give you an idea of how they connect together. For a detailed reference of each individual field, the best place to look is reading the protobuf definitions . They represent the source-of-truth of the spec and are well-commented to address ambiguities.","title":"SQL to Substrait tutorial"},{"location":"tutorial/sql_to_substrait/#problem-set-up","text":"To learn Substrait, we\u2019ll build up to a specific query. We\u2019ll be using the tables: CREATE TABLE orders ( product_id : i64 NOT NULL , quantity : i32 NOT NULL , order_date : date NOT NULL , price : decimal ( 10 , 2 ) ); CREATE TABLE products ( product_id : i64 NOT NULL , categories : list < string NOT NULL > NOT NULL , details : struct < manufacturer : string , year_created : int32 > , product_name : string ); This orders table represents events where products were sold, recording how many ( quantity ) and at what price ( price ). The products table provides details for each product, with product_id as the primary key. And we\u2019ll try to create the query: SELECT product_name , product_id , sum ( quantity * price ) as sales FROM orders INNER JOIN products ON orders . product_id = products . product_id WHERE -- categories does not contain \"Computers\" INDEX_IN ( \"Computers\" , categories ) IS NULL GROUP BY product_name , product_id The query asked the question: For products that aren\u2019t in the \"Computer\" category, how much has each product generated in sales? However, Substrait doesn\u2019t correspond to SQL as much as it does to logical plans. So to be less ambiguous, the plan we are aiming for looks like: |-+ Aggregate({sales = sum(quantity_price)}, group_by=(product_name, product_id)) |-+ InnerJoin(on=orders.product_id = products.product_id) |- ReadTable(orders) |-+ Filter(INDEX_IN(\"Computers\", categories) IS NULL) |- ReadTable(products)","title":"Problem Set up"},{"location":"tutorial/sql_to_substrait/#types-and-schemas","text":"As part of the Substrait plan, we\u2019ll need to embed the data types of the input tables. In Substrait, each type is a distinct message, which at a minimum contains a field for nullability. For example, a string field looks like: { \"string\" : { \"nullability\" : \"NULLABILITY_NULLABLE\" } } Nullability is an enum not a boolean, since Substrait allows NULLABILITY_UNSPECIFIED as an option, in addition to NULLABILITY_NULLABLE (nullable) and NULLABILITY_REQUIRED (not nullable). Other types such as VarChar and Decimal have other parameters. For example, our orders.price column will be represented as: { \"decimal\" : { \"precision\" : 10 , \"scale\" : 2 , \"nullability\" : \"NULLABILITY_NULLABLE\" } } Finally, there are nested compound types such as structs and list types that have other types as parameters. For example, the products.categories column is a list of strings, so can be represented as: { \"list\" : { \"type\" : { \"string\" : { \"nullability\" : \"NULLABILITY_REQUIRED\" } }, \"nullability\" : \"NULLABILITY_REQUIRED\" } } To know what parameters each type can take, refer to the Protobuf definitions in type.proto . Schemas of tables can be represented with a NamedStruct message, which is the combination of a struct type containing all the columns and a list of column names. For the orders table, this will look like: { \"names\" : [ \"product_id\" , \"quantity\" , \"order_date\" , \"price\" ], \"struct\" : { \"types\" : [ { \"i64\" : { \"nullability\" : \"NULLABILITY_REQUIRED\" } }, { \"i32\" : { \"nullability\" : \"NULLABILITY_REQUIRED\" } }, { \"date\" : { \"nullability\" : \"NULLABILITY_REQUIRED\" } }, { \"decimal\" : { \"precision\" : 10 , \"scale\" : 2 , \"nullability\" : \"NULLABILITY_NULLABLE\" } } ], \"nullability\" : \"NULLABILITY_REQUIRED\" } } Here, names is the names of all fields. In nested schemas, this includes the names of subfields in depth-first order. So for the products table, the details struct field will be included as well as the two subfields ( manufacturer and year_created ) right after. And because it\u2019s depth first, these subfields appear before product_name . The full schema looks like: { \"names\" : [ \"product_id\" , \"categories\" , \"details\" , \"manufacturer\" , \"year_created\" , \"product_name\" ], \"struct\" : { \"types\" : [ { \"i64\" : { \"nullability\" : \"NULLABILITY_REQUIRED\" } }, { \"list\" : { \"type\" : { \"string\" : { \"nullability\" : \"NULLABILITY_REQUIRED\" } }, \"nullability\" : \"NULLABILITY_REQUIRED\" } }, { \"struct\" : { \"types\" : [ { \"string\" : { \"nullability\" : \"NULLABILITY_NULLABLE\" }, \"i32\" : { \"nullability\" : \"NULLABILITY_NULLABLE\" } } ], \"nullability\" : \"NULLABILITY_NULLABLE\" } }, { \"string\" : { \"nullability\" : \"NULLABILITY_NULLABLE\" } } ], \"nullability\" : \"NULLABILITY_REQUIRED\" } }","title":"Types and Schemas"},{"location":"tutorial/sql_to_substrait/#expressions","text":"The next basic building block we will need is expressions. Expressions can be one of several things, including: Field references Literal values Functions Subqueries Window Functions Since some expressions such as functions can contain other expressions, expressions can be represented as a tree. Literal values and field references typically are the leaf nodes. For the expression INDEX_IN(categories, \"Computers\") IS NULL , we have a field reference categories , a literal string \"Computers\" , and two functions\u2014 INDEX_IN and IS NULL . The field reference for categories is represented by: { \"selection\" : { \"directReference\" : { \"structField\" : { \"field\" : 1 } }, \"rootReference\" : {} } } Whereas SQL references field by names, Substrait always references fields numerically. This means that a Substrait expression only makes sense relative to a certain schema. As we\u2019ll see later when we discuss relations, for a filter relation this will be relative to the input schema, so the 1 here is referring to the second field of products . Note Protobuf may not serialize fields with integer type and value 0, since 0 is the default. So if you instead saw \"structField\": {} , know that is is equivalent to \"structField\": { \"field\": 0 } . \"Computers\" will be translated to a literal expression: { \"literal\" : { \"string\" : \"Computers\" } } Both IS NULL and INDEX_IN will be scalar function expressions. Available functions in Substrait are defined in extension YAML files contained in https://github.com/substrait-io/substrait/tree/main/extensions . Additional extensions may be created elsewhere. IS NULL is defined as a is_null function in functions_comparison.yaml and INDEX_IN is defined as index_in function in functions_set.yaml . First, the expression for INDEX_IN(\"Computers\", categories) is: { \"scalarFunction\" : { \"functionReference\" : 1 , \"outputType\" : { \"i64\" : { \"nullability\" : \"NULLABILITY_NULLABLE\" } }, \"arguments\" : [ { \"value\" : { \"literal\" : { \"string\" : \"Computers\" } } }, { \"value\" : { \"selection\" : { \"directReference\" : { \"structField\" : { \"field\" : 1 } }, \"rootReference\" : {} } } } ] } } functionReference will be explained later in the plans section. For now, understand that it\u2019s a ID that corresponds to an entry in a list of function definitions that we will create later. outputType defines the type the function outputs. We know this is a nullable i64 type since that is what the function definition declares in the YAML file. arguments defines the arguments being passed into the function, which are all done positionally based on the function definition in the YAML file. The two arguments will be familiar as the literal and the field reference we constructed earlier. To create the final expression, we just need to wrap this in another scalar function expression for IS NULL . { \"scalarFunction\" : { \"functionReference\" : 2 , \"outputType\" : { \"bool\" : { \"nullability\" : \"NULLABILITY_REQUIRED\" } }, \"arguments\" : [ { \"value\" : { \"scalarFunction\" : { \"functionReference\" : 1 , \"outputType\" : { \"i64\" : { \"nullability\" : \"NULLABILITY_NULLABLE\" } }, \"arguments\" : [ { \"value\" : { \"literal\" : { \"string\" : \"Computers\" } } }, { \"value\" : { \"selection\" : { \"directReference\" : { \"structField\" : { \"field\" : 1 } }, \"rootReference\" : {} } } } ] } } } ] } } To see what other types of expressions are available and what fields they take, see the Expression proto definition in algebra.proto .","title":"Expressions"},{"location":"tutorial/sql_to_substrait/#relations","text":"In most SQL engines, a logical or physical plan is represented as a tree of nodes, such as filter, project, scan, or join. The left diagram below may be a familiar representation of our plan, where nodes feed data into each other moving from left to right. In Substrait, each of these nodes is a Relation . A relation that takes another relation as input will contain (or refer to) that relation. This is usually a field called input , but sometimes different names are used in relations that take multiple inputs. For example, join relations take two inputs, with field names left and right . In JSON, the rough layout for the relations in our plan will look like: { \"aggregate\" : { \"input\" : { \"join\" : { \"left\" : { \"filter\" : { \"input\" : { \"read\" : { ... } }, ... } }, \"right\" : { \"read\" : { ... } }, ... } }, ... } } For our plan, we need to define the read relations for each table, a filter relation to exclude the \"Computer\" category from the products table, a join relation to perform the inner join, and finally an aggregate relation to compute the total sales. The read relations are composed of a baseSchema and a namedTable field. The type of read is a named table, so the namedTable field is present with names containing the list of name segments ( my_database.my_table ). Other types of reads include virtual tables (a table of literal values embedded in the plan) and a list of files. See Read Definition Types for more details. The baseSchema is the schemas we defined earlier and namedTable are just the names of the tables. So for reading the orders table, the relation looks like: { \"read\" : { \"namedTable\" : { \"names\" : [ \"orders\" ] }, \"baseSchema\" : { \"names\" : [ \"product_id\" , \"quantity\" , \"order_date\" , \"price\" ], \"struct\" : { \"types\" : [ { \"i64\" : { \"nullability\" : \"NULLABILITY_REQUIRED\" } }, { \"i32\" : { \"nullability\" : \"NULLABILITY_REQUIRED\" } }, { \"date\" : { \"nullability\" : \"NULLABILITY_REQUIRED\" } }, { \"decimal\" : { \"scale\" : 10 , \"precision\" : 2 , \"nullability\" : \"NULLABILITY_NULLABLE\" } } ], \"nullability\" : \"NULLABILITY_REQUIRED\" } } } } Read relations are leaf nodes. Leaf nodes don\u2019t depend on any other node for data and usually represent a source of data in our plan. Leaf nodes are then typically used as input for other nodes that manipulate the data. For example, our filter node will take the products read relation as an input. The filter node will also take a condition field, which will just be the expression we constructed earlier. { \"filter\" : { \"input\" : { \"read\" : { ... } }, \"condition\" : { \"scalarFunction\" : { \"functionReference\" : 2 , \"outputType\" : { \"bool\" : { \"nullability\" : \"NULLABILITY_REQUIRED\" } }, \"arguments\" : [ { \"value\" : { \"scalarFunction\" : { \"functionReference\" : 1 , \"outputType\" : { \"i64\" : { \"nullability\" : \"NULLABILITY_NULLABLE\" } }, \"arguments\" : [ { \"value\" : { \"literal\" : { \"string\" : \"Computers\" } } }, { \"value\" : { \"selection\" : { \"directReference\" : { \"structField\" : { \"field\" : 1 } }, \"rootReference\" : {} } } } ] } } } ] } } } } The join relation will take two inputs. In the left field will be the read relation for orders and in the right field will be the filter relation (from products ). The type field is an enum that allows us to specify we want an inner join. Finally, the expression field contains the expression to use in the join. Since we haven\u2019t used the equals() function yet, we use the reference number 3 here. (Again, we\u2019ll see at the end with plans how these functions are resolved.) The arguments refer to fields 0 and 4, which are indices into the combined schema formed from the left and right inputs. We\u2019ll discuss later in Field Indices where these come from. { \"join\" : { \"left\" : { ... }, \"right\" : { ... }, \"type\" : \"JOIN_TYPE_INNER\" , \"expression\" : { \"scalarFunction\" : { \"functionReference\" : 3 , \"outputType\" : { \"bool\" : { \"nullability\" : \"NULLABILITY_NULLABLE\" } }, \"arguments\" : [ { \"value\" : { \"selection\" : { \"directReference\" : { \"structField\" : { \"field\" : 0 } }, \"rootReference\" : {} } } }, { \"value\" : { \"selection\" : { \"directReference\" : { \"structField\" : { \"field\" : 4 } }, \"rootReference\" : {} } } } ] } } } } The final aggregation requires two things, other than the input. First is the groupings. We\u2019ll use a single grouping expression containing the references to the fields product_name and product_id . (Multiple grouping expressions can be used to do cube aggregations.) For measures , we\u2019ll need to define sum(quantity * price) as sales . Substrait is stricter about data types, and quantity is an integer while price is a decimal. So we\u2019ll first need to cast quantity to a decimal, making the Substrait expression more like sum(multiply(cast(decimal(10, 2), quantity), price)) . Both sum() and multiply() are functions, defined in functions_arithmetic_demical.yaml . However cast() is a special expression type in Substrait, rather than a function. Finally, the naming with as sales will be handled at the end as part of the plan, so that\u2019s not part of the relation. Since we are always using field indices to refer to fields, Substrait doesn\u2019t record any intermediate field names. { \"aggregate\" : { \"input\" : { ... }, \"groupings\" : [ { \"groupingExpressions\" : [ { \"value\" : { \"selection\" : { \"directReference\" : { \"structField\" : { \"field\" : 0 } }, \"rootReference\" : {} } } }, { \"value\" : { \"selection\" : { \"directReference\" : { \"structField\" : { \"field\" : 7 } }, \"rootReference\" : {} } } }, ] } ], \"measures\" : [ { \"measure\" : { \"functionReference\" : 4 , \"outputType\" : { \"decimal\" : { \"precision\" : 38 , \"scale\" : 2 , \"nullability\" : \"NULLABILITY_NULLABLE\" } }, \"arguments\" : [ { \"value\" : { \"scalarFunction\" : { \"functionReference\" : 5 , \"outputType\" : { \"decimal\" : { \"precision\" : 38 , \"scale\" : 2 , \"nullability\" : \"NULLABILITY_NULLABLE\" } }, \"arguments\" : [ { \"value\" : { \"cast\" : { \"type\" : { \"decimal\" : { \"precision\" : 10 , \"scale\" : 2 , \"nullability\" : \"NULLABILITY_REQUIRED\" } }, \"input\" : { \"selection\" : { \"directReference\" : { \"structField\" : { \"field\" : 1 } }, \"rootReference\" : {} } } } } }, { \"value\" : { \"selection\" : { \"directReference\" : { \"structField\" : { \"field\" : 3 } }, \"rootReference\" : {} } } } ] } } } ] } } ] } }","title":"Relations"},{"location":"tutorial/sql_to_substrait/#field-indices","text":"So far, we have glossed over the field indices. Now that we\u2019ve built up each of the relations, it will be a bit easier to explain them. Throughout the plan, data always has some implicit schema, which is modified by each relation. Often, the schema can change within a relation\u2013we\u2019ll discuss an example in the next section. Each relation has it\u2019s own rules in how schemas are modified, called the output order or emit order. For the purposes of our query, the relevant rules are: For Read relations, their output schema is the schema of the table. For Filter relations, the output schema is the same as in the input schema. For Joins relations, the input schema is the concatenation of the left and then the right schemas. The output schema is the same. For Aggregate relations, the output schema is the group by fields followed by the measures. Note Sometimes it can be hard to tell what the implicit schema is. For help determining that, consider using the substrait-validator tool, described in Next Steps . The diagram below shows the mapping of field indices within each relation and how each of the field references show up in each relations properties.","title":"Field indices"},{"location":"tutorial/sql_to_substrait/#column-selection-and-emit","text":"As written, the aggregate output schema will be: 0: product_id: i64 1: product_name: string 2: sales: decimal(32, 8) But we want product_name to come before product_id in our output. How do we reorder those columns? You might be tempted to add a Project relation at the end. However, the project relation only adds columns; it is not responsible for subsetting or reordering columns. Instead, any relation can reorder or subset columns through the emit property. By default, it is set to direct , which outputs all columns \u201cas is\u201d. But it can also be specified as a sequence of field indices. For simplicity, we will add this to the final aggregate relation. We could also add it to all relations, only selecting the fields we strictly need in later relations. Indeed, a good optimizer would probably do that to our plan. And for some engines, the emit property is only valid within a project relation, so in those cases we would need to add that relation in combination with emit. But to keep things simple, we\u2019ll limit the columns at the end within the aggregation relation. For our final column selection, we\u2019ll modify the top-level relation to be: { \"aggregate\" : { \"input\" : { ... }, \"groupings\" : [ ... ], \"measures\" : [ ... ], \"common\" : { \"emit\" : { \"outputMapping\" : [ 1 , 0 , 2 ] } } }","title":"Column selection and emit"},{"location":"tutorial/sql_to_substrait/#plans","text":"Now that we\u2019ve constructed our relations, we can put it all into a plan. Substrait plans are the only messages that can be sent and received on their own. Recall that earlier, we had function references to those YAML files, but so far there\u2019s been no place to tell a consumer what those function reference IDs mean or which extensions we are using. That information belongs at the plan level. The overall layout for a plan is { \"extensionUris\" : [ ... ], \"extensions\" : [ ... ], \"relations\" : [ { \"root\" : { \"names\" : [ \"product_name\" , \"product_id\" , \"sales\" ], \"input\" : { ... } } } ] } The relations field is a list of Root relations. Most queries only have one root relation, but the spec allows for multiple so a common plan could be referenced by other plans, sort of like a CTE (Common Table Expression) from SQL. The root relation provides the final column names for our query. The input to this relation is our aggregate relation (which contains all the other relations as children). For extensions, we need to provide extensionUris with the locations of the YAML files we used and extensions with the list of functions we used and which extension they come from. In our query, we used: index_in (1), from functions_string.yaml , is_null (2), from functions_comparison.yaml , equal (3), from functions_comparison.yaml , sum (4), from functions_arithmetic_decimal.yaml , multiply (5), from functions_arithmetic_decimal.yaml . So first we can create the three extension uris: [ { \"extensionUriAnchor\" : 1 , \"uri\" : \"https://github.com/substrait-io/substrait/blob/main/extensions/functions_string.yaml\" }, { \"extensionUriAnchor\" : 2 , \"uri\" : \"https://github.com/substrait-io/substrait/blob/main/extensions/functions_comparison.yaml\" }, { \"extensionUriAnchor\" : 3 , \"uri\" : \"https://github.com/substrait-io/substrait/blob/main/extensions/functions_arithmetic_decimal.yaml\" } ] Then we can create the extensions: [ { \"extensionFunction\" : { \"extensionUriReference\" : 1 , \"functionAnchor\" : 1 , \"name\" : \"index_in\" } }, { \"extensionFunction\" : { \"extensionUriReference\" : 2 , \"functionAnchor\" : 2 , \"name\" : \"is_null\" } }, { \"extensionFunction\" : { \"extensionUriReference\" : 2 , \"functionAnchor\" : 3 , \"name\" : \"equal\" } }, { \"extensionFunction\" : { \"extensionUriReference\" : 3 , \"functionAnchor\" : 4 , \"name\" : \"sum\" } }, { \"extensionFunction\" : { \"extensionUriReference\" : 3 , \"functionAnchor\" : 5 , \"name\" : \"multiply\" } } ] Once we\u2019ve added our extensions, the plan is complete. Our plan outputted in full is: final_plan.json .","title":"Plans"},{"location":"tutorial/sql_to_substrait/#next-steps","text":"Validate and introspect plans using substrait-validator . Amongst other things, this tool can show what the current schema and column indices are at each point in the plan. Try downloading the final plan JSON above and generating an HTML report on the plan with: substrait-validator final_plan.json --out-file output.html","title":"Next steps"},{"location":"types/type_classes/","text":"Type Classes \u00b6 In Substrait, the \u201cclass\u201d of a type, not to be confused with the concept from object-oriented programming, defines the set of non-null values that instances of a type may assume. Implementations of a Substrait type must support at least this set of values, but may include more; for example, an i8 could be represented using the same in-memory format as an i32 , as long as functions operating on i8 values within [-128..127] behave as specified (in this case, this means 8-bit overflow must work as expected). Operating on values outside the specified range is unspecified behavior. Simple Types \u00b6 Simple type classes are those that don\u2019t support any form of configuration. For simplicity, any generic type that has only a small number of discrete implementations is declared directly, as opposed to via configuration. Type Name Description Protobuf representation for literals boolean A value that is either True or False. bool i8 A signed integer within [-128..127], typically represented as an 8-bit two\u2019s complement number. int32 i16 A signed integer within [-32,768..32,767], typically represented as a 16-bit two\u2019s complement number. int32 i32 A signed integer within [-2147483648..2,147,483,647], typically represented as a 32-bit two\u2019s complement number. int32 i64 A signed integer within [\u22129,223,372,036,854,775,808..9,223,372,036,854,775,807], typically represented as a 64-bit two\u2019s complement number. int64 fp32 A 4-byte single-precision floating point number with range as defined here . float fp64 An 8-byte double-precision floating point number with range as defined here . double string A unicode string of text, [0..2,147,483,647] UTF-8 bytes in length. string binary A binary value, [0..2,147,483,647] bytes in length. binary timestamp A naive timestamp within [1000-01-01 00:00:00.000000..9999-12-31 23:59:59.999999], with microsecond precision. Does not include timezone information and can thus not be unambiguously mapped to a moment on the timeline without context. Similar to naive datetime in Python. int64 microseconds since 1970-01-01 00:00:00.000000 (in an unspecified timezone) timestamp_tz A timezone-aware timestamp within [1000-01-01 00:00:00.000000 UTC..9999-12-31 23:59:59.999999 UTC], with microsecond precision. Similar to aware datetime in Python. int64 microseconds since 1970-01-01 00:00:00.000000 UTC date A date within [1000-01-01..9999-12-31]. int32 days since 1970-01-01 time A time since the beginning of any day. Range of [0..86,399,999,999] microseconds; leap seconds need not be supported. int64 microseconds past midnight interval_year Interval year to month. Supports a range of [-10,000..10,000] years with month precision (= [-120,000..120,000] months). Usually stored as separate integers for years and months, but only the total number of months is significant, i.e. 1y 0m is considered equal to 0y 12m or 1001y -12000m . int32 years and int32 months, with the added constraint that each component can never independently specify more than 10,000 years, even if the components have opposite signs (e.g. -10000y 200000m is not allowed) interval_day Interval day to second. Supports a range of [-3,650,000..3,650,000] days with microsecond precision (= [-315,360,000,000,000,000..315,360,000,000,000,000] microseconds). Usually stored as separate integers for various components, but only the total number of microseconds is significant, i.e. 1d 0s is considered equal to 0d 86400s . int32 days, int32 seconds, and int32 microseconds, with the added constraint that each component can never independently specify more than 10,000 years, even if the components have opposite signs (e.g. 3650001d -86400s 0us is not allowed) uuid A universally-unique identifier composed of 128 bits. Typically presented to users in the following hexadecimal format: c48ffa9e-64f4-44cb-ae47-152b4e60e77b . Any 128-bit value is allowed, without specific adherence to RFC4122. 16-byte binary Compound Types \u00b6 Compound type classes are type classes that need to be configured by means of a parameter pack. Type Name Description Protobuf representation for literals FIXEDCHAR<L> A fixed-length unicode string of L characters. L must be within [1..2,147,483,647]. L-character string VARCHAR<L> A unicode string of at most L characters.L must be within [1..2,147,483,647]. string with at most L characters FIXEDBINARY<L> A binary string of L bytes. When casting, values shorter than L are padded with zeros, and values longer than L are right-trimmed. L-byte bytes DECIMAL<P, S> A fixed-precision decimal value having precision (P, number of digits) <= 38 and scale (S, number of fractional digits) 0 <= S <= P. 16-byte bytes representing a little-endian 128-bit integer, to be divided by 10^S to get the decimal value STRUCT<T1,\u2026,Tn> A list of types in a defined order. repeated Literal , types matching T1..Tn NSTRUCT<N:T1,\u2026,N:Tn> Pseudo-type : A struct that maps unique names to value types. Each name is a UTF-8-encoded string. Each value can have a distinct type. Note that NSTRUCT is actually a pseudo-type, because Substrait\u2019s core type system is based entirely on ordinal positions, not named fields. Nonetheless, when working with systems outside Substrait, names are important. n/a LIST<T> A list of values of type T. The list can be between [0..2,147,483,647] values in length. repeated Literal , all types matching T MAP<K, V> An unordered list of type K keys with type V values. repeated KeyValue (in turn two Literal s), all key types matching K and all value types matching V User-Defined Types \u00b6 User-defined type classes can be created using a combination of pre-defined types. User-defined types are defined as part of simple extensions . An extension can declare an arbitrary number of user defined extension types. Once a type has been declared, it can be used in function declarations. A YAML example of an extension type is below: name : point structure : longitude : i32 latitude : i32 This declares a new type (namespaced to the associated YAML file) called \u201cpoint\u201d. This type is composed of two i32 values named longitude and latitude. Structure and opaque types \u00b6 The name-type object notation used above is syntactic sugar for NSTRUCT<longitude: i32, latitude: i32> . The following means the same thing: name : point structure : \"NSTRUCT<longitude: i32, latitude: i32>\" The structure field of a type is only intended to inform systems that don\u2019t have built-in support for the type how they can transfer the data type from one point to another without unnecessary serialization/deserialization and without loss of type safety. Note that it is currently not possible to \u201cunpack\u201d a user-defined type class into its structure type or components thereof using FieldReference s or any other specialized record expression; if support for this is desired for a particular type, this can be accomplished with an extension function. The structure field is optional. If not specified, the type class is considered to be fully opaque. This implies that a systems without built-in support for the type cannot manipulate values in any way, including moving and cloning. This may be useful for exotic, context-sensitive types, such as raw pointers or identifiers that cannot be cloned. Note however that the vast majority of types can be trivially moved and copied, even if they cannot be precisely represented using Substrait\u2019s built-in types. In this case, it is recommended to use binary or FIXEDBINARY<n> (where n is the size of the type) as the structure type. For example, an unsigned 32-bit integer type could be defined as follows: name : u32 structure : \"FIXEDBINARY<4>\" In this case, i32 might also be used. Literals \u00b6 Literals for user-defined types are represented using protobuf Any messages. Compound User-Defined Types \u00b6 User-defined types may be turned into compound types by requiring parameters to be passed to them. The supported \u201cmeta-types\u201d for parameters are data types (like those used in LIST , MAP , and STRUCT ), booleans, integers, enumerations, and strings. Using parameters, we could redefine \u201cpoint\u201d with different types of coordinates. For example: name : point parameters : - name : T description : | The type used for the longitude and latitude components of the point. type : dataType or: name : point parameters : - name : coordinate_type type : enumeration options : - integer - double or: name : point parameters : - name : LONG type : dataType - name : LAT type : dataType We can\u2019t specify the internal structure in this case, because there is currently no support for derived types in the structure. The allowed range can be limited for integer parameters. For example: name : vector parameters : - name : T type : dataType - name : dimensions type : integer min : 2 max : 3 This specifies a vector that can be either 2- or 3-dimensional. Note however that it\u2019s not currently possible to put constraints on data type, string, or (technically) boolean parameters. Similar to function arguments, the last parameter may be specified to be variadic, allowing it to be specified one or more times instead of only once. For example: name : union parameters : - name : T type : dataType variadic : true This defines a type that can be parameterized with one or more other data types, for example union<i32, i64> but also union<bool> . Zero or more is also possible, by making the last argument optional: name : tuple parameters : - name : T type : dataType optional : true variadic : true This would also allow for tuple<> , to define a zero-tuple.","title":"Type Classes"},{"location":"types/type_classes/#type-classes","text":"In Substrait, the \u201cclass\u201d of a type, not to be confused with the concept from object-oriented programming, defines the set of non-null values that instances of a type may assume. Implementations of a Substrait type must support at least this set of values, but may include more; for example, an i8 could be represented using the same in-memory format as an i32 , as long as functions operating on i8 values within [-128..127] behave as specified (in this case, this means 8-bit overflow must work as expected). Operating on values outside the specified range is unspecified behavior.","title":"Type Classes"},{"location":"types/type_classes/#simple-types","text":"Simple type classes are those that don\u2019t support any form of configuration. For simplicity, any generic type that has only a small number of discrete implementations is declared directly, as opposed to via configuration. Type Name Description Protobuf representation for literals boolean A value that is either True or False. bool i8 A signed integer within [-128..127], typically represented as an 8-bit two\u2019s complement number. int32 i16 A signed integer within [-32,768..32,767], typically represented as a 16-bit two\u2019s complement number. int32 i32 A signed integer within [-2147483648..2,147,483,647], typically represented as a 32-bit two\u2019s complement number. int32 i64 A signed integer within [\u22129,223,372,036,854,775,808..9,223,372,036,854,775,807], typically represented as a 64-bit two\u2019s complement number. int64 fp32 A 4-byte single-precision floating point number with range as defined here . float fp64 An 8-byte double-precision floating point number with range as defined here . double string A unicode string of text, [0..2,147,483,647] UTF-8 bytes in length. string binary A binary value, [0..2,147,483,647] bytes in length. binary timestamp A naive timestamp within [1000-01-01 00:00:00.000000..9999-12-31 23:59:59.999999], with microsecond precision. Does not include timezone information and can thus not be unambiguously mapped to a moment on the timeline without context. Similar to naive datetime in Python. int64 microseconds since 1970-01-01 00:00:00.000000 (in an unspecified timezone) timestamp_tz A timezone-aware timestamp within [1000-01-01 00:00:00.000000 UTC..9999-12-31 23:59:59.999999 UTC], with microsecond precision. Similar to aware datetime in Python. int64 microseconds since 1970-01-01 00:00:00.000000 UTC date A date within [1000-01-01..9999-12-31]. int32 days since 1970-01-01 time A time since the beginning of any day. Range of [0..86,399,999,999] microseconds; leap seconds need not be supported. int64 microseconds past midnight interval_year Interval year to month. Supports a range of [-10,000..10,000] years with month precision (= [-120,000..120,000] months). Usually stored as separate integers for years and months, but only the total number of months is significant, i.e. 1y 0m is considered equal to 0y 12m or 1001y -12000m . int32 years and int32 months, with the added constraint that each component can never independently specify more than 10,000 years, even if the components have opposite signs (e.g. -10000y 200000m is not allowed) interval_day Interval day to second. Supports a range of [-3,650,000..3,650,000] days with microsecond precision (= [-315,360,000,000,000,000..315,360,000,000,000,000] microseconds). Usually stored as separate integers for various components, but only the total number of microseconds is significant, i.e. 1d 0s is considered equal to 0d 86400s . int32 days, int32 seconds, and int32 microseconds, with the added constraint that each component can never independently specify more than 10,000 years, even if the components have opposite signs (e.g. 3650001d -86400s 0us is not allowed) uuid A universally-unique identifier composed of 128 bits. Typically presented to users in the following hexadecimal format: c48ffa9e-64f4-44cb-ae47-152b4e60e77b . Any 128-bit value is allowed, without specific adherence to RFC4122. 16-byte binary","title":"Simple Types"},{"location":"types/type_classes/#compound-types","text":"Compound type classes are type classes that need to be configured by means of a parameter pack. Type Name Description Protobuf representation for literals FIXEDCHAR<L> A fixed-length unicode string of L characters. L must be within [1..2,147,483,647]. L-character string VARCHAR<L> A unicode string of at most L characters.L must be within [1..2,147,483,647]. string with at most L characters FIXEDBINARY<L> A binary string of L bytes. When casting, values shorter than L are padded with zeros, and values longer than L are right-trimmed. L-byte bytes DECIMAL<P, S> A fixed-precision decimal value having precision (P, number of digits) <= 38 and scale (S, number of fractional digits) 0 <= S <= P. 16-byte bytes representing a little-endian 128-bit integer, to be divided by 10^S to get the decimal value STRUCT<T1,\u2026,Tn> A list of types in a defined order. repeated Literal , types matching T1..Tn NSTRUCT<N:T1,\u2026,N:Tn> Pseudo-type : A struct that maps unique names to value types. Each name is a UTF-8-encoded string. Each value can have a distinct type. Note that NSTRUCT is actually a pseudo-type, because Substrait\u2019s core type system is based entirely on ordinal positions, not named fields. Nonetheless, when working with systems outside Substrait, names are important. n/a LIST<T> A list of values of type T. The list can be between [0..2,147,483,647] values in length. repeated Literal , all types matching T MAP<K, V> An unordered list of type K keys with type V values. repeated KeyValue (in turn two Literal s), all key types matching K and all value types matching V","title":"Compound Types"},{"location":"types/type_classes/#user-defined-types","text":"User-defined type classes can be created using a combination of pre-defined types. User-defined types are defined as part of simple extensions . An extension can declare an arbitrary number of user defined extension types. Once a type has been declared, it can be used in function declarations. A YAML example of an extension type is below: name : point structure : longitude : i32 latitude : i32 This declares a new type (namespaced to the associated YAML file) called \u201cpoint\u201d. This type is composed of two i32 values named longitude and latitude.","title":"User-Defined Types"},{"location":"types/type_classes/#structure-and-opaque-types","text":"The name-type object notation used above is syntactic sugar for NSTRUCT<longitude: i32, latitude: i32> . The following means the same thing: name : point structure : \"NSTRUCT<longitude: i32, latitude: i32>\" The structure field of a type is only intended to inform systems that don\u2019t have built-in support for the type how they can transfer the data type from one point to another without unnecessary serialization/deserialization and without loss of type safety. Note that it is currently not possible to \u201cunpack\u201d a user-defined type class into its structure type or components thereof using FieldReference s or any other specialized record expression; if support for this is desired for a particular type, this can be accomplished with an extension function. The structure field is optional. If not specified, the type class is considered to be fully opaque. This implies that a systems without built-in support for the type cannot manipulate values in any way, including moving and cloning. This may be useful for exotic, context-sensitive types, such as raw pointers or identifiers that cannot be cloned. Note however that the vast majority of types can be trivially moved and copied, even if they cannot be precisely represented using Substrait\u2019s built-in types. In this case, it is recommended to use binary or FIXEDBINARY<n> (where n is the size of the type) as the structure type. For example, an unsigned 32-bit integer type could be defined as follows: name : u32 structure : \"FIXEDBINARY<4>\" In this case, i32 might also be used.","title":"Structure and opaque types"},{"location":"types/type_classes/#literals","text":"Literals for user-defined types are represented using protobuf Any messages.","title":"Literals"},{"location":"types/type_classes/#compound-user-defined-types","text":"User-defined types may be turned into compound types by requiring parameters to be passed to them. The supported \u201cmeta-types\u201d for parameters are data types (like those used in LIST , MAP , and STRUCT ), booleans, integers, enumerations, and strings. Using parameters, we could redefine \u201cpoint\u201d with different types of coordinates. For example: name : point parameters : - name : T description : | The type used for the longitude and latitude components of the point. type : dataType or: name : point parameters : - name : coordinate_type type : enumeration options : - integer - double or: name : point parameters : - name : LONG type : dataType - name : LAT type : dataType We can\u2019t specify the internal structure in this case, because there is currently no support for derived types in the structure. The allowed range can be limited for integer parameters. For example: name : vector parameters : - name : T type : dataType - name : dimensions type : integer min : 2 max : 3 This specifies a vector that can be either 2- or 3-dimensional. Note however that it\u2019s not currently possible to put constraints on data type, string, or (technically) boolean parameters. Similar to function arguments, the last parameter may be specified to be variadic, allowing it to be specified one or more times instead of only once. For example: name : union parameters : - name : T type : dataType variadic : true This defines a type that can be parameterized with one or more other data types, for example union<i32, i64> but also union<bool> . Zero or more is also possible, by making the last argument optional: name : tuple parameters : - name : T type : dataType optional : true variadic : true This would also allow for tuple<> , to define a zero-tuple.","title":"Compound User-Defined Types"},{"location":"types/type_parsing/","text":"Type Syntax Parsing \u00b6 In many places, it is useful to have a human-readable string representation of data types. Substrait has a custom syntax for type declaration. The basic structure of a type declaration is: name?[variation]<param0,...,paramN> The components of this expression are: Component Description Required Name Each type has a name. A type is expressed by providing a name. This name can be expressed in arbitrary case (e.g. varchar and vArChAr are equivalent). Nullability indicator A type is either non-nullable or nullable. To express nullability, a type name is appended with a question mark. Optional, defaults to non-nullable Variation When expressing a type, a user can define the type based on a type variation. Some systems use type variations to describe different underlying representations of the same data type. This is expressed as a bracketed integer such as [2]. Optional, defaults to [0] Parameters Compound types may have one or more configurable properties. The two main types of properties are integer and type properties. The parameters for each type correspond to a list of known properties associated with a type as declared in the order defined in the type specification. For compound types (types that contain types), the data type syntax will include nested type declarations. The one exception is structs, which are further outlined below. Required where parameters are defined Grammars \u00b6 It is relatively easy in most languages to produce simple parser & emitters for the type syntax. To make that easier, Substrait also includes an ANTLR [impl pending] grammar to ease consumption and production of types. Structs & Named Structs \u00b6 Structs are unique from other types because they have an arbitrary number of parameters. The parameters can also include one or two subproperties. Struct parsing is thus declared in the following two ways: # Struct struct?[variation]<type0, type1,..., typeN> # Named Struct nstruct?[variation]<name0:type0, name1:type1,..., nameN:typeN> In the normal (non-named) form, struct declares a set of types that are fields within that struct. In the named struct form, the parameters are formed by tuples of names + types, delineated by a colon. Names that are composed only of numbers and letters can be left unquoted. For other characters, names should be quoted with double quotes and use backslash for double-quote escaping. Note, in core Substrait algebra, fields are unnamed and references are always based on zero-index ordinal positions. However, data inputs must declare name-to-ordinal mappings and outputs must declare ordinal-to-name mappings. As such, Substrait also provides a named struct which is a pseudo-type that is useful for human consumption. Outside these places, most structs in a Substrait plan are structs, not named-structs. The two cannot be used interchangeably.","title":"Type Syntax Parsing"},{"location":"types/type_parsing/#type-syntax-parsing","text":"In many places, it is useful to have a human-readable string representation of data types. Substrait has a custom syntax for type declaration. The basic structure of a type declaration is: name?[variation]<param0,...,paramN> The components of this expression are: Component Description Required Name Each type has a name. A type is expressed by providing a name. This name can be expressed in arbitrary case (e.g. varchar and vArChAr are equivalent). Nullability indicator A type is either non-nullable or nullable. To express nullability, a type name is appended with a question mark. Optional, defaults to non-nullable Variation When expressing a type, a user can define the type based on a type variation. Some systems use type variations to describe different underlying representations of the same data type. This is expressed as a bracketed integer such as [2]. Optional, defaults to [0] Parameters Compound types may have one or more configurable properties. The two main types of properties are integer and type properties. The parameters for each type correspond to a list of known properties associated with a type as declared in the order defined in the type specification. For compound types (types that contain types), the data type syntax will include nested type declarations. The one exception is structs, which are further outlined below. Required where parameters are defined","title":"Type Syntax Parsing"},{"location":"types/type_parsing/#grammars","text":"It is relatively easy in most languages to produce simple parser & emitters for the type syntax. To make that easier, Substrait also includes an ANTLR [impl pending] grammar to ease consumption and production of types.","title":"Grammars"},{"location":"types/type_parsing/#structs-named-structs","text":"Structs are unique from other types because they have an arbitrary number of parameters. The parameters can also include one or two subproperties. Struct parsing is thus declared in the following two ways: # Struct struct?[variation]<type0, type1,..., typeN> # Named Struct nstruct?[variation]<name0:type0, name1:type1,..., nameN:typeN> In the normal (non-named) form, struct declares a set of types that are fields within that struct. In the named struct form, the parameters are formed by tuples of names + types, delineated by a colon. Names that are composed only of numbers and letters can be left unquoted. For other characters, names should be quoted with double quotes and use backslash for double-quote escaping. Note, in core Substrait algebra, fields are unnamed and references are always based on zero-index ordinal positions. However, data inputs must declare name-to-ordinal mappings and outputs must declare ordinal-to-name mappings. As such, Substrait also provides a named struct which is a pseudo-type that is useful for human consumption. Outside these places, most structs in a Substrait plan are structs, not named-structs. The two cannot be used interchangeably.","title":"Structs &amp; Named Structs"},{"location":"types/type_system/","text":"Type System \u00b6 Substrait tries to cover the most common types used in data manipulation. Types beyond this common core may be represented using simple extensions . Substrait types fundamentally consist of four components: Component Condition Examples Description Class Always i8 , string , STRUCT , extensions Together with the parameter pack, describes the set of non-null values supported by the type. Subdivided into simple and compound type classes. Nullability Always Either NULLABLE ( ? suffix) or REQUIRED (no suffix) Describes whether values of this type can be null. Note that null is considered to be a special value of a nullable type, rather than the only value of a special null type. Variation Always No suffix or explicitly [0] (system-preferred), or an extension Allows different variations of the same type class to exist in a system at a time, usually distinguished by in-memory format. Parameters Compound types only <10, 2> (for DECIMAL ), <i32, string> (for STRUCT ) Some combination of zero or more data types or integers. The expected set of parameters and the significance of each parameter depends on the type class. Refer to Type Parsing for a description of the syntax used to describe types. Note that Substrait employs a strict type system without any coercion rules. All changes in types must be made explicit via cast expressions .","title":"Type System"},{"location":"types/type_system/#type-system","text":"Substrait tries to cover the most common types used in data manipulation. Types beyond this common core may be represented using simple extensions . Substrait types fundamentally consist of four components: Component Condition Examples Description Class Always i8 , string , STRUCT , extensions Together with the parameter pack, describes the set of non-null values supported by the type. Subdivided into simple and compound type classes. Nullability Always Either NULLABLE ( ? suffix) or REQUIRED (no suffix) Describes whether values of this type can be null. Note that null is considered to be a special value of a nullable type, rather than the only value of a special null type. Variation Always No suffix or explicitly [0] (system-preferred), or an extension Allows different variations of the same type class to exist in a system at a time, usually distinguished by in-memory format. Parameters Compound types only <10, 2> (for DECIMAL ), <i32, string> (for STRUCT ) Some combination of zero or more data types or integers. The expected set of parameters and the significance of each parameter depends on the type class. Refer to Type Parsing for a description of the syntax used to describe types. Note that Substrait employs a strict type system without any coercion rules. All changes in types must be made explicit via cast expressions .","title":"Type System"},{"location":"types/type_variations/","text":"Type Variations \u00b6 Type variations may be used to represent differences in representation between different consumers. For example, an engine might support dictionary encoding for a string, or could be using either a row-wise or columnar representation of a struct. All variations of a type are expected to have the same semantics when operated on by functions or other expressions. All variations except the \u201csystem-preferred\u201d variation (a.k.a. [0] , see Type Parsing ) must be defined using simple extensions . The key properties of these variations are: Property Description Base Type Class The type class that this variation belongs to. Name The name used to reference this type. Should be unique within type variations for this parent type within a simple extension. Description A human description of the purpose of this type variation. Function Behavior INHERITS or SEPARATE : whether functions that support the system-preferred variation implicitly also support this variation, or whether functions should be resolved independently. For example, if one has the function add(i8,i8) defined and then defines an i8 variation, this determines whether the i8 variation can be bound to the base add operation (inherits) or whether a specialized version of add needs to be defined specifically for this variation (separate). Defaults to inherits.","title":"Type Variations"},{"location":"types/type_variations/#type-variations","text":"Type variations may be used to represent differences in representation between different consumers. For example, an engine might support dictionary encoding for a string, or could be using either a row-wise or columnar representation of a struct. All variations of a type are expected to have the same semantics when operated on by functions or other expressions. All variations except the \u201csystem-preferred\u201d variation (a.k.a. [0] , see Type Parsing ) must be defined using simple extensions . The key properties of these variations are: Property Description Base Type Class The type class that this variation belongs to. Name The name used to reference this type. Should be unique within type variations for this parent type within a simple extension. Description A human description of the purpose of this type variation. Function Behavior INHERITS or SEPARATE : whether functions that support the system-preferred variation implicitly also support this variation, or whether functions should be resolved independently. For example, if one has the function add(i8,i8) defined and then defines an i8 variation, this determines whether the i8 variation can be bound to the base add operation (inherits) or whether a specialized version of add needs to be defined specifically for this variation (separate). Defaults to inherits.","title":"Type Variations"}]}