{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Substrait: Cross-Language Serialization for Relational Algebra \u00b6 Project Vision \u00b6 Create a well-defined, cross-language specification for data compute operations. This includes a declaration of common operations, custom operations and one or more serialized representations of this specification. The spec focuses on the semantics of each operation and a consistent way to describe. In many ways, the goal of this project is similar to that of the Apache Arrow project. Arrow is focused on a standardized memory representation of columnar data. Substrait is focused on what should be done to data. Example Use Cases \u00b6 Communicate a compute plan between a SQL parser and an execution engine (e.g. Calcite SQL parsing to Arrow C++ compute kernel) Serialize a plan that represents a SQL view for consistent use in multiple systems (e.g. Iceberg views in Spark and Trino) Submit a plan to different execution engines (e.g. Datafusion and Postgres) and get a consistent interpretation of the semantics. Create an alternative plan generation implementation that can connect an existing end-user compute expression system to an existing end-user processing engine (e.g. Pandas operations executed inside SingleStore) Build a pluggable plan visualization tool (e.g. D3 based plan visualizer) Community Principles \u00b6 Be inclusive and open to all. If you want to join the project, open a PR or issue , start a discussion or join the Slack Channel . Ensure a diverse set of contributors that come from multiple data backgrounds to maximize general utility. Build a specification based on open consensus. Avoid over-reliance/coupling to any single technology. Make the specification and all tools freely available on a permissive license (ApacheV2) Related Technologies \u00b6 Apache Calcite : Many ideas in Substrait are inspired by the Calcite project. Calcite is a great JVM-based SQL query parsing and optimization framework. A key goal of the Substrait project is to expose Calcite capabilities more easily to non-JVM technologies as well as expose query planning operations as microservices. Apache Arrow : The Arrow format for data is what the Substrait specification attempts to be for compute expressions. A key goal of Substrait is to enable Substrait producers to execute work within the Arrow Rust and C++ compute kernels. Why not use SQL? \u00b6 POSIX SQL is a well known language for describing queries against relational data. It is designed to be simple and allow reading and writing by humans. Substrait is not intended as a replacement for SQL and works alongside SQL to provide capabilities that SQL lacks. SQL is not a great fit for systems that actually satisfy the query because it does not provide sufficient detail and is not represented in a format that is easy for processing. Because of this, most modern systems will first translate the SQL query into a query plan, sometimes called the execution plan. There can be multiple levels of a query plan (e.g. physical and logical), a query plan may be split up and distributed across multiple systems, and a query plan often undergoes simplifying or optimizing transformations. The SQL standard does not define the format of the query or execution plan and there is no open format that is supported by a broad set of systems. Substrait was created to provide a standard and open format for these query plans. Why not just do this within an existing OSS project? \u00b6 A key goal of the Substrait project is to not be coupled to any single existing technology. Trying to get people involved in something can be difficult when it seems to be primarily driven by the opinions and habits of a single community. In many ways, this situation is similar to the early situation with Arrow. The precursor to Arrow was the Apache Drill ValueVectors concepts. As part of creating Arrow, Wes and Jacques recognized the need to create a new community to build a fresh consensus (beyond just what the Apache Drill community wanted). This separation and new independent community was a key ingredient to Arrow\u2019s current success. The needs here are much the same: many separate communities could benefit from Substrait, but each have their own pain points, type systems, development processes and timelines. To help resolve these tensions, one of the approaches proposed in Substrait is to set a bar that at least two of the top four OSS data technologies (Arrow, Spark, Iceberg, Trino) supports something before incorporating it directly into the Substrait specification. (Another goal is to support strong extension points at key locations to avoid this bar being a limiter to broad adoption.) Why the name Substrait? \u00b6 A strait is a narrow connector of water between two other pieces of water. In analytics, data is often thought of as water. Substrait is focused on instructions related to the data. In other words, what defines or supports the movement of water between one or more larger systems. Thus, the underlayment for the strait connecting different pools of water => sub-strait.","title":"Home"},{"location":"#substrait-cross-language-serialization-for-relational-algebra","text":"","title":"Substrait: Cross-Language Serialization for Relational Algebra"},{"location":"#project-vision","text":"Create a well-defined, cross-language specification for data compute operations. This includes a declaration of common operations, custom operations and one or more serialized representations of this specification. The spec focuses on the semantics of each operation and a consistent way to describe. In many ways, the goal of this project is similar to that of the Apache Arrow project. Arrow is focused on a standardized memory representation of columnar data. Substrait is focused on what should be done to data.","title":"Project Vision"},{"location":"#example-use-cases","text":"Communicate a compute plan between a SQL parser and an execution engine (e.g. Calcite SQL parsing to Arrow C++ compute kernel) Serialize a plan that represents a SQL view for consistent use in multiple systems (e.g. Iceberg views in Spark and Trino) Submit a plan to different execution engines (e.g. Datafusion and Postgres) and get a consistent interpretation of the semantics. Create an alternative plan generation implementation that can connect an existing end-user compute expression system to an existing end-user processing engine (e.g. Pandas operations executed inside SingleStore) Build a pluggable plan visualization tool (e.g. D3 based plan visualizer)","title":"Example Use Cases"},{"location":"#community-principles","text":"Be inclusive and open to all. If you want to join the project, open a PR or issue , start a discussion or join the Slack Channel . Ensure a diverse set of contributors that come from multiple data backgrounds to maximize general utility. Build a specification based on open consensus. Avoid over-reliance/coupling to any single technology. Make the specification and all tools freely available on a permissive license (ApacheV2)","title":"Community Principles"},{"location":"#related-technologies","text":"Apache Calcite : Many ideas in Substrait are inspired by the Calcite project. Calcite is a great JVM-based SQL query parsing and optimization framework. A key goal of the Substrait project is to expose Calcite capabilities more easily to non-JVM technologies as well as expose query planning operations as microservices. Apache Arrow : The Arrow format for data is what the Substrait specification attempts to be for compute expressions. A key goal of Substrait is to enable Substrait producers to execute work within the Arrow Rust and C++ compute kernels.","title":"Related Technologies"},{"location":"#why-not-use-sql","text":"POSIX SQL is a well known language for describing queries against relational data. It is designed to be simple and allow reading and writing by humans. Substrait is not intended as a replacement for SQL and works alongside SQL to provide capabilities that SQL lacks. SQL is not a great fit for systems that actually satisfy the query because it does not provide sufficient detail and is not represented in a format that is easy for processing. Because of this, most modern systems will first translate the SQL query into a query plan, sometimes called the execution plan. There can be multiple levels of a query plan (e.g. physical and logical), a query plan may be split up and distributed across multiple systems, and a query plan often undergoes simplifying or optimizing transformations. The SQL standard does not define the format of the query or execution plan and there is no open format that is supported by a broad set of systems. Substrait was created to provide a standard and open format for these query plans.","title":"Why not use SQL?"},{"location":"#why-not-just-do-this-within-an-existing-oss-project","text":"A key goal of the Substrait project is to not be coupled to any single existing technology. Trying to get people involved in something can be difficult when it seems to be primarily driven by the opinions and habits of a single community. In many ways, this situation is similar to the early situation with Arrow. The precursor to Arrow was the Apache Drill ValueVectors concepts. As part of creating Arrow, Wes and Jacques recognized the need to create a new community to build a fresh consensus (beyond just what the Apache Drill community wanted). This separation and new independent community was a key ingredient to Arrow\u2019s current success. The needs here are much the same: many separate communities could benefit from Substrait, but each have their own pain points, type systems, development processes and timelines. To help resolve these tensions, one of the approaches proposed in Substrait is to set a bar that at least two of the top four OSS data technologies (Arrow, Spark, Iceberg, Trino) supports something before incorporating it directly into the Substrait specification. (Another goal is to support strong extension points at key locations to avoid this bar being a limiter to broad adoption.)","title":"Why not just do this within an existing OSS project?"},{"location":"#why-the-name-substrait","text":"A strait is a narrow connector of water between two other pieces of water. In analytics, data is often thought of as water. Substrait is focused on instructions related to the data. In other words, what defines or supports the movement of water between one or more larger systems. Thus, the underlayment for the strait connecting different pools of water => sub-strait.","title":"Why the name Substrait?"},{"location":"community/","text":"Community \u00b6 Substrait is developed as a consensus-driven open source product under the Apache 2.0 license. Development is done in the open leveraging GitHub issues and PRs. Get In Touch \u00b6 Mailing List/Google Group We use the mailing list to discuss questions, formulate plans and collaborate asynchronously. Slack Channel The developers of Substrait frequent the Slack channel. You can get an invite to the channel by following this link . GitHub Issues Substrait is developed via GitHub issues and pull requests. If you see a problem or want to enhance the product, we suggest you file a GitHub issue for developers to review. Twitter The @substrait_io account on Twitter is our official account. Follow-up to keep to date on what is happening with Substrait! Docs Our website is all maintained in our source repository. If there is something you think can be improved, feel free to fork our repository and post a pull request. Talks \u00b6 Want to learn more about Substrait? Try the following presentations and slide decks. Substrait: A Common Representation for Data Compute Plans (Jacques Nadeau, April 2022) [ slides ] Contribution \u00b6 All contributors are welcome to Substrait.","title":"Community"},{"location":"community/#community","text":"Substrait is developed as a consensus-driven open source product under the Apache 2.0 license. Development is done in the open leveraging GitHub issues and PRs.","title":"Community"},{"location":"community/#get-in-touch","text":"Mailing List/Google Group We use the mailing list to discuss questions, formulate plans and collaborate asynchronously. Slack Channel The developers of Substrait frequent the Slack channel. You can get an invite to the channel by following this link . GitHub Issues Substrait is developed via GitHub issues and pull requests. If you see a problem or want to enhance the product, we suggest you file a GitHub issue for developers to review. Twitter The @substrait_io account on Twitter is our official account. Follow-up to keep to date on what is happening with Substrait! Docs Our website is all maintained in our source repository. If there is something you think can be improved, feel free to fork our repository and post a pull request.","title":"Get In Touch"},{"location":"community/#talks","text":"Want to learn more about Substrait? Try the following presentations and slide decks. Substrait: A Common Representation for Data Compute Plans (Jacques Nadeau, April 2022) [ slides ]","title":"Talks"},{"location":"community/#contribution","text":"All contributors are welcome to Substrait.","title":"Contribution"},{"location":"expressions/aggregate_functions/","text":"Aggregate Functions \u00b6 Aggregate functions are functions that define an operation which consumes values from multiple records to a produce a single output. Aggregate functions in SQL are typically used in GROUP BY functions. Aggregate functions are similar to scalar functions and function signatures with a small set of different properties. Aggregate function signatures contain all the properties defined for scalar functions . Additionally, they contain the properties below: Property Description Required Inherits All properties defined for scalar function. N/A Ordered Whether the result of this function is sensitive to sort order. Optional, defaults to false Maximum set size Maximum allowed set size as an unsigned integer. Optional, defaults to unlimited Decomposable Whether the function can be executed in one or more intermediate steps. Valid options are: NONE , ONE , MANY , describing how intermediate steps can be taken. Optional, defaults to NONE Intermediate Output Type If the function is decomposable, represents the intermediate output type that is used, if the function is defined as either ONE or MANY decomposable. Will be a struct in many cases. Required for ONE and MANY . Invocation Whether the function uses all or only distinct values in the aggregation calculation. Valid options are: ALL , DISTINCT . Optional, defaults to ALL Aggregate Binding \u00b6 When binding an aggregate function, the binding must include the following additional properties beyond the standard scalar binding properties: Property Description Phase Describes the input type of the data: [INITIAL_TO_INTERMEDIATE, INTERMEDIATE_TO_INTERMEDIATE, INITIAL_TO_RESULT, INTERMEDIATE_TO_RESULT] describing what portion of the operation is required. For functions that are NOT decomposable, the only valid option will be INITIAL_TO_RESULT. Ordering Zero or more ordering keys along with key order (ASC|DESC|NULL FIRST, etc.), declared similar to the sort keys in an ORDER BY relational operation. If no sorts are specified, the records are not sorted prior to being passed to the aggregate function.","title":"Aggregate Functions"},{"location":"expressions/aggregate_functions/#aggregate-functions","text":"Aggregate functions are functions that define an operation which consumes values from multiple records to a produce a single output. Aggregate functions in SQL are typically used in GROUP BY functions. Aggregate functions are similar to scalar functions and function signatures with a small set of different properties. Aggregate function signatures contain all the properties defined for scalar functions . Additionally, they contain the properties below: Property Description Required Inherits All properties defined for scalar function. N/A Ordered Whether the result of this function is sensitive to sort order. Optional, defaults to false Maximum set size Maximum allowed set size as an unsigned integer. Optional, defaults to unlimited Decomposable Whether the function can be executed in one or more intermediate steps. Valid options are: NONE , ONE , MANY , describing how intermediate steps can be taken. Optional, defaults to NONE Intermediate Output Type If the function is decomposable, represents the intermediate output type that is used, if the function is defined as either ONE or MANY decomposable. Will be a struct in many cases. Required for ONE and MANY . Invocation Whether the function uses all or only distinct values in the aggregation calculation. Valid options are: ALL , DISTINCT . Optional, defaults to ALL","title":"Aggregate Functions"},{"location":"expressions/aggregate_functions/#aggregate-binding","text":"When binding an aggregate function, the binding must include the following additional properties beyond the standard scalar binding properties: Property Description Phase Describes the input type of the data: [INITIAL_TO_INTERMEDIATE, INTERMEDIATE_TO_INTERMEDIATE, INITIAL_TO_RESULT, INTERMEDIATE_TO_RESULT] describing what portion of the operation is required. For functions that are NOT decomposable, the only valid option will be INITIAL_TO_RESULT. Ordering Zero or more ordering keys along with key order (ASC|DESC|NULL FIRST, etc.), declared similar to the sort keys in an ORDER BY relational operation. If no sorts are specified, the records are not sorted prior to being passed to the aggregate function.","title":"Aggregate Binding"},{"location":"expressions/embedded_functions/","text":"Embedded Functions \u00b6 Embedded functions are a special kind of function where the implementation is embedded within the actual plan. They are commonly used in tools where a user intersperses business logic within a data pipeline. This is more common in data science workflows than traditional SQL workflows. Embedded functions are not pre-registered. Embedded functions require that data be consumed and produced with a standard API, may require memory allocation and have determinate error reporting behavior. They may also have specific runtime dependencies. For example, a Python pickle function may depend on pyarrow 5.0 and pynessie 1.0. Properties for an embedded function include: Property Description Required Function Type The type of embedded function presented. Required Function Properties Function properties, one of those items defined below. Required Output Type The fully resolved output type for this embedded function. Required The binary representation of an embedded function is: Binary Representation message EmbeddedFunction { repeated Expression arguments = 1 ; Type output_type = 2 ; oneof kind { PythonPickleFunction python_pickle_function = 3 ; WebAssemblyFunction web_assembly_function = 4 ; } message PythonPickleFunction { bytes function = 1 ; repeated string prerequisite = 2 ; } message WebAssemblyFunction { bytes script = 1 ; repeated string prerequisite = 2 ; } } Human Readable Representation n/a Example n/a Function Details \u00b6 There are many types of possible stored functions. For each, Substrait works to expose the function in as descriptive a way as possible to support the largest number of consumers. Python Pickle Function Type \u00b6 Property Description Required Pickle Body binary pickle encoded function using [TBD] API representation to access arguments. True Prereqs A list of specific Python conda packages that are prerequisites for access (a structured version of a requirements.txt file). Optional, defaults to none WebAssembly Function Type \u00b6 Property Description Required Script WebAssembly function True Prereqs A list of AssemblyScript prerequisites required to compile the assemblyscript function using NPM coordinates. Optional, defaults to none Discussion Points \u00b6 What are the common embedded function formats? How do we expose the data for a function? How do we express batching capabilities? How do we ensure/declare containerization?","title":"Embedded Functions"},{"location":"expressions/embedded_functions/#embedded-functions","text":"Embedded functions are a special kind of function where the implementation is embedded within the actual plan. They are commonly used in tools where a user intersperses business logic within a data pipeline. This is more common in data science workflows than traditional SQL workflows. Embedded functions are not pre-registered. Embedded functions require that data be consumed and produced with a standard API, may require memory allocation and have determinate error reporting behavior. They may also have specific runtime dependencies. For example, a Python pickle function may depend on pyarrow 5.0 and pynessie 1.0. Properties for an embedded function include: Property Description Required Function Type The type of embedded function presented. Required Function Properties Function properties, one of those items defined below. Required Output Type The fully resolved output type for this embedded function. Required The binary representation of an embedded function is: Binary Representation message EmbeddedFunction { repeated Expression arguments = 1 ; Type output_type = 2 ; oneof kind { PythonPickleFunction python_pickle_function = 3 ; WebAssemblyFunction web_assembly_function = 4 ; } message PythonPickleFunction { bytes function = 1 ; repeated string prerequisite = 2 ; } message WebAssemblyFunction { bytes script = 1 ; repeated string prerequisite = 2 ; } } Human Readable Representation n/a Example n/a","title":"Embedded Functions"},{"location":"expressions/embedded_functions/#function-details","text":"There are many types of possible stored functions. For each, Substrait works to expose the function in as descriptive a way as possible to support the largest number of consumers.","title":"Function Details"},{"location":"expressions/embedded_functions/#python-pickle-function-type","text":"Property Description Required Pickle Body binary pickle encoded function using [TBD] API representation to access arguments. True Prereqs A list of specific Python conda packages that are prerequisites for access (a structured version of a requirements.txt file). Optional, defaults to none","title":"Python Pickle Function Type"},{"location":"expressions/embedded_functions/#webassembly-function-type","text":"Property Description Required Script WebAssembly function True Prereqs A list of AssemblyScript prerequisites required to compile the assemblyscript function using NPM coordinates. Optional, defaults to none","title":"WebAssembly Function Type"},{"location":"expressions/embedded_functions/#discussion-points","text":"What are the common embedded function formats? How do we expose the data for a function? How do we express batching capabilities? How do we ensure/declare containerization?","title":"Discussion Points"},{"location":"expressions/field_references/","text":"Field References \u00b6 In Substrait, all fields are dealt with on a positional basis. Field names are only used at the edge of a plan, for the purposes of naming fields for the outside world. Each operation returns a simple or compound data type. Additional operations can refer to data within that initial operation using field references. To reference a field, you use a reference based on the type of field position you want to reference. Reference Type Properties Type Applicability Type return Struct Field Ordinal position. Zero-based. Only legal within the range of possible fields within a struct. Selecting an ordinal outside the applicable field range results in an invalid plan. struct Type of field referenced Array Value Array offset. Zero-based. Negative numbers can be used to describe an offset relative to the end of the array. For example, -1 means the last element in an array. Negative and positive overflows return null values (no wrapping). list type of list Array Slice Array offset and element count. Zero-based. Negative numbers can be used to describe an offset relative to the end of the array. For example, -1 means the last element in an array. Position does not wrap, nor does length. list Same type as original list Map Key A map value that is matched exactly against available map keys and returned. [TBD, can multiple matches occur?] map Value type of map Map KeyExpression A wildcard string that is matched against a simplified form of regular expressions. Requires the key type of the map to be a character type. [Format detail needed, intention to include basic regex concepts such as greedy/non-greedy.] map List of map value type Masked Complex Expression An expression that provides a mask over a schema declaring which portions of the schema should be presented. This allows a user to select a portion of a complex object but mask certain subsections of that same object. any any Compound References \u00b6 References are typically constructed as a sequence. For example: [struct position 0, struct position 1, array offset 2, array slice 1..3]. Validation \u00b6 References must validate against the schema of the record being referenced. If not, an error is expected. Masked Complex Expression \u00b6 A masked complex expression is used to do a subselection of a portion of a complex record. It allows a user to specify the portion of the complex object to consume. Imagine you have a schema of (note that structs are lists of fields here, as they are in general in Substrait as field names are not used internally in Substrait): struct: - struct: - integer - list: struct: - i32 - string - string - i32 - i16 - i32 - i64 Given this schema, you could declare a mask in pseudocode, such as: 0:[0,1:[..5:[0,2]]],2,3 OR 0: - 0 - 1: ..5: -0 -2 2 3 This mask states that we would like to include fields 0 2 and 3 at the top-level. Within field 0, we want to include subfields 0 and 1. For subfield 0.1, we want to include up to only the first 5 records in the array and only includes fields 0 and 2 within the struct within that array. The resulting schema would be: struct: - struct: - integer - list: struct: - i32 - string - i32 - i64 Unwrapping Behavior \u00b6 By default, when only a single field is selected from a struct, that struct is removed. When only a single element is removed from a list, the list is removed. A user can also configure the mask to avoid unwrapping in these cases. [TBD how we express this in the serialization formats.] Discussion Points \u00b6 Should we support column reordering/positioning using a masked complex expression? (Right now, you can only mask things out.)","title":"Field References"},{"location":"expressions/field_references/#field-references","text":"In Substrait, all fields are dealt with on a positional basis. Field names are only used at the edge of a plan, for the purposes of naming fields for the outside world. Each operation returns a simple or compound data type. Additional operations can refer to data within that initial operation using field references. To reference a field, you use a reference based on the type of field position you want to reference. Reference Type Properties Type Applicability Type return Struct Field Ordinal position. Zero-based. Only legal within the range of possible fields within a struct. Selecting an ordinal outside the applicable field range results in an invalid plan. struct Type of field referenced Array Value Array offset. Zero-based. Negative numbers can be used to describe an offset relative to the end of the array. For example, -1 means the last element in an array. Negative and positive overflows return null values (no wrapping). list type of list Array Slice Array offset and element count. Zero-based. Negative numbers can be used to describe an offset relative to the end of the array. For example, -1 means the last element in an array. Position does not wrap, nor does length. list Same type as original list Map Key A map value that is matched exactly against available map keys and returned. [TBD, can multiple matches occur?] map Value type of map Map KeyExpression A wildcard string that is matched against a simplified form of regular expressions. Requires the key type of the map to be a character type. [Format detail needed, intention to include basic regex concepts such as greedy/non-greedy.] map List of map value type Masked Complex Expression An expression that provides a mask over a schema declaring which portions of the schema should be presented. This allows a user to select a portion of a complex object but mask certain subsections of that same object. any any","title":"Field References"},{"location":"expressions/field_references/#compound-references","text":"References are typically constructed as a sequence. For example: [struct position 0, struct position 1, array offset 2, array slice 1..3].","title":"Compound References"},{"location":"expressions/field_references/#validation","text":"References must validate against the schema of the record being referenced. If not, an error is expected.","title":"Validation"},{"location":"expressions/field_references/#masked-complex-expression","text":"A masked complex expression is used to do a subselection of a portion of a complex record. It allows a user to specify the portion of the complex object to consume. Imagine you have a schema of (note that structs are lists of fields here, as they are in general in Substrait as field names are not used internally in Substrait): struct: - struct: - integer - list: struct: - i32 - string - string - i32 - i16 - i32 - i64 Given this schema, you could declare a mask in pseudocode, such as: 0:[0,1:[..5:[0,2]]],2,3 OR 0: - 0 - 1: ..5: -0 -2 2 3 This mask states that we would like to include fields 0 2 and 3 at the top-level. Within field 0, we want to include subfields 0 and 1. For subfield 0.1, we want to include up to only the first 5 records in the array and only includes fields 0 and 2 within the struct within that array. The resulting schema would be: struct: - struct: - integer - list: struct: - i32 - string - i32 - i64","title":"Masked Complex Expression"},{"location":"expressions/field_references/#unwrapping-behavior","text":"By default, when only a single field is selected from a struct, that struct is removed. When only a single element is removed from a list, the list is removed. A user can also configure the mask to avoid unwrapping in these cases. [TBD how we express this in the serialization formats.]","title":"Unwrapping Behavior"},{"location":"expressions/field_references/#discussion-points","text":"Should we support column reordering/positioning using a masked complex expression? (Right now, you can only mask things out.)","title":"Discussion Points"},{"location":"expressions/scalar_functions/","text":"Scalar Functions \u00b6 A function is a scalar function if that function takes in values from a single record and produces an output value. To clearly specify the definition of functions, Substrait declares an extensible specification plus binding approach to function resolution. A scalar function signature includes the following properties: Property Description Required Name One or more user-friendly UTF-8 strings that are used to reference this function. At least one value is required. List of arguments Argument properties are defined below. Arguments can be fully defined or calculated with a type expression. See further details below. Optional, defaults to niladic. Deterministic Whether this function is expected to reproduce the same output when it is invoked multiple times with the same input. This informs a plan consumer on whether it can constant-reduce the defined function. An example would be a random() function, which is typically expected to be evaluated repeatedly despite having the same set of inputs. Optional, defaults to true. Session Dependent Whether this function is influenced by the session context it is invoked within. For example, a function may be influenced by a user who is invoking the function, the time zone of a session, or some other non-obvious parameter. This can inform caching systems on whether a particular function is cacheable. Optional, defaults to false. Variadic Behavior Whether the last argument of the function is variadic or a single argument. If variadic, the argument can optionally have a lower bound (minimum number of instances) and an upper bound (maximum number of instances). Optional, defaults to single value. Nullability Handling Describes how nullability of input arguments maps to nullability of output arguments. Three options are: MIRROR , DECLARED_OUTPUT and DISCRETE . More details about nullability handling are listed below. Optional, defaults to MIRROR Description Additional description of function for implementers or users. Should be written human-readable to allow exposure to end users. Presented as a map with language => description mappings. E.g. { \"en\": \"This adds two numbers together.\", \"fr\": \"cela ajoute deux nombres\"} . Optional Return Value The output type of the expression. Return types can be expressed as a fully-defined type or a type expression. See below for more on type expressions. Required Implementation Map A map of implementation locations for one or more implementations of the given function. Each key is a function implementation type. Implementation types include examples such as: AthenaArrowLambda, TrinoV361Jar, ArrowCppKernelEnum, GandivaEnum, LinkedIn Transport Jar, etc. [Definition TBD]. Implementation type has one or more properties associated with retrieval of that implementation. Optional Argument Types \u00b6 There are four main types of arguments: value arguments, type arguments, required enumerations, and optional enumerations. Value arguments: arguments that refer to a data value. These could be constants (literal expressions defined in the plan) or variables (a reference expression that references data being processed by the plan). This is the most common type of argument. The value of a value argument is not available in output derivation, but its type is. Value arguments can be declared in one of two ways: concrete or parameterized. Concrete types are either simple types or compound types with all parameters fully defined (without referencing any type arguments). Examples include i32 , fp32 , VARCHAR<20> , List<fp32> , etc. Parameterized types are discussed further below. Type arguments: arguments that are used only to inform the evaluation and/or type derivation of the function. For example, you might have a function which is truncate(<type> DECIMAL<P0,S0>, <value> DECIMAL<P1, S1>, <value> i32) . This function declares two value arguments and a type argument. The difference between them is that the type argument has no value at runtime, while the value arguments do. Required enumeration: arguments that support a fixed set of declared values as constant arguments. These arguments must be specified as part of an expression. While these could also have been implemented as constant string value arguments, they are formally included to improve validation/contextual help/etc. for frontend processors and IDEs. An example might use might be extract([DAY|YEAR|MONTH], <date value>) . In this example, a producer must specify a type of date part to extract. Note, the value of a required enumeration cannot be used in type derivation. Optional enumeration: similar to required enumeration, but more focused on supporting alternative behaviors. An optional enumeration always includes an \u201cunspecified\u201d default option that can be bound based on the capabilities of the plan consumer. When a plan does not specify a behavior, the consumer is expected to resolve the option based on the first option the system can match. An example use case might be OVERFLOW_BEHAVIOR:[OVERFLOW, SATURATE, ERROR] If unspecified, an engine would use the first of these that it implements. If specified, the engine would be expected to behave as specified or fail. Note, the value of an optional enumeration cannot be used in type derivation. Value Argument Properties \u00b6 Property Description Required Name A human-readable name for this argument to help clarify use. Optional, defaults to a name based on position (e.g. arg0 ) Type A fully defined type or a type expression. Required Constant Whether this argument is required to be a constant for invocation. For example, in some system a regular expression pattern would only be accepted as a literal and not a column value reference. Optional, defaults to false Type Argument Properties \u00b6 Property Description Required Type A partially or completely parameterized type. E.g. List<K> or K Required Name A human-readable name for this argument to help clarify use. Optional, defaults to a name based on position (e.g. arg0 ) Required Enumeration Properties \u00b6 Property Description Required Options List of valid string options for this argument Required Name A human-readable name for this argument to help clarify use. Optional, defaults to a name based on position (e.g. arg0 ) Optional Enumeration Properties \u00b6 Property Description Required Options Priority-ordered list of valid string options for this argument. The pseudo-option will be the default \u201cvalue\u201d for the enumeration unless a binding specifies a specific value. Required Name A human-readable name for this argument to help clarify use. Optional, defaults to a name based on position (e.g. arg0 ) Nullability Handling \u00b6 Mode Description MIRROR This means that the function has the behavior that if at least one of the input arguments are nullable, the return type is also nullable. If all arguments are non-nullable, the return type will be non-nullable. An example might be the + function. DECLARED_OUTPUT Input arguments are accepted of any mix of nullability. The nullability of the output function is whatever the return type expression states. Example use might be the function is_null() where the output is always boolean independent of the nullability of the input. DISCRETE The input and arguments all define concrete nullability and can only be bound to the types that have those nullability. For example, if a type input is declared i64? and one has an i64 literal, the i64 literal must be specifically cast to i64? to allow the operation to bind. Parameterized Types \u00b6 Types are parameterized by two types of values: by inner types (e.g. List<K> ) and numeric values (e.g. DECIMAL<P,S> ). Parameter names are simple strings (frequently a single character). There are two types of parameters: integer parameters and type parameters. When the same parameter name is used multiple times in a function definition, the function can only bind if the exact same value is used for all parameters of that name. For example, if one had a function with a signature of fn(VARCHAR<N>, VARCHAR<N>) , the function would be only be usable if both VARCHAR types had the same length value N . This necessitates that all instances of the same parameter name must be of the same parameter type (all instances are a type parameter or all instances are an integer parameter). Type Parameter Resolution in Variadic Functions \u00b6 When the last argument of a function is variadic and declares a type parameter e.g. fn(A, B, C...) , the C parameter can be marked as either consistent or inconsistent. If marked as consistent, the function can only be bound to arguments where all the C types are the same concrete type. If marked as inconsistent, each unique C can be bound to a different type within the constraints of what T allows. Output Type Derivation \u00b6 Concrete Return Types \u00b6 A concrete return type is one that is fully known at function definition time. Example simple concrete return types would be things such as i32 , fp32 . For compound types, a concrete return type must be fully declared. Example of fully defined compound types: VARCHAR<20> , DECIMAL<25,5> Return Type Expressions \u00b6 Any function can declare a return type expression. A return type expression uses a simplified set of expressions to describe how the return type should be returned. For example, a return expression could be as simple as the return of parameter declared in the arguments. For example f(List<K>) => K or can be a simple mathematical or conditional expression such as add(decimal<a,b>, decimal<c,d>) => decimal<a+c, b+d> . For the simple expression language, there is a very narrow set of types: Integer: 64-bit signed integer (can be a literal or a parameter value) Boolean: True and False Type: A Substrait type (with possibly additional embedded expressions) These types are evaluated using a small set of operations to support common scenarios. List of valid operations: Math: +, -, *, /, min, max Boolean: &&, ||, !, <, >, == Parameters: type, integer Literals: type, integer Fully defined with argument types: type_parameter(string name) => type integer_parameter(string name) => integer not(boolean x) => boolean and(boolean a, boolean b) => boolean or(boolean a, boolean b) => boolean multiply(integer a, integer b) => integer divide(integer a, integer b) => integer add(integer a, integer b) => integer subtract(integer a, integer b) => integer min(integer a, integer b) => integer max(integer a, integer b) => integer equal(integer a, integer b) => boolean greater_than(integer a, integer b) => boolean less_than(integer a, integer b) => boolean covers(Type a, Type b) => boolean Covers means that type b matches type A for as much as type B is defined. For example, if type A is VARCHAR<20> and type B is VARCHAR<N> , type B would be considered covering. Similarlily if type A was List<Struct<a:f32, b:f32>> and type B was List<Struct<>> , it would be considered covering. Note that this is directional \u201cas in B covers A\u201d or \u201cB can be further enhanced to match the definition A\u201d. if(boolean a) then (integer) else (integer) if(boolean a) then (type) else (type) Example Type Expressions \u00b6 For reference, here are are some common output type derivations and how they can be expressed with a return type expression: Operation Definition Add item to list add(<List<T>, T>) => List<T> Decimal Division divide(Decimal<P1,S1>, Decimal<P2,S2>) => Decimal<P1 -S1 + S2 + MAX(6, S1 + P2 + 1), MAX(6, S1 + P2 + 1)> Select a subset of map keys based on a regular expression (requires stringlike keys) extract_values(regex:string, map:Map<K,V>) => List<V> WHERE K IN [STRING, VARCHAR<N>, FIXEDCHAR<N>] Concatenate two fixed sized character strings concat(FIXEDCHAR<A>, FIXEDCHAR<B>) => FIXEDCHAR<A+B> Make a struct of a set of fields and a struct definition. make_struct(<type> T, K...) => T","title":"Scalar Functions"},{"location":"expressions/scalar_functions/#scalar-functions","text":"A function is a scalar function if that function takes in values from a single record and produces an output value. To clearly specify the definition of functions, Substrait declares an extensible specification plus binding approach to function resolution. A scalar function signature includes the following properties: Property Description Required Name One or more user-friendly UTF-8 strings that are used to reference this function. At least one value is required. List of arguments Argument properties are defined below. Arguments can be fully defined or calculated with a type expression. See further details below. Optional, defaults to niladic. Deterministic Whether this function is expected to reproduce the same output when it is invoked multiple times with the same input. This informs a plan consumer on whether it can constant-reduce the defined function. An example would be a random() function, which is typically expected to be evaluated repeatedly despite having the same set of inputs. Optional, defaults to true. Session Dependent Whether this function is influenced by the session context it is invoked within. For example, a function may be influenced by a user who is invoking the function, the time zone of a session, or some other non-obvious parameter. This can inform caching systems on whether a particular function is cacheable. Optional, defaults to false. Variadic Behavior Whether the last argument of the function is variadic or a single argument. If variadic, the argument can optionally have a lower bound (minimum number of instances) and an upper bound (maximum number of instances). Optional, defaults to single value. Nullability Handling Describes how nullability of input arguments maps to nullability of output arguments. Three options are: MIRROR , DECLARED_OUTPUT and DISCRETE . More details about nullability handling are listed below. Optional, defaults to MIRROR Description Additional description of function for implementers or users. Should be written human-readable to allow exposure to end users. Presented as a map with language => description mappings. E.g. { \"en\": \"This adds two numbers together.\", \"fr\": \"cela ajoute deux nombres\"} . Optional Return Value The output type of the expression. Return types can be expressed as a fully-defined type or a type expression. See below for more on type expressions. Required Implementation Map A map of implementation locations for one or more implementations of the given function. Each key is a function implementation type. Implementation types include examples such as: AthenaArrowLambda, TrinoV361Jar, ArrowCppKernelEnum, GandivaEnum, LinkedIn Transport Jar, etc. [Definition TBD]. Implementation type has one or more properties associated with retrieval of that implementation. Optional","title":"Scalar Functions"},{"location":"expressions/scalar_functions/#argument-types","text":"There are four main types of arguments: value arguments, type arguments, required enumerations, and optional enumerations. Value arguments: arguments that refer to a data value. These could be constants (literal expressions defined in the plan) or variables (a reference expression that references data being processed by the plan). This is the most common type of argument. The value of a value argument is not available in output derivation, but its type is. Value arguments can be declared in one of two ways: concrete or parameterized. Concrete types are either simple types or compound types with all parameters fully defined (without referencing any type arguments). Examples include i32 , fp32 , VARCHAR<20> , List<fp32> , etc. Parameterized types are discussed further below. Type arguments: arguments that are used only to inform the evaluation and/or type derivation of the function. For example, you might have a function which is truncate(<type> DECIMAL<P0,S0>, <value> DECIMAL<P1, S1>, <value> i32) . This function declares two value arguments and a type argument. The difference between them is that the type argument has no value at runtime, while the value arguments do. Required enumeration: arguments that support a fixed set of declared values as constant arguments. These arguments must be specified as part of an expression. While these could also have been implemented as constant string value arguments, they are formally included to improve validation/contextual help/etc. for frontend processors and IDEs. An example might use might be extract([DAY|YEAR|MONTH], <date value>) . In this example, a producer must specify a type of date part to extract. Note, the value of a required enumeration cannot be used in type derivation. Optional enumeration: similar to required enumeration, but more focused on supporting alternative behaviors. An optional enumeration always includes an \u201cunspecified\u201d default option that can be bound based on the capabilities of the plan consumer. When a plan does not specify a behavior, the consumer is expected to resolve the option based on the first option the system can match. An example use case might be OVERFLOW_BEHAVIOR:[OVERFLOW, SATURATE, ERROR] If unspecified, an engine would use the first of these that it implements. If specified, the engine would be expected to behave as specified or fail. Note, the value of an optional enumeration cannot be used in type derivation.","title":"Argument Types"},{"location":"expressions/scalar_functions/#value-argument-properties","text":"Property Description Required Name A human-readable name for this argument to help clarify use. Optional, defaults to a name based on position (e.g. arg0 ) Type A fully defined type or a type expression. Required Constant Whether this argument is required to be a constant for invocation. For example, in some system a regular expression pattern would only be accepted as a literal and not a column value reference. Optional, defaults to false","title":"Value Argument Properties"},{"location":"expressions/scalar_functions/#type-argument-properties","text":"Property Description Required Type A partially or completely parameterized type. E.g. List<K> or K Required Name A human-readable name for this argument to help clarify use. Optional, defaults to a name based on position (e.g. arg0 )","title":"Type Argument Properties"},{"location":"expressions/scalar_functions/#required-enumeration-properties","text":"Property Description Required Options List of valid string options for this argument Required Name A human-readable name for this argument to help clarify use. Optional, defaults to a name based on position (e.g. arg0 )","title":"Required Enumeration Properties"},{"location":"expressions/scalar_functions/#optional-enumeration-properties","text":"Property Description Required Options Priority-ordered list of valid string options for this argument. The pseudo-option will be the default \u201cvalue\u201d for the enumeration unless a binding specifies a specific value. Required Name A human-readable name for this argument to help clarify use. Optional, defaults to a name based on position (e.g. arg0 )","title":"Optional Enumeration Properties"},{"location":"expressions/scalar_functions/#nullability-handling","text":"Mode Description MIRROR This means that the function has the behavior that if at least one of the input arguments are nullable, the return type is also nullable. If all arguments are non-nullable, the return type will be non-nullable. An example might be the + function. DECLARED_OUTPUT Input arguments are accepted of any mix of nullability. The nullability of the output function is whatever the return type expression states. Example use might be the function is_null() where the output is always boolean independent of the nullability of the input. DISCRETE The input and arguments all define concrete nullability and can only be bound to the types that have those nullability. For example, if a type input is declared i64? and one has an i64 literal, the i64 literal must be specifically cast to i64? to allow the operation to bind.","title":"Nullability Handling"},{"location":"expressions/scalar_functions/#parameterized-types","text":"Types are parameterized by two types of values: by inner types (e.g. List<K> ) and numeric values (e.g. DECIMAL<P,S> ). Parameter names are simple strings (frequently a single character). There are two types of parameters: integer parameters and type parameters. When the same parameter name is used multiple times in a function definition, the function can only bind if the exact same value is used for all parameters of that name. For example, if one had a function with a signature of fn(VARCHAR<N>, VARCHAR<N>) , the function would be only be usable if both VARCHAR types had the same length value N . This necessitates that all instances of the same parameter name must be of the same parameter type (all instances are a type parameter or all instances are an integer parameter).","title":"Parameterized Types"},{"location":"expressions/scalar_functions/#type-parameter-resolution-in-variadic-functions","text":"When the last argument of a function is variadic and declares a type parameter e.g. fn(A, B, C...) , the C parameter can be marked as either consistent or inconsistent. If marked as consistent, the function can only be bound to arguments where all the C types are the same concrete type. If marked as inconsistent, each unique C can be bound to a different type within the constraints of what T allows.","title":"Type Parameter Resolution in Variadic Functions"},{"location":"expressions/scalar_functions/#output-type-derivation","text":"","title":"Output Type Derivation"},{"location":"expressions/scalar_functions/#concrete-return-types","text":"A concrete return type is one that is fully known at function definition time. Example simple concrete return types would be things such as i32 , fp32 . For compound types, a concrete return type must be fully declared. Example of fully defined compound types: VARCHAR<20> , DECIMAL<25,5>","title":"Concrete Return Types"},{"location":"expressions/scalar_functions/#return-type-expressions","text":"Any function can declare a return type expression. A return type expression uses a simplified set of expressions to describe how the return type should be returned. For example, a return expression could be as simple as the return of parameter declared in the arguments. For example f(List<K>) => K or can be a simple mathematical or conditional expression such as add(decimal<a,b>, decimal<c,d>) => decimal<a+c, b+d> . For the simple expression language, there is a very narrow set of types: Integer: 64-bit signed integer (can be a literal or a parameter value) Boolean: True and False Type: A Substrait type (with possibly additional embedded expressions) These types are evaluated using a small set of operations to support common scenarios. List of valid operations: Math: +, -, *, /, min, max Boolean: &&, ||, !, <, >, == Parameters: type, integer Literals: type, integer Fully defined with argument types: type_parameter(string name) => type integer_parameter(string name) => integer not(boolean x) => boolean and(boolean a, boolean b) => boolean or(boolean a, boolean b) => boolean multiply(integer a, integer b) => integer divide(integer a, integer b) => integer add(integer a, integer b) => integer subtract(integer a, integer b) => integer min(integer a, integer b) => integer max(integer a, integer b) => integer equal(integer a, integer b) => boolean greater_than(integer a, integer b) => boolean less_than(integer a, integer b) => boolean covers(Type a, Type b) => boolean Covers means that type b matches type A for as much as type B is defined. For example, if type A is VARCHAR<20> and type B is VARCHAR<N> , type B would be considered covering. Similarlily if type A was List<Struct<a:f32, b:f32>> and type B was List<Struct<>> , it would be considered covering. Note that this is directional \u201cas in B covers A\u201d or \u201cB can be further enhanced to match the definition A\u201d. if(boolean a) then (integer) else (integer) if(boolean a) then (type) else (type)","title":"Return Type Expressions"},{"location":"expressions/scalar_functions/#example-type-expressions","text":"For reference, here are are some common output type derivations and how they can be expressed with a return type expression: Operation Definition Add item to list add(<List<T>, T>) => List<T> Decimal Division divide(Decimal<P1,S1>, Decimal<P2,S2>) => Decimal<P1 -S1 + S2 + MAX(6, S1 + P2 + 1), MAX(6, S1 + P2 + 1)> Select a subset of map keys based on a regular expression (requires stringlike keys) extract_values(regex:string, map:Map<K,V>) => List<V> WHERE K IN [STRING, VARCHAR<N>, FIXEDCHAR<N>] Concatenate two fixed sized character strings concat(FIXEDCHAR<A>, FIXEDCHAR<B>) => FIXEDCHAR<A+B> Make a struct of a set of fields and a struct definition. make_struct(<type> T, K...) => T","title":"Example Type Expressions"},{"location":"expressions/specialized_record_expressions/","text":"Specialized Record Expressions \u00b6 While all types of operations could be reduced to functions, in some cases this would be overly simplistic. Instead, it is helpful to construct some other expression constructs. These constructs should be focused on different expression types as opposed to something that directly related to syntactic sugar. For example, CAST and EXTRACT or SQL operations that are presented using specialized syntax. However, they can easily be modeled using a function paradigm with minimal complexity. Literal Expressions \u00b6 For each data type, it is possible to create a literal value for that data type. The representation depends on the serialization format. Literal expressions include both a type literal and a possibly null value. Cast Expression \u00b6 To convert a value from one type to another, Substrait defines a cast expression. Cast expressions declare an expected type, an input argument and an enumeration specifying failure behavior, indicating whether cast should return null on failure or throw an exception. Note that Substrait always requires a cast expression whenever the current type is not exactly equal to (one of) the expected types. For example, it is illegal to directly pass a value of type i8[0] to a function that only supports an i8?[0] argument, some other variation of i8 , or i16[0] . If Expression \u00b6 An if value expression is an expression composed of one if clause, zero or more else if clauses and an else clause. In pseudocode, they are envisioned as: if <boolean expression> then <result expression 1> else if <boolean expression> then <result expression 2> (zero or more times) else <result expression 3> When an if expression is declared, all return expressions must be the same identical type. Shortcut Behavior \u00b6 An if expression is expected to logically short-circuit on a positive outcome. This means that a skipped else/elseif expression cannot cause an error. For example, this should not actually throw an error despite the fact that the cast operation should fail. if 'value' = 'value' then 0 else cast('hello' as integer) Switch Expression \u00b6 Switch expression allow a selection of alternate branches based on the value of a given expression. They are an optimized form of a generic if expression where all conditions are equality to the same value. In pseudocode: switch(value) <value 1> => <return 1> (1 or more times) <else> => <return 3> Return values for a switch expression must all be of identical type. Shortcut Behavior \u00b6 As in if expressions, switch expression evaluation should not be interrupted by \u201croads not taken\u201d. Or List Equality Expression \u00b6 A specialized structure that is often used is a large list of possible values. In SQL, these are typically large IN lists. They can be composed from one or more fields. There are two common patterns, single value and multi value. In pseudocode they are represented as: Single Value: expression, [<value1>, <value2>, ... <valueN>] Multi Value: [expressionA, expressionB], [[value1a, value1b], [value2a, value2b].. [valueNa, valueNb]] For single value expressions, these are a compact equivalent of expression = value1 OR expression = value2 OR .. OR expression = valueN . When using an expression of this type, two things are required; the types of the test expression and all value expressions that are related must be of the same type. Additionally, a function signature for equality must be available for the expression type used.","title":"Specialized Record Expressions"},{"location":"expressions/specialized_record_expressions/#specialized-record-expressions","text":"While all types of operations could be reduced to functions, in some cases this would be overly simplistic. Instead, it is helpful to construct some other expression constructs. These constructs should be focused on different expression types as opposed to something that directly related to syntactic sugar. For example, CAST and EXTRACT or SQL operations that are presented using specialized syntax. However, they can easily be modeled using a function paradigm with minimal complexity.","title":"Specialized Record Expressions"},{"location":"expressions/specialized_record_expressions/#literal-expressions","text":"For each data type, it is possible to create a literal value for that data type. The representation depends on the serialization format. Literal expressions include both a type literal and a possibly null value.","title":"Literal Expressions"},{"location":"expressions/specialized_record_expressions/#cast-expression","text":"To convert a value from one type to another, Substrait defines a cast expression. Cast expressions declare an expected type, an input argument and an enumeration specifying failure behavior, indicating whether cast should return null on failure or throw an exception. Note that Substrait always requires a cast expression whenever the current type is not exactly equal to (one of) the expected types. For example, it is illegal to directly pass a value of type i8[0] to a function that only supports an i8?[0] argument, some other variation of i8 , or i16[0] .","title":"Cast Expression"},{"location":"expressions/specialized_record_expressions/#if-expression","text":"An if value expression is an expression composed of one if clause, zero or more else if clauses and an else clause. In pseudocode, they are envisioned as: if <boolean expression> then <result expression 1> else if <boolean expression> then <result expression 2> (zero or more times) else <result expression 3> When an if expression is declared, all return expressions must be the same identical type.","title":"If Expression"},{"location":"expressions/specialized_record_expressions/#shortcut-behavior","text":"An if expression is expected to logically short-circuit on a positive outcome. This means that a skipped else/elseif expression cannot cause an error. For example, this should not actually throw an error despite the fact that the cast operation should fail. if 'value' = 'value' then 0 else cast('hello' as integer)","title":"Shortcut Behavior"},{"location":"expressions/specialized_record_expressions/#switch-expression","text":"Switch expression allow a selection of alternate branches based on the value of a given expression. They are an optimized form of a generic if expression where all conditions are equality to the same value. In pseudocode: switch(value) <value 1> => <return 1> (1 or more times) <else> => <return 3> Return values for a switch expression must all be of identical type.","title":"Switch Expression"},{"location":"expressions/specialized_record_expressions/#shortcut-behavior_1","text":"As in if expressions, switch expression evaluation should not be interrupted by \u201croads not taken\u201d.","title":"Shortcut Behavior"},{"location":"expressions/specialized_record_expressions/#or-list-equality-expression","text":"A specialized structure that is often used is a large list of possible values. In SQL, these are typically large IN lists. They can be composed from one or more fields. There are two common patterns, single value and multi value. In pseudocode they are represented as: Single Value: expression, [<value1>, <value2>, ... <valueN>] Multi Value: [expressionA, expressionB], [[value1a, value1b], [value2a, value2b].. [valueNa, valueNb]] For single value expressions, these are a compact equivalent of expression = value1 OR expression = value2 OR .. OR expression = valueN . When using an expression of this type, two things are required; the types of the test expression and all value expressions that are related must be of the same type. Additionally, a function signature for equality must be available for the expression type used.","title":"Or List Equality Expression"},{"location":"expressions/subqueries/","text":"Subqueries \u00b6 Subqueries are scalar expressions comprised of another query. Forms \u00b6 Scalar \u00b6 Scalar subqueries are subqueries that return one row and one column. Property Description Required Input Input relation Yes IN predicate \u00b6 An IN subquery predicate checks that the left expression is contained in the right subquery. Examples \u00b6 SELECT * FROM t1 WHERE x IN ( SELECT * FROM t2 ) SELECT * FROM t1 WHERE ( x , y ) IN ( SELECT a , b FROM t2 ) Property Description Required Needles Expressions who existence will be checked Yes Haystack Subquery to check Yes Set predicates \u00b6 A set predicate is a predicate over a set of rows in the form of a subquery. EXISTS and UNIQUE are common SQL spellings of these kinds of predicates. Property Description Required Operation The operation to perform over the set Yes Tuples Set of tuples to check using the operation Yes Set comparisons \u00b6 A set comparison subquery is a subquery comparison using ANY or ALL operations. Examples \u00b6 SELECT * FROM t1 WHERE x < ANY ( SELECT y from t2 ) Property Description Required Reduction operation The kind of reduction to use over the subquery Yes Comparison operation The kind of comparison operation to use Yes Expression Left-hand side expression to check Yes Subquery Subquery to check Yes","title":"Subqueries"},{"location":"expressions/subqueries/#subqueries","text":"Subqueries are scalar expressions comprised of another query.","title":"Subqueries"},{"location":"expressions/subqueries/#forms","text":"","title":"Forms"},{"location":"expressions/subqueries/#scalar","text":"Scalar subqueries are subqueries that return one row and one column. Property Description Required Input Input relation Yes","title":"Scalar"},{"location":"expressions/subqueries/#in-predicate","text":"An IN subquery predicate checks that the left expression is contained in the right subquery.","title":"IN predicate"},{"location":"expressions/subqueries/#examples","text":"SELECT * FROM t1 WHERE x IN ( SELECT * FROM t2 ) SELECT * FROM t1 WHERE ( x , y ) IN ( SELECT a , b FROM t2 ) Property Description Required Needles Expressions who existence will be checked Yes Haystack Subquery to check Yes","title":"Examples"},{"location":"expressions/subqueries/#set-predicates","text":"A set predicate is a predicate over a set of rows in the form of a subquery. EXISTS and UNIQUE are common SQL spellings of these kinds of predicates. Property Description Required Operation The operation to perform over the set Yes Tuples Set of tuples to check using the operation Yes","title":"Set predicates"},{"location":"expressions/subqueries/#set-comparisons","text":"A set comparison subquery is a subquery comparison using ANY or ALL operations.","title":"Set comparisons"},{"location":"expressions/subqueries/#examples_1","text":"SELECT * FROM t1 WHERE x < ANY ( SELECT y from t2 ) Property Description Required Reduction operation The kind of reduction to use over the subquery Yes Comparison operation The kind of comparison operation to use Yes Expression Left-hand side expression to check Yes Subquery Subquery to check Yes","title":"Examples"},{"location":"expressions/table_functions/","text":"Table Functions \u00b6 Table functions produce zero or more records for each input record. Table functions use a signature similar to scalar functions. However, they are not allowed in the same contexts. to be completed\u2026","title":"Table Functions"},{"location":"expressions/table_functions/#table-functions","text":"Table functions produce zero or more records for each input record. Table functions use a signature similar to scalar functions. However, they are not allowed in the same contexts. to be completed\u2026","title":"Table Functions"},{"location":"expressions/user_defined_functions/","text":"User-Defined Functions \u00b6 Substrait supports the creation of custom functions using simple extensions , using the facilities described in scalar functions . In fact, the functions defined by Substrait use the same mechanism. The extension files for them can be found here .","title":"User-Defined Functions"},{"location":"expressions/user_defined_functions/#user-defined-functions","text":"Substrait supports the creation of custom functions using simple extensions , using the facilities described in scalar functions . In fact, the functions defined by Substrait use the same mechanism. The extension files for them can be found here .","title":"User-Defined Functions"},{"location":"expressions/window_functions/","text":"Window Functions \u00b6 Window functions are functions which consume values from multiple records to produce a single output. They are similar to aggregate functions, but also have a focused window of analysis to compare to their partition window. Window functions are similar to scalar values to an end user, producing a single value for each input record. However, the consumption visibility for the production of each single record can be many records. Window function signatures contain all the properties defined for aggregate functions . Additionally, they contain the properties below Property Description Required Inherits All properties defined for aggregate functions. N/A Window Type STREAMING or PARTITION. Describes whether the function needs to see all data for the specific partition operation simultaneously. Operations like SUM can produce values in a streaming manner with no complete visibility of the partition. NTILE requires visibility of the entire partition before it can start producing values. Optional, defaults to PARTITION When binding an aggregate function, the binding must include the following additional properties beyond the standard scalar binding properties: Property Description Required Partition A list of partitioning expressions. False, defaults to a single partition for the entire dataset Lower Bound Bound Following(int64), Bound Trailing(int64) or CurrentRow. False, defaults to start of partition Upper Bound Bound Following(int64), Bound Trailing(int64) or CurrentRow. False, defaults to end of partition","title":"Window Functions"},{"location":"expressions/window_functions/#window-functions","text":"Window functions are functions which consume values from multiple records to produce a single output. They are similar to aggregate functions, but also have a focused window of analysis to compare to their partition window. Window functions are similar to scalar values to an end user, producing a single value for each input record. However, the consumption visibility for the production of each single record can be many records. Window function signatures contain all the properties defined for aggregate functions . Additionally, they contain the properties below Property Description Required Inherits All properties defined for aggregate functions. N/A Window Type STREAMING or PARTITION. Describes whether the function needs to see all data for the specific partition operation simultaneously. Operations like SUM can produce values in a streaming manner with no complete visibility of the partition. NTILE requires visibility of the entire partition before it can start producing values. Optional, defaults to PARTITION When binding an aggregate function, the binding must include the following additional properties beyond the standard scalar binding properties: Property Description Required Partition A list of partitioning expressions. False, defaults to a single partition for the entire dataset Lower Bound Bound Following(int64), Bound Trailing(int64) or CurrentRow. False, defaults to start of partition Upper Bound Bound Following(int64), Bound Trailing(int64) or CurrentRow. False, defaults to end of partition","title":"Window Functions"},{"location":"extensions/","text":"Extensions \u00b6 In many cases, the existing objects in Substrait will be sufficient to accomplish a particular use case. However, it is sometimes helpful to create a new data type, scalar function signature or some other custom representation within a system. For that, Substrait provides a number of extension points. Simple Extensions \u00b6 Some kinds of primitives are so frequently extended that Substrait defines a standard YAML format that describes how the extended functionality can be interpreted. This allows different projects/systems to use the YAML definition as a specification so that interoperability isn\u2019t constrained to the base Substrait specification. The main types of extensions that are defined in this manner include the following: Data types Type variations Scalar Functions Aggregate Functions Window Functions Table Functions To extend these items, developers can create one or more YAML files at a defined URI that describes the properties of each of these extensions. The YAML file is constructed according to the YAML Schema . Each definition in the file corresponds to the YAML-based serialization of the relevant data structure. If a user only wants to extend one of these types of objects (e.g. types), a developer does not have to provide definitions for the other extension points. A Substrait plan can reference one or more YAML files via URI for extension. In the places where these entities are referenced, they will be referenced using a URI + name reference. The name scheme per type works as follows: Category Naming scheme Type The name as defined on the type object. Type Variation The name as defined on the type variation object. Function Signature In a specific YAML, if there is only one function implementation with a specific name, a extension type declaration can reference the function using either simple or compound references. Simple references are simply the name of the function (e.g. add ). Compound references (e.g. add:i8_i8 )are described below. Function Signature Compound Names \u00b6 A YAML file may contain one or more functions by the same name. When only a single function is declared within the file, it can be referenced using the name of that function or a compound name. When more than one function of the same name is declared within a YAML file, the key used in the function extension declaration is a combination of the name of the function along with a list of input argument types. The format is as follows: <function name>:<short_arg_type0>_<short_arg_type1>_..._<short_arg_typeN> Rather than using a full data type representation, the input argument types ( short_arg_type ) are mapped to single-level short name. The mappings are listed in the table below. Note It is required that two function implementation with the same simple name must resolve to different compound names using types. If two function implementations in a YAML file resolve to the same compound name, the YAML file is invalid and behavior is undefined. Argument Type Signature Name Optional Enumeration opt Required Enumeration req i8 i8 i16 i16 i32 i32 i64 i64 fp32 fp32 fp64 fp64 string str binary vbin timestamp ts timestamp_tz tstz date date time time interval_year iyear interval_day iday uuid uuid fixedchar<N> fchar varchar<N> vchar fixedbinary<N> fbin decimal<P,S> dec struct<T1,T2,\u2026,TN> struct list<T> list map<K,V> map any[\\d]? any user defined type u!name Examples \u00b6 Function Signature Function Name add(optional enumeration, i8, i8) => i8 add:opt_i8_i8 avg(fp32) => fp32 avg:fp32 extract(required enumeration, timestamp) => i64 extract:req_ts sum(any1) => any1 sum:any Advanced Extensions \u00b6 Less common extensions can be extended using customization support at the serialization level. This includes the following kinds of extensions: Extension Type Description Relation Modification (semantic) Extensions to an existing relation that will alter the semantics of that relation. These kinds of extensions require that any plan consumer understand the extension to be able to manipulate or execute that operator. Ignoring these extensions will result in an incorrect interpretation of the plan. An example extension might be creating a customized version of Aggregate that can optionally apply a filter before aggregating the data. Note: Semantic-changing extensions shouldn\u2019t change the core characteristics of the underlying relation. For example, they should not change the default direct output field ordering, change the number of fields output or change the behavior of physical property characteristics. If one needs to change one of these behaviors, one should define a new relation as described below. Relation Modification (optimization) Extensions to an existing relation that can improve the efficiency of a plan consumer but don\u2019t fundamentally change the behavior of the operation. An example might be an estimated amount of memory the relation is expected to use or a particular algorithmic pattern that is perceived to be optimal. New Relations Creates an entirely new kind of relation. It is the most flexible way to extend Substrait but also make the Substrait plan the least interoperable. In most cases it is better to use a semantic changing relation as oppposed to a new relation as it means existing code patterns can easily be extended to work with the additional properties. New Read Types Defines a new subcategory of read that can be used in a ReadRel. One of Substrait is to provide a fairly extensive set of read patterns within the project as opposed to requiring people to define new types externally. As such, we suggest that you first talk with the Substrait community to determine whether you read type can be incorporated directly in the core specification. New Write Types Similar to a read type but for writes. As with reads, the community recommends that interested extenders first discuss with the community about developing new write types in the community before using the extension mechanisms. Plan Extensions Semantic and/or optimization based additions at the plan level. Because extension mechanisms are different for each serialization format, please refer to the corresponding serialization sections to understand how these extensions are defined in more detail.","title":"Extensions"},{"location":"extensions/#extensions","text":"In many cases, the existing objects in Substrait will be sufficient to accomplish a particular use case. However, it is sometimes helpful to create a new data type, scalar function signature or some other custom representation within a system. For that, Substrait provides a number of extension points.","title":"Extensions"},{"location":"extensions/#simple-extensions","text":"Some kinds of primitives are so frequently extended that Substrait defines a standard YAML format that describes how the extended functionality can be interpreted. This allows different projects/systems to use the YAML definition as a specification so that interoperability isn\u2019t constrained to the base Substrait specification. The main types of extensions that are defined in this manner include the following: Data types Type variations Scalar Functions Aggregate Functions Window Functions Table Functions To extend these items, developers can create one or more YAML files at a defined URI that describes the properties of each of these extensions. The YAML file is constructed according to the YAML Schema . Each definition in the file corresponds to the YAML-based serialization of the relevant data structure. If a user only wants to extend one of these types of objects (e.g. types), a developer does not have to provide definitions for the other extension points. A Substrait plan can reference one or more YAML files via URI for extension. In the places where these entities are referenced, they will be referenced using a URI + name reference. The name scheme per type works as follows: Category Naming scheme Type The name as defined on the type object. Type Variation The name as defined on the type variation object. Function Signature In a specific YAML, if there is only one function implementation with a specific name, a extension type declaration can reference the function using either simple or compound references. Simple references are simply the name of the function (e.g. add ). Compound references (e.g. add:i8_i8 )are described below.","title":"Simple Extensions"},{"location":"extensions/#function-signature-compound-names","text":"A YAML file may contain one or more functions by the same name. When only a single function is declared within the file, it can be referenced using the name of that function or a compound name. When more than one function of the same name is declared within a YAML file, the key used in the function extension declaration is a combination of the name of the function along with a list of input argument types. The format is as follows: <function name>:<short_arg_type0>_<short_arg_type1>_..._<short_arg_typeN> Rather than using a full data type representation, the input argument types ( short_arg_type ) are mapped to single-level short name. The mappings are listed in the table below. Note It is required that two function implementation with the same simple name must resolve to different compound names using types. If two function implementations in a YAML file resolve to the same compound name, the YAML file is invalid and behavior is undefined. Argument Type Signature Name Optional Enumeration opt Required Enumeration req i8 i8 i16 i16 i32 i32 i64 i64 fp32 fp32 fp64 fp64 string str binary vbin timestamp ts timestamp_tz tstz date date time time interval_year iyear interval_day iday uuid uuid fixedchar<N> fchar varchar<N> vchar fixedbinary<N> fbin decimal<P,S> dec struct<T1,T2,\u2026,TN> struct list<T> list map<K,V> map any[\\d]? any user defined type u!name","title":"Function Signature Compound Names"},{"location":"extensions/#examples","text":"Function Signature Function Name add(optional enumeration, i8, i8) => i8 add:opt_i8_i8 avg(fp32) => fp32 avg:fp32 extract(required enumeration, timestamp) => i64 extract:req_ts sum(any1) => any1 sum:any","title":"Examples"},{"location":"extensions/#advanced-extensions","text":"Less common extensions can be extended using customization support at the serialization level. This includes the following kinds of extensions: Extension Type Description Relation Modification (semantic) Extensions to an existing relation that will alter the semantics of that relation. These kinds of extensions require that any plan consumer understand the extension to be able to manipulate or execute that operator. Ignoring these extensions will result in an incorrect interpretation of the plan. An example extension might be creating a customized version of Aggregate that can optionally apply a filter before aggregating the data. Note: Semantic-changing extensions shouldn\u2019t change the core characteristics of the underlying relation. For example, they should not change the default direct output field ordering, change the number of fields output or change the behavior of physical property characteristics. If one needs to change one of these behaviors, one should define a new relation as described below. Relation Modification (optimization) Extensions to an existing relation that can improve the efficiency of a plan consumer but don\u2019t fundamentally change the behavior of the operation. An example might be an estimated amount of memory the relation is expected to use or a particular algorithmic pattern that is perceived to be optimal. New Relations Creates an entirely new kind of relation. It is the most flexible way to extend Substrait but also make the Substrait plan the least interoperable. In most cases it is better to use a semantic changing relation as oppposed to a new relation as it means existing code patterns can easily be extended to work with the additional properties. New Read Types Defines a new subcategory of read that can be used in a ReadRel. One of Substrait is to provide a fairly extensive set of read patterns within the project as opposed to requiring people to define new types externally. As such, we suggest that you first talk with the Substrait community to determine whether you read type can be incorporated directly in the core specification. New Write Types Similar to a read type but for writes. As with reads, the community recommends that interested extenders first discuss with the community about developing new write types in the community before using the extension mechanisms. Plan Extensions Semantic and/or optimization based additions at the plan level. Because extension mechanisms are different for each serialization format, please refer to the corresponding serialization sections to understand how these extensions are defined in more detail.","title":"Advanced Extensions"},{"location":"relations/basics/","text":"Basics \u00b6 Substrait is designed to allow a user to construct an arbitrarily complex data transformation plan. The plan is composed of one or more relational operations. Relational operations are well-defined transformation operations that work by taking zero or more input datasets and transforming them into zero or more output transformations. Substrait defines a core set of transformations, but users are also able to extend the operations with their own specialized operations. Each relational operation is composed of several properties. Common properties for relational operations include the following: Property Description Type Emit The set of columns output from this operation and the order of those columns. Logical & Physical Hints A set of optionally provided, optionally consumed information about an operation that better informs execution. These might include estimated number of input and output records, estimated record size, likely filter reduction, estimated dictionary size, etc. These can also include implementation specific pieces of execution information. Physical Constraint A set of runtime constraints around the operation, limiting its consumption based on real-world resources (CPU, memory) as well as virtual resources like number of records produced, the largest record size, etc. Physical Relational Signatures \u00b6 In functions, function signatures are declared externally to the use of those signatures (function bindings). In the case of relational operations, signatures are declared directly in the specification. This is due to the speed of change and number of total operations. Relational operations in the specification are expected to be <100 for several years with additions being infrequent. On the other hand, there is an expectation of both a much larger number of functions (1,000s) and a much higher velocity of additions. Each relational operation must declare the following: Transformation logic around properties of the data. For example, does a relational operation maintain sortedness of a field? Does an operation change the distribution of data? How many input sets does an operation produce? Does the operator produce an output (by specification, we limit relational operations to a single output at this time) What is the schema and field ordering of an output (see emit below)? Emit: Output Ordering \u00b6 A relational operation uses field references to access specific fields of the input stream. Field references are always ordinal based on the order of the incoming streams. Each relational operation must declare the order of its output data. To simplify things, each relational operation can be in one of two modes: Direct output : The order of outputs is based on the definition declared by the relational operation. Remap : A listed ordering of the direct outputs. This remapping can be also used to drop columns no longer used (such as a filter field or join keys after a join). Note that remapping/exclusion can only be done at the outputs root struct. Filtering of compound values or extracting subsets must be done through other operation types (e.g. projection). Relation Properties \u00b6 There are a number of predefined properties that exist in Substrait relations. These include the following. Distribution \u00b6 When data is partitioned across multiple sibling sets, distribution describes that set of properties that apply to any one partition. This is based on a set of distribution expression properties. A distribution is declared as a set of one or more fields and a distribution type across all fields. Property Description Required Distribution Fields List of fields references that describe distribution (e.g. [0,2:4,5:0:0]). The order of these references do not impact results. Required for partitioned distribution type. Disallowed for singleton distribution type. Distribution Type PARTITIONED: For a discrete tuple of values for the declared distribution fields, all records with that tuple are located in the same partition. SINGLETON: there will only be a single partition for this operation. Required Orderedness \u00b6 A guarantee that data output from this operation is provided with a sort order. The sort order will be declared based on a set of sort field definitions based on the emitted output of this operation. Property Description Required Sort Fields A list of fields that the data are ordered by. The list is in order of the sort. If sort by [0,1] this means we only consider the data for field 1 is only ordered within each discrete value of field 0. At least one required. Per - Sort Field A field reference that the data is sorted by. Required Per - Sort Direction The direction of the data. See direction options below. Required Ordering Directions \u00b6 Direction Descriptions Nulls Position Ascending Returns data in ascending order based on the quality function associated with the type. Nulls are included before any values. First Descending Returns data in descending order based on the quality function associated with the type. Nulls are included before any values. First Ascending Returns data in ascending order based on the quality function associated with the type. Nulls are included after any values. Last Descending Returns data in descending order based on the quality function associated with the type. Nulls are included after any values. Last Custom function identifier Returns data using a custom function that returns -1, 0, or 1 depending on the order of the data. Per Function Clustered Ensures that all equal values are coalesced (but no ordering between values is defined). E.g, for values 1,2,3,1,2,3, output could be any of the following 1,1,2,2,3,3 or 2,2,3,3,1,1 or 3,3,2,2,1,1 or 3,3,1,1,2,2. N/A, may appear anywhere but will be coalesced. Discussion Points \u00b6 Do we try to make read definition types more extensible \u00e0 la function signatures? Is that necessary if we have a custom relational operator? How do we express decomposed types. For example, the Iceberg type above is for early logical planning. Once we do some operations, it may produce a list of Iceberg file reads. This is likely a secondary type of object. We currently include a \u201cgeneric properties\u201d property on read type. Do we want this dumping ground?","title":"Basics"},{"location":"relations/basics/#basics","text":"Substrait is designed to allow a user to construct an arbitrarily complex data transformation plan. The plan is composed of one or more relational operations. Relational operations are well-defined transformation operations that work by taking zero or more input datasets and transforming them into zero or more output transformations. Substrait defines a core set of transformations, but users are also able to extend the operations with their own specialized operations. Each relational operation is composed of several properties. Common properties for relational operations include the following: Property Description Type Emit The set of columns output from this operation and the order of those columns. Logical & Physical Hints A set of optionally provided, optionally consumed information about an operation that better informs execution. These might include estimated number of input and output records, estimated record size, likely filter reduction, estimated dictionary size, etc. These can also include implementation specific pieces of execution information. Physical Constraint A set of runtime constraints around the operation, limiting its consumption based on real-world resources (CPU, memory) as well as virtual resources like number of records produced, the largest record size, etc. Physical","title":"Basics"},{"location":"relations/basics/#relational-signatures","text":"In functions, function signatures are declared externally to the use of those signatures (function bindings). In the case of relational operations, signatures are declared directly in the specification. This is due to the speed of change and number of total operations. Relational operations in the specification are expected to be <100 for several years with additions being infrequent. On the other hand, there is an expectation of both a much larger number of functions (1,000s) and a much higher velocity of additions. Each relational operation must declare the following: Transformation logic around properties of the data. For example, does a relational operation maintain sortedness of a field? Does an operation change the distribution of data? How many input sets does an operation produce? Does the operator produce an output (by specification, we limit relational operations to a single output at this time) What is the schema and field ordering of an output (see emit below)?","title":"Relational Signatures"},{"location":"relations/basics/#emit-output-ordering","text":"A relational operation uses field references to access specific fields of the input stream. Field references are always ordinal based on the order of the incoming streams. Each relational operation must declare the order of its output data. To simplify things, each relational operation can be in one of two modes: Direct output : The order of outputs is based on the definition declared by the relational operation. Remap : A listed ordering of the direct outputs. This remapping can be also used to drop columns no longer used (such as a filter field or join keys after a join). Note that remapping/exclusion can only be done at the outputs root struct. Filtering of compound values or extracting subsets must be done through other operation types (e.g. projection).","title":"Emit: Output Ordering"},{"location":"relations/basics/#relation-properties","text":"There are a number of predefined properties that exist in Substrait relations. These include the following.","title":"Relation Properties"},{"location":"relations/basics/#distribution","text":"When data is partitioned across multiple sibling sets, distribution describes that set of properties that apply to any one partition. This is based on a set of distribution expression properties. A distribution is declared as a set of one or more fields and a distribution type across all fields. Property Description Required Distribution Fields List of fields references that describe distribution (e.g. [0,2:4,5:0:0]). The order of these references do not impact results. Required for partitioned distribution type. Disallowed for singleton distribution type. Distribution Type PARTITIONED: For a discrete tuple of values for the declared distribution fields, all records with that tuple are located in the same partition. SINGLETON: there will only be a single partition for this operation. Required","title":"Distribution"},{"location":"relations/basics/#orderedness","text":"A guarantee that data output from this operation is provided with a sort order. The sort order will be declared based on a set of sort field definitions based on the emitted output of this operation. Property Description Required Sort Fields A list of fields that the data are ordered by. The list is in order of the sort. If sort by [0,1] this means we only consider the data for field 1 is only ordered within each discrete value of field 0. At least one required. Per - Sort Field A field reference that the data is sorted by. Required Per - Sort Direction The direction of the data. See direction options below. Required","title":"Orderedness"},{"location":"relations/basics/#ordering-directions","text":"Direction Descriptions Nulls Position Ascending Returns data in ascending order based on the quality function associated with the type. Nulls are included before any values. First Descending Returns data in descending order based on the quality function associated with the type. Nulls are included before any values. First Ascending Returns data in ascending order based on the quality function associated with the type. Nulls are included after any values. Last Descending Returns data in descending order based on the quality function associated with the type. Nulls are included after any values. Last Custom function identifier Returns data using a custom function that returns -1, 0, or 1 depending on the order of the data. Per Function Clustered Ensures that all equal values are coalesced (but no ordering between values is defined). E.g, for values 1,2,3,1,2,3, output could be any of the following 1,1,2,2,3,3 or 2,2,3,3,1,1 or 3,3,2,2,1,1 or 3,3,1,1,2,2. N/A, may appear anywhere but will be coalesced.","title":"Ordering Directions"},{"location":"relations/basics/#discussion-points","text":"Do we try to make read definition types more extensible \u00e0 la function signatures? Is that necessary if we have a custom relational operator? How do we express decomposed types. For example, the Iceberg type above is for early logical planning. Once we do some operations, it may produce a list of Iceberg file reads. This is likely a secondary type of object. We currently include a \u201cgeneric properties\u201d property on read type. Do we want this dumping ground?","title":"Discussion Points"},{"location":"relations/embedded_relations/","text":"Embedded Relations \u00b6 Pending. Embedded relations allow a Substrait producer to define a set operation that will be embedded in the plan. TODO: define lots of details about what interfaces, languages, formats, etc. Should reasonably be an extension of embedded user defined table functions.","title":"Embedded Relations"},{"location":"relations/embedded_relations/#embedded-relations","text":"Pending. Embedded relations allow a Substrait producer to define a set operation that will be embedded in the plan. TODO: define lots of details about what interfaces, languages, formats, etc. Should reasonably be an extension of embedded user defined table functions.","title":"Embedded Relations"},{"location":"relations/logical_relations/","text":"Logical Relations \u00b6 Read Operator \u00b6 The read operator is an operator that produces one output. A simple example would be the reading of a Parquet file. It is expected that many types of reads will be added over time. Signature Value Inputs 0 Outputs 1 Property Maintenance N/A (no inputs) Direct Output Order Defaults to the schema of the data read after the optional projection (masked complex expression) is applied. Read Properties \u00b6 Property Description Required Definition The contents of the read property definition. Required Direct Schema Defines the schema of the output of the read (before any projection or emit remapping/hiding). Required Filter A boolean Substrait expression that describes the filter of an iceberg dataset. TBD: define how field referencing works. Optional, defaults to none. Projection A masked complex expression describing the portions of the content that should be read Optional, defaults to all of schema Output properties Declaration of orderedness and/or distribution properties this read produces. Optional, defaults to no properties. Properties A list of name/value pairs associated with the read. Optional, defaults to empty Read Definition Types \u00b6 Read definition types are built by the community and added to the specification. This is a portion of specification that is expected to grow rapidly. Virtual Table \u00b6 Property Description Required Data Required Required Files Type \u00b6 Property Description Required Items An array of Items (path or path glob) associated with the read. Required Format per item Enumeration of available formats. Only current option is PARQUET. Required Slicing parameters per item Information to use when reading a slice of a file. Optional Slicing Files \u00b6 A read operation is allowed to only read part of a file. This is convenient, for example, when distributing a read operation across several nodes. The slicing parameters are specified as byte offsets into the file. Many file formats consist of indivisible \u201cchunks\u201d of data (e.g. Parquet row groups). If this happens the consumer can determine which slice a particular chunk belongs to. For example, one possible approach is that a chunk should only be read if the midpoint of the chunk (dividing by 2 and rounding down) is contained within the asked-for byte range. ReadRel Message message ReadRel { RelCommon common = 1 ; NamedStruct base_schema = 2 ; Expression filter = 3 ; Expression.MaskExpression projection = 4 ; substrait.extensions.AdvancedExtension advanced_extension = 10 ; // Definition of which type of scan operation is to be performed oneof read_type { VirtualTable virtual_table = 5 ; LocalFiles local_files = 6 ; NamedTable named_table = 7 ; ExtensionTable extension_table = 8 ; } // A base table. The list of string is used to represent namespacing (e.g., mydb.mytable). // This assumes shared catalog between systems exchanging a message. message NamedTable { repeated string names = 1 ; substrait.extensions.AdvancedExtension advanced_extension = 10 ; } // A table composed of literals. message VirtualTable { repeated Expression.Literal.Struct values = 1 ; } // A stub type that can be used to extend/introduce new table types outside // the specification. message ExtensionTable { google.protobuf.Any detail = 1 ; } // Represents a list of files in input of a scan operation message LocalFiles { repeated FileOrFiles items = 1 ; substrait.extensions.AdvancedExtension advanced_extension = 10 ; // Many files consist of indivisible chunks (e.g. parquet row groups // or CSV rows). If a slice partially selects an indivisible chunk // then the consumer should employ some rule to decide which slice to // include the chunk in (e.g. include it in the slice that contains // the midpoint of the chunk) message FileOrFiles { oneof path_type { // A URI that can refer to either a single folder or a single file string uri_path = 1 ; // A URI where the path portion is a glob expression that can // identify zero or more paths. // Consumers should support the POSIX syntax. The recursive // globstar (**) may not be supported. string uri_path_glob = 2 ; // A URI that refers to a single file string uri_file = 3 ; // A URI that refers to a single folder string uri_folder = 4 ; } // Original file format enum, superseded by the file_format oneof. reserved 5 ; reserved \"format\" ; // The index of the partition this item belongs to uint64 partition_index = 6 ; // The start position in byte to read from this item uint64 start = 7 ; // The length in byte to read from this item uint64 length = 8 ; message ParquetReadOptions {} message ArrowReadOptions {} message OrcReadOptions {} // The format of the files. oneof file_format { ParquetReadOptions parquet = 9 ; ArrowReadOptions arrow = 10 ; OrcReadOptions orc = 11 ; google.protobuf.Any extension = 12 ; } } } } Filter Operation \u00b6 The filter operator eliminates one or more records from the input data based on a boolean filter expression. Signature Value Inputs 1 Outputs 1 Property Maintenance Orderedness, Distribution, remapped by emit Direct Output Order The field order as the input. Filter Properties \u00b6 Property Description Required Input The relational input. Required Expression A boolean expression which describes which records are included/excluded. Required FilterRel Message message FilterRel { RelCommon common = 1 ; Rel input = 2 ; Expression condition = 3 ; substrait.extensions.AdvancedExtension advanced_extension = 10 ; } Sort Operation \u00b6 The sort operator reorders a dataset based on one or more identified sort fields and a sorting function for each. Signature Value Inputs 1 Outputs 1 Property Maintenance Will update orderedness property to the output of the sort operation. Distribution property only remapped based on emit. Direct Output Order The field order of the input. Sort Properties \u00b6 Property Description Required Input The relational input. Required Sort Fields List of one or more fields to sort by. Uses the same properties as the orderedness property. One sort field required SortRel Message message SortRel { RelCommon common = 1 ; Rel input = 2 ; repeated SortField sorts = 3 ; substrait.extensions.AdvancedExtension advanced_extension = 10 ; } Project Operation \u00b6 The project operation will produce one or more additional expressions based on the inputs of the dataset. Signature Value Inputs 1 Outputs 1 Property Maintenance Distribution maintained, mapped by emit. Orderedness: Maintained if no window operations. Extended to include projection fields if fields are direct references. If window operations are present, no orderedness is maintained. Direct Output Order The field order of the input + the list of new expressions in the order they are declared in the expressions list. Project Properties \u00b6 Property Description Required Input The relational input. Required Expressions List of one or more expressions to add to the input. At least one expression required ProjectRel Message message ProjectRel { RelCommon common = 1 ; Rel input = 2 ; repeated Expression expressions = 3 ; substrait.extensions.AdvancedExtension advanced_extension = 10 ; } Cross Product Operation \u00b6 The cross product operation will combine two separate inputs into a single output. It pairs every record from the left input with every record of the right input. Signature Value Inputs 2 Outputs 1 Property Maintenance Distribution is maintained. Orderedness is empty post operation. Direct Output Order The emit order of the left input followed by the emit order of the right input. Cross Product Properties \u00b6 Property Description Required Left Input A relational input. Required Right Input A relational input. Required CrossRel Message message CrossRel { RelCommon common = 1 ; Rel left = 2 ; Rel right = 3 ; substrait.extensions.AdvancedExtension advanced_extension = 10 ; } Join Operation \u00b6 The join operation will combine two separate inputs into a single output, based on a join expression. A common subtype of joins is an equality join where the join expression is constrained to a list of equality (or equality + null equality) conditions between the two inputs of the join. Signature Value Inputs 2 Outputs 1 Property Maintenance Distribution is maintained. Orderedness is empty post operation. Physical relations may provide better property maintenance. Direct Output Order The emit order of the left input followed by the emit order of the right input. Join Properties \u00b6 Property Description Required Left Input A relational input. Required Right Input A relational input. Required Join Expression A boolean condition that describes whether each record from the left set \u201cmatch\u201d the record from the right set. Field references correspond to the direct output order of the data. Required. Can be the literal True. Join Type One of the join types defined below. Required Join Types \u00b6 Type Description Inner Return records from the left side only if they match the right side. Return records from the right side only when they match the left side. For each cross input match, return a record including the data from both sides. Non-matching records are ignored. Outer Return all records from both the left and right inputs. For each cross input match, return a record including the data from both sides. For any remaining non-match records, return the record from the corresponding input along with nulls for the opposite input. Left Return all records from the left input. For each cross input match, return a record including the data from both sides. For any remaining non-matching records from the left input, return the left record along with nulls for the right input. Right Return all records from the right input. For each cross input match, return a record including the data from both sides. For any remaining non-matching records from the right input, return the left record along with nulls for the right input. Semi Returns records from the left input. These are returned only if the records have a join partner on the right side. Anti Return records from the left input. These are returned only if the records do not have a join partner on the right side. Single Returns one join partner per entry on the left input. If more than one join partner exists, there are two valid semantics. 1) Only the first match is returned. 2) The system throws an error. If there is no match between the left and right inputs, NULL is returned. JoinRel Message message JoinRel { RelCommon common = 1 ; Rel left = 2 ; Rel right = 3 ; Expression expression = 4 ; Expression post_join_filter = 5 ; JoinType type = 6 ; enum JoinType { JOIN_TYPE_UNSPECIFIED = 0 ; JOIN_TYPE_INNER = 1 ; JOIN_TYPE_OUTER = 2 ; JOIN_TYPE_LEFT = 3 ; JOIN_TYPE_RIGHT = 4 ; JOIN_TYPE_SEMI = 5 ; JOIN_TYPE_ANTI = 6 ; // This join is useful for nested sub-queries where we need exactly one tuple in output (or throw exception) // See Section 3.2 of https://15721.courses.cs.cmu.edu/spring2018/papers/16-optimizer2/hyperjoins-btw2017.pdf JOIN_TYPE_SINGLE = 7 ; } substrait.extensions.AdvancedExtension advanced_extension = 10 ; } Set Operation \u00b6 The set operation encompasses several set-level operations that support combining datasets based, possibly excluding records based on various types of record level matching. Signature Value Inputs 2 or more Outputs 1 Property Maintenance Maintains distribution if all inputs have the same ordinal distribution. Orderedness is not maintained. Direct Output Order All inputs are ordinally matched and returned together. All inputs must have matching record types. Set Properties \u00b6 Property Description Required Primary Input The primary input of the dataset. Required Secondary Inputs One or more relational inputs. At least one required Set Operation Type From list below. Required Set Operation Types \u00b6 Property Description Minus (Primary) Returns the primary input excluding any matching records from secondary inputs. Minus (Multiset) Returns the primary input minus any records that are included in all sets. Intersection (Primary) Returns all rows primary rows that intersect at least one secondary input. Intersection (Multiset) Returns all rows that intersect at least one record from each secondary inputs. Union Distinct Returns all the records from each set, removing any rows that are duplicated (within or across sets). Union All Returns all records from each set, allowing duplicates. SetRel Message message SetRel { RelCommon common = 1 ; repeated Rel inputs = 2 ; SetOp op = 3 ; substrait.extensions.AdvancedExtension advanced_extension = 10 ; enum SetOp { SET_OP_UNSPECIFIED = 0 ; SET_OP_MINUS_PRIMARY = 1 ; SET_OP_MINUS_MULTISET = 2 ; SET_OP_INTERSECTION_PRIMARY = 3 ; SET_OP_INTERSECTION_MULTISET = 4 ; SET_OP_UNION_DISTINCT = 5 ; SET_OP_UNION_ALL = 6 ; } } Fetch Operation \u00b6 The fetch operation eliminates records outside a desired window. Typically corresponds to a fetch/offset SQL clause. Will only returns records between the start offset and the end offset. Signature Value Inputs 2 or more Outputs 1 Property Maintenance Maintains distribution and orderedness. Direct Output Order Unchanged from input. Fetch Properties \u00b6 Property Description Required Input A relational input, typically with a desired orderedness property. Required Offset A positive integer. Declares the offset for retrieval of records. Optional, defaults to 0. Count A positive integer. Declares the number of records that should be returned. Required FetchRel Message message FetchRel { RelCommon common = 1 ; Rel input = 2 ; // the offset expressed in number of records int64 offset = 3 ; // the amount of records to return int64 count = 4 ; substrait.extensions.AdvancedExtension advanced_extension = 10 ; } Aggregate Operation \u00b6 The aggregate operation groups input data on one or more sets of grouping keys, calculating each measure for each combination of grouping key. Signature Value Inputs 1 Outputs 1 Property Maintenance Maintains distribution if all distribution fields are contained in every grouping set. No orderedness guaranteed. Direct Output Order The list of distinct columns from each grouping set (ordered by their first appearance) followed by the list of measures in declaration order, followed by an i32 describing the associated particular grouping set the value is derived from (if applicable). In its simplest form, an aggregation has only measures. In this case, all records are folded into one, and a column is returned for each aggregate expression in the measures list. Grouping sets can be used for finer-grained control over which records are folded. Within a grouping set, two records will be folded together if and only if each expressions in the grouping set yields the same value for each. The values returned by the grouping sets will be returned as columns to the left of the columns for the aggregate expressions. If a grouping set contains no grouping expressions, all rows will be folded for that grouping set. It\u2019s possible to specify multiple grouping sets in a single aggregate operation. The grouping sets behave more or less independently, with each returned record belonging to one of the grouping sets. The values for the grouping expression columns that are not part of the grouping set for a particular record will be set to null. Two grouping expressions will be returned using the same column if they represent the protobuf messages describing the expressions are equal. The columns for grouping expressions that do not appear in all grouping sets will be nullable (regardless of the nullability of the type returned by the grouping expression) to accomodate the null insertion. To further disambiguate which record belongs to which grouping set, an aggregate relation with more than one grouping set receives an extra i32 column on the right-hand side. The value of this field will be the zero-based index of the grouping set that yielded the record. If at least one grouping expression is present, the aggregation is allowed to not have any aggregate expressions. An aggregate relation is invalid if it would yield zero columns. Aggregate Properties \u00b6 Property Description Required Input The relational input. Required Grouping Sets One or more grouping sets. Optional, required if no measures. Per Grouping Set A list of expression grouping that the aggregation measured should be calculated for. Optional. Measures A list of one or more aggregate expressions along with an optional filter. Optional, required if no grouping sets. AggregateRel Message message AggregateRel { RelCommon common = 1 ; // Input of the aggregation Rel input = 2 ; // A list of expression grouping that the aggregation measured should be calculated for. repeated Grouping groupings = 3 ; // A list of one or more aggregate expressions along with an optional filter. repeated Measure measures = 4 ; substrait.extensions.AdvancedExtension advanced_extension = 10 ; message Grouping { repeated Expression grouping_expressions = 1 ; } message Measure { AggregateFunction measure = 1 ; // An optional boolean expression that acts to filter which records are // included in the measure. True means include this record for calculation // within the measure. // Helps to support SUM(<c>) FILTER(WHERE...) syntax without masking opportunities for optimization Expression filter = 2 ; } } Write Operator \u00b6 The write operator is an operator that consumes one output and writes it to storage. A simple example would be writing Parquet files. It is expected that many types of writes will be added over time. Signature Value Inputs 1 Outputs 0 Property Maintenance N/A (no output) Direct Output Order N/A (no output) Write Properties \u00b6 Property Description Required Definition The contents of the write property definition. Required Field names The names of all struct fields in breadth-first order. Required Masked Complex Expression The masking expression applied to the input record prior to write. Optional, defaults to all Rotation description fields A list of fields that can be used for stream description whenever a stream is reset. Optional, defaults to none. Rotation indicator An input field ID that describes when the current stream should be \u201crotated\u201d. Individual write definition types may support the ability to rotate the output into one or more streams. This could mean closing and opening a new file, finishing and restarting a TCP connection, etc. If a rotation indicator is available, it will be 0 except when a rotation should occur. Rotation indication are frequently defined by things like discrete partition values but could be done based on number of records or other arbitrary criteria. Optional, defaults to none. Write Definition Types \u00b6 Write definition types are built by the community and added to the specification. This is a portion of specification that is expected to grow rapidly. Virtual Table \u00b6 Property Description Required Name The in-memory name to give the dataset. Required Pin Whether it is okay to remove this dataset from memory or it should be kept in memory. Optional, defaults to false. Files Type \u00b6 Property Description Required Path A URI to write the data to. Supports the inclusion of field references that are listed as available in properties as a \u201crotation description field\u201d. Required Format Enumeration of available formats. Only current option is PARQUET. Required Discussion Points \u00b6 How to handle correlated operations?","title":"Logical Relations"},{"location":"relations/logical_relations/#logical-relations","text":"","title":"Logical Relations"},{"location":"relations/logical_relations/#read-operator","text":"The read operator is an operator that produces one output. A simple example would be the reading of a Parquet file. It is expected that many types of reads will be added over time. Signature Value Inputs 0 Outputs 1 Property Maintenance N/A (no inputs) Direct Output Order Defaults to the schema of the data read after the optional projection (masked complex expression) is applied.","title":"Read Operator"},{"location":"relations/logical_relations/#read-properties","text":"Property Description Required Definition The contents of the read property definition. Required Direct Schema Defines the schema of the output of the read (before any projection or emit remapping/hiding). Required Filter A boolean Substrait expression that describes the filter of an iceberg dataset. TBD: define how field referencing works. Optional, defaults to none. Projection A masked complex expression describing the portions of the content that should be read Optional, defaults to all of schema Output properties Declaration of orderedness and/or distribution properties this read produces. Optional, defaults to no properties. Properties A list of name/value pairs associated with the read. Optional, defaults to empty","title":"Read Properties"},{"location":"relations/logical_relations/#read-definition-types","text":"Read definition types are built by the community and added to the specification. This is a portion of specification that is expected to grow rapidly.","title":"Read Definition Types"},{"location":"relations/logical_relations/#virtual-table","text":"Property Description Required Data Required Required","title":"Virtual Table"},{"location":"relations/logical_relations/#files-type","text":"Property Description Required Items An array of Items (path or path glob) associated with the read. Required Format per item Enumeration of available formats. Only current option is PARQUET. Required Slicing parameters per item Information to use when reading a slice of a file. Optional","title":"Files Type"},{"location":"relations/logical_relations/#slicing-files","text":"A read operation is allowed to only read part of a file. This is convenient, for example, when distributing a read operation across several nodes. The slicing parameters are specified as byte offsets into the file. Many file formats consist of indivisible \u201cchunks\u201d of data (e.g. Parquet row groups). If this happens the consumer can determine which slice a particular chunk belongs to. For example, one possible approach is that a chunk should only be read if the midpoint of the chunk (dividing by 2 and rounding down) is contained within the asked-for byte range. ReadRel Message message ReadRel { RelCommon common = 1 ; NamedStruct base_schema = 2 ; Expression filter = 3 ; Expression.MaskExpression projection = 4 ; substrait.extensions.AdvancedExtension advanced_extension = 10 ; // Definition of which type of scan operation is to be performed oneof read_type { VirtualTable virtual_table = 5 ; LocalFiles local_files = 6 ; NamedTable named_table = 7 ; ExtensionTable extension_table = 8 ; } // A base table. The list of string is used to represent namespacing (e.g., mydb.mytable). // This assumes shared catalog between systems exchanging a message. message NamedTable { repeated string names = 1 ; substrait.extensions.AdvancedExtension advanced_extension = 10 ; } // A table composed of literals. message VirtualTable { repeated Expression.Literal.Struct values = 1 ; } // A stub type that can be used to extend/introduce new table types outside // the specification. message ExtensionTable { google.protobuf.Any detail = 1 ; } // Represents a list of files in input of a scan operation message LocalFiles { repeated FileOrFiles items = 1 ; substrait.extensions.AdvancedExtension advanced_extension = 10 ; // Many files consist of indivisible chunks (e.g. parquet row groups // or CSV rows). If a slice partially selects an indivisible chunk // then the consumer should employ some rule to decide which slice to // include the chunk in (e.g. include it in the slice that contains // the midpoint of the chunk) message FileOrFiles { oneof path_type { // A URI that can refer to either a single folder or a single file string uri_path = 1 ; // A URI where the path portion is a glob expression that can // identify zero or more paths. // Consumers should support the POSIX syntax. The recursive // globstar (**) may not be supported. string uri_path_glob = 2 ; // A URI that refers to a single file string uri_file = 3 ; // A URI that refers to a single folder string uri_folder = 4 ; } // Original file format enum, superseded by the file_format oneof. reserved 5 ; reserved \"format\" ; // The index of the partition this item belongs to uint64 partition_index = 6 ; // The start position in byte to read from this item uint64 start = 7 ; // The length in byte to read from this item uint64 length = 8 ; message ParquetReadOptions {} message ArrowReadOptions {} message OrcReadOptions {} // The format of the files. oneof file_format { ParquetReadOptions parquet = 9 ; ArrowReadOptions arrow = 10 ; OrcReadOptions orc = 11 ; google.protobuf.Any extension = 12 ; } } } }","title":"Slicing Files"},{"location":"relations/logical_relations/#filter-operation","text":"The filter operator eliminates one or more records from the input data based on a boolean filter expression. Signature Value Inputs 1 Outputs 1 Property Maintenance Orderedness, Distribution, remapped by emit Direct Output Order The field order as the input.","title":"Filter Operation"},{"location":"relations/logical_relations/#filter-properties","text":"Property Description Required Input The relational input. Required Expression A boolean expression which describes which records are included/excluded. Required FilterRel Message message FilterRel { RelCommon common = 1 ; Rel input = 2 ; Expression condition = 3 ; substrait.extensions.AdvancedExtension advanced_extension = 10 ; }","title":"Filter Properties"},{"location":"relations/logical_relations/#sort-operation","text":"The sort operator reorders a dataset based on one or more identified sort fields and a sorting function for each. Signature Value Inputs 1 Outputs 1 Property Maintenance Will update orderedness property to the output of the sort operation. Distribution property only remapped based on emit. Direct Output Order The field order of the input.","title":"Sort Operation"},{"location":"relations/logical_relations/#sort-properties","text":"Property Description Required Input The relational input. Required Sort Fields List of one or more fields to sort by. Uses the same properties as the orderedness property. One sort field required SortRel Message message SortRel { RelCommon common = 1 ; Rel input = 2 ; repeated SortField sorts = 3 ; substrait.extensions.AdvancedExtension advanced_extension = 10 ; }","title":"Sort Properties"},{"location":"relations/logical_relations/#project-operation","text":"The project operation will produce one or more additional expressions based on the inputs of the dataset. Signature Value Inputs 1 Outputs 1 Property Maintenance Distribution maintained, mapped by emit. Orderedness: Maintained if no window operations. Extended to include projection fields if fields are direct references. If window operations are present, no orderedness is maintained. Direct Output Order The field order of the input + the list of new expressions in the order they are declared in the expressions list.","title":"Project Operation"},{"location":"relations/logical_relations/#project-properties","text":"Property Description Required Input The relational input. Required Expressions List of one or more expressions to add to the input. At least one expression required ProjectRel Message message ProjectRel { RelCommon common = 1 ; Rel input = 2 ; repeated Expression expressions = 3 ; substrait.extensions.AdvancedExtension advanced_extension = 10 ; }","title":"Project Properties"},{"location":"relations/logical_relations/#cross-product-operation","text":"The cross product operation will combine two separate inputs into a single output. It pairs every record from the left input with every record of the right input. Signature Value Inputs 2 Outputs 1 Property Maintenance Distribution is maintained. Orderedness is empty post operation. Direct Output Order The emit order of the left input followed by the emit order of the right input.","title":"Cross Product Operation"},{"location":"relations/logical_relations/#cross-product-properties","text":"Property Description Required Left Input A relational input. Required Right Input A relational input. Required CrossRel Message message CrossRel { RelCommon common = 1 ; Rel left = 2 ; Rel right = 3 ; substrait.extensions.AdvancedExtension advanced_extension = 10 ; }","title":"Cross Product Properties"},{"location":"relations/logical_relations/#join-operation","text":"The join operation will combine two separate inputs into a single output, based on a join expression. A common subtype of joins is an equality join where the join expression is constrained to a list of equality (or equality + null equality) conditions between the two inputs of the join. Signature Value Inputs 2 Outputs 1 Property Maintenance Distribution is maintained. Orderedness is empty post operation. Physical relations may provide better property maintenance. Direct Output Order The emit order of the left input followed by the emit order of the right input.","title":"Join Operation"},{"location":"relations/logical_relations/#join-properties","text":"Property Description Required Left Input A relational input. Required Right Input A relational input. Required Join Expression A boolean condition that describes whether each record from the left set \u201cmatch\u201d the record from the right set. Field references correspond to the direct output order of the data. Required. Can be the literal True. Join Type One of the join types defined below. Required","title":"Join Properties"},{"location":"relations/logical_relations/#join-types","text":"Type Description Inner Return records from the left side only if they match the right side. Return records from the right side only when they match the left side. For each cross input match, return a record including the data from both sides. Non-matching records are ignored. Outer Return all records from both the left and right inputs. For each cross input match, return a record including the data from both sides. For any remaining non-match records, return the record from the corresponding input along with nulls for the opposite input. Left Return all records from the left input. For each cross input match, return a record including the data from both sides. For any remaining non-matching records from the left input, return the left record along with nulls for the right input. Right Return all records from the right input. For each cross input match, return a record including the data from both sides. For any remaining non-matching records from the right input, return the left record along with nulls for the right input. Semi Returns records from the left input. These are returned only if the records have a join partner on the right side. Anti Return records from the left input. These are returned only if the records do not have a join partner on the right side. Single Returns one join partner per entry on the left input. If more than one join partner exists, there are two valid semantics. 1) Only the first match is returned. 2) The system throws an error. If there is no match between the left and right inputs, NULL is returned. JoinRel Message message JoinRel { RelCommon common = 1 ; Rel left = 2 ; Rel right = 3 ; Expression expression = 4 ; Expression post_join_filter = 5 ; JoinType type = 6 ; enum JoinType { JOIN_TYPE_UNSPECIFIED = 0 ; JOIN_TYPE_INNER = 1 ; JOIN_TYPE_OUTER = 2 ; JOIN_TYPE_LEFT = 3 ; JOIN_TYPE_RIGHT = 4 ; JOIN_TYPE_SEMI = 5 ; JOIN_TYPE_ANTI = 6 ; // This join is useful for nested sub-queries where we need exactly one tuple in output (or throw exception) // See Section 3.2 of https://15721.courses.cs.cmu.edu/spring2018/papers/16-optimizer2/hyperjoins-btw2017.pdf JOIN_TYPE_SINGLE = 7 ; } substrait.extensions.AdvancedExtension advanced_extension = 10 ; }","title":"Join Types"},{"location":"relations/logical_relations/#set-operation","text":"The set operation encompasses several set-level operations that support combining datasets based, possibly excluding records based on various types of record level matching. Signature Value Inputs 2 or more Outputs 1 Property Maintenance Maintains distribution if all inputs have the same ordinal distribution. Orderedness is not maintained. Direct Output Order All inputs are ordinally matched and returned together. All inputs must have matching record types.","title":"Set Operation"},{"location":"relations/logical_relations/#set-properties","text":"Property Description Required Primary Input The primary input of the dataset. Required Secondary Inputs One or more relational inputs. At least one required Set Operation Type From list below. Required","title":"Set Properties"},{"location":"relations/logical_relations/#set-operation-types","text":"Property Description Minus (Primary) Returns the primary input excluding any matching records from secondary inputs. Minus (Multiset) Returns the primary input minus any records that are included in all sets. Intersection (Primary) Returns all rows primary rows that intersect at least one secondary input. Intersection (Multiset) Returns all rows that intersect at least one record from each secondary inputs. Union Distinct Returns all the records from each set, removing any rows that are duplicated (within or across sets). Union All Returns all records from each set, allowing duplicates. SetRel Message message SetRel { RelCommon common = 1 ; repeated Rel inputs = 2 ; SetOp op = 3 ; substrait.extensions.AdvancedExtension advanced_extension = 10 ; enum SetOp { SET_OP_UNSPECIFIED = 0 ; SET_OP_MINUS_PRIMARY = 1 ; SET_OP_MINUS_MULTISET = 2 ; SET_OP_INTERSECTION_PRIMARY = 3 ; SET_OP_INTERSECTION_MULTISET = 4 ; SET_OP_UNION_DISTINCT = 5 ; SET_OP_UNION_ALL = 6 ; } }","title":"Set Operation Types"},{"location":"relations/logical_relations/#fetch-operation","text":"The fetch operation eliminates records outside a desired window. Typically corresponds to a fetch/offset SQL clause. Will only returns records between the start offset and the end offset. Signature Value Inputs 2 or more Outputs 1 Property Maintenance Maintains distribution and orderedness. Direct Output Order Unchanged from input.","title":"Fetch Operation"},{"location":"relations/logical_relations/#fetch-properties","text":"Property Description Required Input A relational input, typically with a desired orderedness property. Required Offset A positive integer. Declares the offset for retrieval of records. Optional, defaults to 0. Count A positive integer. Declares the number of records that should be returned. Required FetchRel Message message FetchRel { RelCommon common = 1 ; Rel input = 2 ; // the offset expressed in number of records int64 offset = 3 ; // the amount of records to return int64 count = 4 ; substrait.extensions.AdvancedExtension advanced_extension = 10 ; }","title":"Fetch Properties"},{"location":"relations/logical_relations/#aggregate-operation","text":"The aggregate operation groups input data on one or more sets of grouping keys, calculating each measure for each combination of grouping key. Signature Value Inputs 1 Outputs 1 Property Maintenance Maintains distribution if all distribution fields are contained in every grouping set. No orderedness guaranteed. Direct Output Order The list of distinct columns from each grouping set (ordered by their first appearance) followed by the list of measures in declaration order, followed by an i32 describing the associated particular grouping set the value is derived from (if applicable). In its simplest form, an aggregation has only measures. In this case, all records are folded into one, and a column is returned for each aggregate expression in the measures list. Grouping sets can be used for finer-grained control over which records are folded. Within a grouping set, two records will be folded together if and only if each expressions in the grouping set yields the same value for each. The values returned by the grouping sets will be returned as columns to the left of the columns for the aggregate expressions. If a grouping set contains no grouping expressions, all rows will be folded for that grouping set. It\u2019s possible to specify multiple grouping sets in a single aggregate operation. The grouping sets behave more or less independently, with each returned record belonging to one of the grouping sets. The values for the grouping expression columns that are not part of the grouping set for a particular record will be set to null. Two grouping expressions will be returned using the same column if they represent the protobuf messages describing the expressions are equal. The columns for grouping expressions that do not appear in all grouping sets will be nullable (regardless of the nullability of the type returned by the grouping expression) to accomodate the null insertion. To further disambiguate which record belongs to which grouping set, an aggregate relation with more than one grouping set receives an extra i32 column on the right-hand side. The value of this field will be the zero-based index of the grouping set that yielded the record. If at least one grouping expression is present, the aggregation is allowed to not have any aggregate expressions. An aggregate relation is invalid if it would yield zero columns.","title":"Aggregate Operation"},{"location":"relations/logical_relations/#aggregate-properties","text":"Property Description Required Input The relational input. Required Grouping Sets One or more grouping sets. Optional, required if no measures. Per Grouping Set A list of expression grouping that the aggregation measured should be calculated for. Optional. Measures A list of one or more aggregate expressions along with an optional filter. Optional, required if no grouping sets. AggregateRel Message message AggregateRel { RelCommon common = 1 ; // Input of the aggregation Rel input = 2 ; // A list of expression grouping that the aggregation measured should be calculated for. repeated Grouping groupings = 3 ; // A list of one or more aggregate expressions along with an optional filter. repeated Measure measures = 4 ; substrait.extensions.AdvancedExtension advanced_extension = 10 ; message Grouping { repeated Expression grouping_expressions = 1 ; } message Measure { AggregateFunction measure = 1 ; // An optional boolean expression that acts to filter which records are // included in the measure. True means include this record for calculation // within the measure. // Helps to support SUM(<c>) FILTER(WHERE...) syntax without masking opportunities for optimization Expression filter = 2 ; } }","title":"Aggregate Properties"},{"location":"relations/logical_relations/#write-operator","text":"The write operator is an operator that consumes one output and writes it to storage. A simple example would be writing Parquet files. It is expected that many types of writes will be added over time. Signature Value Inputs 1 Outputs 0 Property Maintenance N/A (no output) Direct Output Order N/A (no output)","title":"Write Operator"},{"location":"relations/logical_relations/#write-properties","text":"Property Description Required Definition The contents of the write property definition. Required Field names The names of all struct fields in breadth-first order. Required Masked Complex Expression The masking expression applied to the input record prior to write. Optional, defaults to all Rotation description fields A list of fields that can be used for stream description whenever a stream is reset. Optional, defaults to none. Rotation indicator An input field ID that describes when the current stream should be \u201crotated\u201d. Individual write definition types may support the ability to rotate the output into one or more streams. This could mean closing and opening a new file, finishing and restarting a TCP connection, etc. If a rotation indicator is available, it will be 0 except when a rotation should occur. Rotation indication are frequently defined by things like discrete partition values but could be done based on number of records or other arbitrary criteria. Optional, defaults to none.","title":"Write Properties"},{"location":"relations/logical_relations/#write-definition-types","text":"Write definition types are built by the community and added to the specification. This is a portion of specification that is expected to grow rapidly.","title":"Write Definition Types"},{"location":"relations/logical_relations/#virtual-table_1","text":"Property Description Required Name The in-memory name to give the dataset. Required Pin Whether it is okay to remove this dataset from memory or it should be kept in memory. Optional, defaults to false.","title":"Virtual Table"},{"location":"relations/logical_relations/#files-type_1","text":"Property Description Required Path A URI to write the data to. Supports the inclusion of field references that are listed as available in properties as a \u201crotation description field\u201d. Required Format Enumeration of available formats. Only current option is PARQUET. Required","title":"Files Type"},{"location":"relations/logical_relations/#discussion-points","text":"How to handle correlated operations?","title":"Discussion Points"},{"location":"relations/physical_relations/","text":"Physical Relations \u00b6 There is no true distinction between logical and physical operations in Substrait. By convention, certain operations are classified as physical, but all operations can be potentially used in any kind of plan. A particular set of transformations or target operators may (by convention) be considered the \u201cphysical plan\u201d but this is a characteristic of the system consuming substrait as opposed to a definition within Substrait. Hash Equijoin Operator \u00b6 The hash equijoin join operator will build a hash table out of the right input based on a set of join keys. It will then probe that hash table for incoming inputs, finding matches. Signature Value Inputs 2 Outputs 1 Property Maintenance Distribution is maintained. Orderedness of the left set is maintained in INNER join cases, otherwise it is eliminated. Direct Output Order Same as the Join operator. Hash Equijoin Properties \u00b6 Property Description Required Left Input A relational input. Required Right Input A relational input. Required Join Expression A boolean condition that describes whether each record from the left set \u201cmatch\u201d the record from the right set. The condition must only include the following operations: AND, ==, field references, is not distinct from. Field references correspond to the direct output order of the data. Required. Post Join Predicate An additional expression that can be used to reduce the output of the join operation post the equality condition. Minimizes the overhead of secondary join conditions that cannot be evaluated using the equijoin keys. Optional, defaults true. Join Type One of the join types defined in the Join operator. Required NLJ Operator \u00b6 The nested loop join operator does a join by holding the entire right input and then iterating over it using the left input, evaluating the join expression on the Cartesian product of all rows, only outputting rows where the expression is true. Will also include non-matching rows in the OUTER, LEFT and RIGHT operations per the join type requirements. Signature Value Inputs 2 Outputs 1 Property Maintenance Distribution is maintained. Orderedness is eliminated. Direct Output Order Same as the Join operator. NLJ Properties \u00b6 Property Description Required Left Input A relational input. Required Right Input A relational input. Required Join Expression A boolean condition that describes whether each record from the left set \u201cmatch\u201d the record from the right set. Optional. Defaults to true (a Cartesian join). Join Type One of the join types defined in the Join operator. Required Merge Equijoin Operator \u00b6 The merge equijoin does a join by taking advantage of two sets that are sorted on the join keys. This allows the join operation to be done in a streaming fashion. Signature Value Inputs 2 Outputs 1 Property Maintenance Distribution is maintained. Orderedness is eliminated. Direct Output Order Same as the Join operator. Merge Join Properties \u00b6 Property Description Required Left Input A relational input. Required Right Input A relational input. Required Join Expression A boolean condition that describes whether each record from the left set \u201cmatch\u201d the record from the right set. The condition must only include the following operations: AND, ==, field references, is not distinct from. Field references correspond to the direct output order of the data. Optional. Defaults to true (a Cartesian join). Post Join Predicate An additional expression that can be used to reduce the output of the join operation post the equality condition. Minimizes the overhead of secondary join conditions that cannot be evaluated using the equijoin keys. Optional, defaults true. Join Type One of the join types defined in the Join operator. Required Exchange Operator \u00b6 The exchange operator will redistribute data based on an exchange type definition. Applying this operation will lead to an output that presents the desired distribution. Signature Value Inputs 1 Outputs 1 Property Maintenance Orderedness is maintained. Distribution is overwritten based on configuration. Direct Output Order Order of the input. Exchange Types \u00b6 Type Description Scatter Distribute data using a system defined hashing function that considers one or more fields. For the same type of fields and same ordering of values, the same partition target should be identified for different ExchangeRels Single Bucket Define an expression that provides a single i32 bucket number. Optionally define whether the expression will only return values within the valid number of partition counts. If not, the system should modulo the return value to determine a target partition. Multi Bucket Define an expression that provides a List<i32> of bucket numbers. Optionally define whether the expression will only return values within the valid number of partition counts. If not, the system should modulo the return value to determine a target partition. The records should be sent to all bucket numbers provided by the expression. Broadcast Send all records to all partitions. Round Robin Send records to each target in sequence. Can follow either exact or approximate behavior. Approximate will attempt to balance the number of records sent to each destination but may not exactly distribute evenly and may send batches of records to each target before moving to the next. Exchange Properties \u00b6 Property Description Required Input The relational input. Required. Distribution Type One of the distribution types defined above. Required. Partition Count The number of partitions targeted for output. Optional. If not defined, implementation system should decide the number of partitions. Note that when not defined, single or multi bucket expressions should not be constrained to count. Expression Mapping Describes a relationship between each partition ID and the destination that partition should be sent to. Optional. A partition may be sent to 0..N locations. Value can either be a URI or arbitrary value. Merging Capture \u00b6 A receiving operation that will merge multiple ordered streams to maintain orderedness. Signature Value Inputs 1 Outputs 1 Property Maintenance Orderedness and distribution are maintained. Direct Output Order Order of the input. Merging Capture Properties \u00b6 Property Description Required Blocking Whether the merging should block incoming data. Blocking should be used carefully, based on whether a deadlock can be produced. Optional, defaults to false Simple Capture \u00b6 A receiving operation that will merge multiple streams in an arbitrary order. Signature Value Inputs 1 Outputs 1 Property Maintenance Orderness is empty after this operation. Distribution are maintained. Direct Output Order Order of the input. Naive Capture Properties \u00b6 Property Description Required Input The relational input. Required Top-N Operation \u00b6 The top-N operator reorders a dataset based on one or more identified sort fields as well as a sorting function. Rather than sort the entire dataset, the top-N will only maintain the total number of records required to ensure a limited output. A top-n is a combination of a logical sort and logical fetch operations. Signature Value Inputs 1 Outputs 1 Property Maintenance Will update orderedness property to the output of the sort operation. Distribution property only remapped based on emit. Direct Output Order The field order of the input. Top-N Properties \u00b6 Property Description Required Input The relational input. Required Sort Fields List of one or more fields to sort by. Uses the same properties as the orderedness property. One sort field required Offset A positive integer. Declares the offset for retrieval of records. Optional, defaults to 0. Count A positive integer. Declares the number of records that should be returned. Required Hash Aggregate Operation \u00b6 The hash aggregate operation maintains a hash table for each grouping set to coalesce equivalent tuples. Signature Value Inputs 1 Outputs 1 Property Maintenance Maintains distribution if all distribution fields are contained in every grouping set. No orderness guaranteed. Direct Output Order Same as defined by Aggregate operation. Hash Aggregate Properties \u00b6 Property Description Required Input The relational input. Required Grouping Sets One or more grouping sets. Optional, required if no measures. Per Grouping Set A list of expression grouping that the aggregation measured should be calculated for. Optional, defaults to 0. Measures A list of one or more aggregate expressions. Implementations may or may not support aggregate ordering expressions. Optional, required if no grouping sets. Streaming Aggregate Operation \u00b6 The streaming aggregate operation leverages data ordered by the grouping expressions to calculate data each grouping set tuple-by-tuple in streaming fashion. All grouping sets and orderings requested on each aggregate must be compatible to allow multiple grouping sets or aggregate orderings. Signature Value Inputs 1 Outputs 1 Property Maintenance Maintains distribution if all distribution fields are contained in every grouping set. Maintains input ordering. Direct Output Order Same as defined by Aggregate operation. Streaming Aggregate Properties \u00b6 Property Description Required Input The relational input. Required Grouping Sets One or more grouping sets. If multiple grouping sets are declared, sets must all be compatible with the input sortedness. Optional, required if no measures. Per Grouping Set A list of expression grouping that the aggregation measured should be calculated for. Optional, defaults to 0. Measures A list of one or more aggregate expressions. Aggregate expressions ordering requirements must be compatible with expected ordering. Optional, required if no grouping sets. Hashing Window Operation \u00b6 A window aggregate operation that will build hash tables for each distinct partition expression. Signature Value Inputs 1 Outputs 1 Property Maintenance Maintains distribution. Eliminates ordering. Direct Output Order Same as Project operator (input followed by each window expression). Hashing Window Properties \u00b6 Property Description Required Input The relational input. Required Window Expressions One or more window expressions. At least one required. Streaming Window Operation \u00b6 A window aggregate operation that relies on a partition/ordering sorted input. Signature Value Inputs 1 Outputs 1 Property Maintenance Maintains distribution. Eliminates ordering. Direct Output Order Same as Project operator (input followed by each window expression). Streaming Window Properties \u00b6 Property Description Required Input The relational input. Required Window Expressions One or more window expressions. Must be supported by the sortedness of the input. At least one required.","title":"Physical Relations"},{"location":"relations/physical_relations/#physical-relations","text":"There is no true distinction between logical and physical operations in Substrait. By convention, certain operations are classified as physical, but all operations can be potentially used in any kind of plan. A particular set of transformations or target operators may (by convention) be considered the \u201cphysical plan\u201d but this is a characteristic of the system consuming substrait as opposed to a definition within Substrait.","title":"Physical Relations"},{"location":"relations/physical_relations/#hash-equijoin-operator","text":"The hash equijoin join operator will build a hash table out of the right input based on a set of join keys. It will then probe that hash table for incoming inputs, finding matches. Signature Value Inputs 2 Outputs 1 Property Maintenance Distribution is maintained. Orderedness of the left set is maintained in INNER join cases, otherwise it is eliminated. Direct Output Order Same as the Join operator.","title":"Hash Equijoin Operator"},{"location":"relations/physical_relations/#hash-equijoin-properties","text":"Property Description Required Left Input A relational input. Required Right Input A relational input. Required Join Expression A boolean condition that describes whether each record from the left set \u201cmatch\u201d the record from the right set. The condition must only include the following operations: AND, ==, field references, is not distinct from. Field references correspond to the direct output order of the data. Required. Post Join Predicate An additional expression that can be used to reduce the output of the join operation post the equality condition. Minimizes the overhead of secondary join conditions that cannot be evaluated using the equijoin keys. Optional, defaults true. Join Type One of the join types defined in the Join operator. Required","title":"Hash Equijoin Properties"},{"location":"relations/physical_relations/#nlj-operator","text":"The nested loop join operator does a join by holding the entire right input and then iterating over it using the left input, evaluating the join expression on the Cartesian product of all rows, only outputting rows where the expression is true. Will also include non-matching rows in the OUTER, LEFT and RIGHT operations per the join type requirements. Signature Value Inputs 2 Outputs 1 Property Maintenance Distribution is maintained. Orderedness is eliminated. Direct Output Order Same as the Join operator.","title":"NLJ Operator"},{"location":"relations/physical_relations/#nlj-properties","text":"Property Description Required Left Input A relational input. Required Right Input A relational input. Required Join Expression A boolean condition that describes whether each record from the left set \u201cmatch\u201d the record from the right set. Optional. Defaults to true (a Cartesian join). Join Type One of the join types defined in the Join operator. Required","title":"NLJ Properties"},{"location":"relations/physical_relations/#merge-equijoin-operator","text":"The merge equijoin does a join by taking advantage of two sets that are sorted on the join keys. This allows the join operation to be done in a streaming fashion. Signature Value Inputs 2 Outputs 1 Property Maintenance Distribution is maintained. Orderedness is eliminated. Direct Output Order Same as the Join operator.","title":"Merge Equijoin Operator"},{"location":"relations/physical_relations/#merge-join-properties","text":"Property Description Required Left Input A relational input. Required Right Input A relational input. Required Join Expression A boolean condition that describes whether each record from the left set \u201cmatch\u201d the record from the right set. The condition must only include the following operations: AND, ==, field references, is not distinct from. Field references correspond to the direct output order of the data. Optional. Defaults to true (a Cartesian join). Post Join Predicate An additional expression that can be used to reduce the output of the join operation post the equality condition. Minimizes the overhead of secondary join conditions that cannot be evaluated using the equijoin keys. Optional, defaults true. Join Type One of the join types defined in the Join operator. Required","title":"Merge Join Properties"},{"location":"relations/physical_relations/#exchange-operator","text":"The exchange operator will redistribute data based on an exchange type definition. Applying this operation will lead to an output that presents the desired distribution. Signature Value Inputs 1 Outputs 1 Property Maintenance Orderedness is maintained. Distribution is overwritten based on configuration. Direct Output Order Order of the input.","title":"Exchange Operator"},{"location":"relations/physical_relations/#exchange-types","text":"Type Description Scatter Distribute data using a system defined hashing function that considers one or more fields. For the same type of fields and same ordering of values, the same partition target should be identified for different ExchangeRels Single Bucket Define an expression that provides a single i32 bucket number. Optionally define whether the expression will only return values within the valid number of partition counts. If not, the system should modulo the return value to determine a target partition. Multi Bucket Define an expression that provides a List<i32> of bucket numbers. Optionally define whether the expression will only return values within the valid number of partition counts. If not, the system should modulo the return value to determine a target partition. The records should be sent to all bucket numbers provided by the expression. Broadcast Send all records to all partitions. Round Robin Send records to each target in sequence. Can follow either exact or approximate behavior. Approximate will attempt to balance the number of records sent to each destination but may not exactly distribute evenly and may send batches of records to each target before moving to the next.","title":"Exchange Types"},{"location":"relations/physical_relations/#exchange-properties","text":"Property Description Required Input The relational input. Required. Distribution Type One of the distribution types defined above. Required. Partition Count The number of partitions targeted for output. Optional. If not defined, implementation system should decide the number of partitions. Note that when not defined, single or multi bucket expressions should not be constrained to count. Expression Mapping Describes a relationship between each partition ID and the destination that partition should be sent to. Optional. A partition may be sent to 0..N locations. Value can either be a URI or arbitrary value.","title":"Exchange Properties"},{"location":"relations/physical_relations/#merging-capture","text":"A receiving operation that will merge multiple ordered streams to maintain orderedness. Signature Value Inputs 1 Outputs 1 Property Maintenance Orderedness and distribution are maintained. Direct Output Order Order of the input.","title":"Merging Capture"},{"location":"relations/physical_relations/#merging-capture-properties","text":"Property Description Required Blocking Whether the merging should block incoming data. Blocking should be used carefully, based on whether a deadlock can be produced. Optional, defaults to false","title":"Merging Capture Properties"},{"location":"relations/physical_relations/#simple-capture","text":"A receiving operation that will merge multiple streams in an arbitrary order. Signature Value Inputs 1 Outputs 1 Property Maintenance Orderness is empty after this operation. Distribution are maintained. Direct Output Order Order of the input.","title":"Simple Capture"},{"location":"relations/physical_relations/#naive-capture-properties","text":"Property Description Required Input The relational input. Required","title":"Naive Capture Properties"},{"location":"relations/physical_relations/#top-n-operation","text":"The top-N operator reorders a dataset based on one or more identified sort fields as well as a sorting function. Rather than sort the entire dataset, the top-N will only maintain the total number of records required to ensure a limited output. A top-n is a combination of a logical sort and logical fetch operations. Signature Value Inputs 1 Outputs 1 Property Maintenance Will update orderedness property to the output of the sort operation. Distribution property only remapped based on emit. Direct Output Order The field order of the input.","title":"Top-N Operation"},{"location":"relations/physical_relations/#top-n-properties","text":"Property Description Required Input The relational input. Required Sort Fields List of one or more fields to sort by. Uses the same properties as the orderedness property. One sort field required Offset A positive integer. Declares the offset for retrieval of records. Optional, defaults to 0. Count A positive integer. Declares the number of records that should be returned. Required","title":"Top-N Properties"},{"location":"relations/physical_relations/#hash-aggregate-operation","text":"The hash aggregate operation maintains a hash table for each grouping set to coalesce equivalent tuples. Signature Value Inputs 1 Outputs 1 Property Maintenance Maintains distribution if all distribution fields are contained in every grouping set. No orderness guaranteed. Direct Output Order Same as defined by Aggregate operation.","title":"Hash Aggregate Operation"},{"location":"relations/physical_relations/#hash-aggregate-properties","text":"Property Description Required Input The relational input. Required Grouping Sets One or more grouping sets. Optional, required if no measures. Per Grouping Set A list of expression grouping that the aggregation measured should be calculated for. Optional, defaults to 0. Measures A list of one or more aggregate expressions. Implementations may or may not support aggregate ordering expressions. Optional, required if no grouping sets.","title":"Hash Aggregate Properties"},{"location":"relations/physical_relations/#streaming-aggregate-operation","text":"The streaming aggregate operation leverages data ordered by the grouping expressions to calculate data each grouping set tuple-by-tuple in streaming fashion. All grouping sets and orderings requested on each aggregate must be compatible to allow multiple grouping sets or aggregate orderings. Signature Value Inputs 1 Outputs 1 Property Maintenance Maintains distribution if all distribution fields are contained in every grouping set. Maintains input ordering. Direct Output Order Same as defined by Aggregate operation.","title":"Streaming Aggregate Operation"},{"location":"relations/physical_relations/#streaming-aggregate-properties","text":"Property Description Required Input The relational input. Required Grouping Sets One or more grouping sets. If multiple grouping sets are declared, sets must all be compatible with the input sortedness. Optional, required if no measures. Per Grouping Set A list of expression grouping that the aggregation measured should be calculated for. Optional, defaults to 0. Measures A list of one or more aggregate expressions. Aggregate expressions ordering requirements must be compatible with expected ordering. Optional, required if no grouping sets.","title":"Streaming Aggregate Properties"},{"location":"relations/physical_relations/#hashing-window-operation","text":"A window aggregate operation that will build hash tables for each distinct partition expression. Signature Value Inputs 1 Outputs 1 Property Maintenance Maintains distribution. Eliminates ordering. Direct Output Order Same as Project operator (input followed by each window expression).","title":"Hashing Window Operation"},{"location":"relations/physical_relations/#hashing-window-properties","text":"Property Description Required Input The relational input. Required Window Expressions One or more window expressions. At least one required.","title":"Hashing Window Properties"},{"location":"relations/physical_relations/#streaming-window-operation","text":"A window aggregate operation that relies on a partition/ordering sorted input. Signature Value Inputs 1 Outputs 1 Property Maintenance Maintains distribution. Eliminates ordering. Direct Output Order Same as Project operator (input followed by each window expression).","title":"Streaming Window Operation"},{"location":"relations/physical_relations/#streaming-window-properties","text":"Property Description Required Input The relational input. Required Window Expressions One or more window expressions. Must be supported by the sortedness of the input. At least one required.","title":"Streaming Window Properties"},{"location":"relations/user_defined_relations/","text":"User Defined Relations \u00b6 Pending","title":"User Defined Relations"},{"location":"relations/user_defined_relations/#user-defined-relations","text":"Pending","title":"User Defined Relations"},{"location":"serialization/binary_serialization/","text":"Binary Serialization \u00b6 Substrait can be serialized into a protobuf -based binary representation. The proto schema/IDL files can be found on GitHub . Proto files are place in the io.substrait namespace for C++/Java and the Substrait.Protobuf namespace for C#. Plan \u00b6 The main top-level object used to communicate a Substrait plan using protobuf is a Plan message. The plan message is composed of a set of data structures that minimize repetition in the serialization along with one (or more) Relation trees. Plan Message message Plan { // a list of yaml specifications this plan may depend on repeated substrait.extensions.SimpleExtensionURI extension_uris = 1 ; // a list of extensions this plan may depend on repeated substrait.extensions.SimpleExtensionDeclaration extensions = 2 ; // one or more relation trees that are associated with this plan. repeated PlanRel relations = 3 ; // additional extensions associated with this plan. substrait.extensions.AdvancedExtension advanced_extensions = 4 ; // A list of com.google.Any entities that this plan may use. Can be used to // warn if some embedded message types are unknown. Note that this list may // include message types that are ignorable (optimizations) or that are // unused. In many cases, a consumer may be able to work with a plan even if // one or more message types defined here are unknown. repeated string expected_type_urls = 5 ; } Extensions \u00b6 Protobuf supports both simple and advanced extensions. Simple extensions are declared at the plan level and advanced extensions are declared at multiple levels of messages within the plan. Simple Extensions \u00b6 For simple extensions, a plan references the URIs associated with the simple extensions to provide additional plan capabilities. These URIs will list additional relevant information for the plan. Simple extensions within a plan are split into three components: an extension URI, an extension declaration and a number of references. Extension URI : A unique identifier for the extension pointing to a YAML document specifying one or more specific extensions. Declares an anchor that can be used in extension declarations. Extension Declaration : A specific extension within a single YAML document. The declaration combines a reference to the associated Extension URI along with a unique key identifying the specific item within that YAML document (see Function Signature Compound Names ). It also defines a declaration anchor. The anchor is a plan-specific unique value that the producer creates as a key to be referenced elsewhere. Extension Reference : A specific instance or use of an extension declaration within the plan body. Extension URIs and declarations are encapsulated in the top level of the plan. Extension declarations are then referenced throughout the body of the plan itself. The exact structure of these references will depend on the extension point being used, but they will always include the extension\u2019s anchor (or key). For example, all scalar function expressions contain references to an extension declaration which defines the semantics of the function. Simple Extension URI message SimpleExtensionURI { // A surrogate key used in the context of a single plan used to reference the // URI associated with an extension. uint32 extension_uri_anchor = 1 ; // The URI where this extension YAML can be retrieved. This is the \"namespace\" // of this extension. string uri = 2 ; } Once the YAML file URI anchor is defined, the anchor will be referenced by zero or more SimpleExtensionDefinition s. For each simple extension definition, an anchor is defined for that specific extension entity. This anchor is then referenced to within lower-level primitives (functions, etc.) to reference that specific extension. Message properties are named *_anchor where the anchor is defined and *_reference when referencing the anchor. For example function_anchor and function_reference . Simple Extension Declaration message SimpleExtensionDeclaration { oneof mapping_type { ExtensionType extension_type = 1 ; ExtensionTypeVariation extension_type_variation = 2 ; ExtensionFunction extension_function = 3 ; } // Describes a Type message ExtensionType { // references the extension_uri_anchor defined for a specific extension URI. uint32 extension_uri_reference = 1 ; // A surrogate key used in the context of a single plan to reference a // specific extension type uint32 type_anchor = 2 ; // the name of the type in the defined extension YAML. string name = 3 ; } message ExtensionTypeVariation { // references the extension_uri_anchor defined for a specific extension URI. uint32 extension_uri_reference = 1 ; // A surrogate key used in the context of a single plan to reference a // specific type variation uint32 type_variation_anchor = 2 ; // the name of the type in the defined extension YAML. string name = 3 ; } message ExtensionFunction { // references the extension_uri_anchor defined for a specific extension URI. uint32 extension_uri_reference = 1 ; // A surrogate key used in the context of a single plan to reference a // specific function uint32 function_anchor = 2 ; // A simple name if there is only one impl for the function within the YAML. // A compound name, referencing that includes type short names if there is // more than one impl per name in the YAML. string name = 3 ; } } Note Anchors only have meaning within a single plan and exist simply to reduce plan size. They are not some form of global identifier. Different plans may use different anchors for the same specific functions, types, type variations, etc. Note It is valid for a plan to include SimpleExtensionURI s and/or SimpleExtensionDeclaration s that are not referenced directly. Advanced Extensions \u00b6 Substrait protobuf exposes a special object in multiple places in the representation to expose extension capabilities. Extensions are done via this object. Extensions are separated into main concepts: Advanced Extension Type Description Optimization A change to the plan that may help some consumers work more efficiently with the plan. These properties should be propagated through plan pipelines where possible but do not impact the meaning of the plan. A consumer can safely ignore these properties. Enhancement A change to the plan that functionally changes the behavior of the plan. Use these sparingly as they will impact plan interoperability. Advanced Extension Protobuf message AdvancedExtension { // An optimization is helpful information that don't influence semantics. May // be ignored by a consumer. google.protobuf.Any optimization = 1 ; // An enhancement alter semantics. Cannot be ignored by a consumer. google.protobuf.Any enhancement = 2 ; } Capabilities \u00b6 When two systems exchanging Substrait plans want to understand each other\u2019s capabilities, they may exchange a Capabilities message. The capabilities message provides information on the set of simple and advanced extensions that the system supports. Capabilities Message message Capabilities { // List of Substrait versions this system supports repeated string substrait_versions = 1 ; // list of com.google.Any message types this system supports for advanced // extensions. repeated string advanced_extension_type_urls = 2 ; // list of simple extensions this system supports. repeated SimpleExtension simple_extensions = 3 ; message SimpleExtension { string uri = 1 ; repeated string function_keys = 2 ; repeated string type_keys = 3 ; repeated string type_variation_keys = 4 ; } } Protobuf Rationale \u00b6 The binary format of Substrait is designed to be easy to work with in many languages. A key requirement is that someone can take the binary format IDL and use standard tools to build a set of primitives that are easy to work with in any of a number of languages. This allows communities to build and use Substrait using only a binary IDL and the specification (and allows the Substrait project to avoid being required to build libraries for each language to work with the specification). There are several binary IDLs that exist today. The key requirements for Substrait are the following: Strongly typed IDL schema language High-quality well-supported and idiomatic bindings/compilers for key languages (Python, Javascript, C++, Go, Rust, Java) Compact serial representation The primary formats that exist that roughly qualify under these requirements include: Protobuf, Thrift, Flatbuf, Avro, Cap\u2019N\u2019Proto. Protobuf was chosen due to its clean typing system and large number of high quality language bindings. The binary serialization IDLs can be found on GitHub and are sampled throughout the documentation.","title":"Binary Serialization"},{"location":"serialization/binary_serialization/#binary-serialization","text":"Substrait can be serialized into a protobuf -based binary representation. The proto schema/IDL files can be found on GitHub . Proto files are place in the io.substrait namespace for C++/Java and the Substrait.Protobuf namespace for C#.","title":"Binary Serialization"},{"location":"serialization/binary_serialization/#plan","text":"The main top-level object used to communicate a Substrait plan using protobuf is a Plan message. The plan message is composed of a set of data structures that minimize repetition in the serialization along with one (or more) Relation trees. Plan Message message Plan { // a list of yaml specifications this plan may depend on repeated substrait.extensions.SimpleExtensionURI extension_uris = 1 ; // a list of extensions this plan may depend on repeated substrait.extensions.SimpleExtensionDeclaration extensions = 2 ; // one or more relation trees that are associated with this plan. repeated PlanRel relations = 3 ; // additional extensions associated with this plan. substrait.extensions.AdvancedExtension advanced_extensions = 4 ; // A list of com.google.Any entities that this plan may use. Can be used to // warn if some embedded message types are unknown. Note that this list may // include message types that are ignorable (optimizations) or that are // unused. In many cases, a consumer may be able to work with a plan even if // one or more message types defined here are unknown. repeated string expected_type_urls = 5 ; }","title":"Plan"},{"location":"serialization/binary_serialization/#extensions","text":"Protobuf supports both simple and advanced extensions. Simple extensions are declared at the plan level and advanced extensions are declared at multiple levels of messages within the plan.","title":"Extensions"},{"location":"serialization/binary_serialization/#simple-extensions","text":"For simple extensions, a plan references the URIs associated with the simple extensions to provide additional plan capabilities. These URIs will list additional relevant information for the plan. Simple extensions within a plan are split into three components: an extension URI, an extension declaration and a number of references. Extension URI : A unique identifier for the extension pointing to a YAML document specifying one or more specific extensions. Declares an anchor that can be used in extension declarations. Extension Declaration : A specific extension within a single YAML document. The declaration combines a reference to the associated Extension URI along with a unique key identifying the specific item within that YAML document (see Function Signature Compound Names ). It also defines a declaration anchor. The anchor is a plan-specific unique value that the producer creates as a key to be referenced elsewhere. Extension Reference : A specific instance or use of an extension declaration within the plan body. Extension URIs and declarations are encapsulated in the top level of the plan. Extension declarations are then referenced throughout the body of the plan itself. The exact structure of these references will depend on the extension point being used, but they will always include the extension\u2019s anchor (or key). For example, all scalar function expressions contain references to an extension declaration which defines the semantics of the function. Simple Extension URI message SimpleExtensionURI { // A surrogate key used in the context of a single plan used to reference the // URI associated with an extension. uint32 extension_uri_anchor = 1 ; // The URI where this extension YAML can be retrieved. This is the \"namespace\" // of this extension. string uri = 2 ; } Once the YAML file URI anchor is defined, the anchor will be referenced by zero or more SimpleExtensionDefinition s. For each simple extension definition, an anchor is defined for that specific extension entity. This anchor is then referenced to within lower-level primitives (functions, etc.) to reference that specific extension. Message properties are named *_anchor where the anchor is defined and *_reference when referencing the anchor. For example function_anchor and function_reference . Simple Extension Declaration message SimpleExtensionDeclaration { oneof mapping_type { ExtensionType extension_type = 1 ; ExtensionTypeVariation extension_type_variation = 2 ; ExtensionFunction extension_function = 3 ; } // Describes a Type message ExtensionType { // references the extension_uri_anchor defined for a specific extension URI. uint32 extension_uri_reference = 1 ; // A surrogate key used in the context of a single plan to reference a // specific extension type uint32 type_anchor = 2 ; // the name of the type in the defined extension YAML. string name = 3 ; } message ExtensionTypeVariation { // references the extension_uri_anchor defined for a specific extension URI. uint32 extension_uri_reference = 1 ; // A surrogate key used in the context of a single plan to reference a // specific type variation uint32 type_variation_anchor = 2 ; // the name of the type in the defined extension YAML. string name = 3 ; } message ExtensionFunction { // references the extension_uri_anchor defined for a specific extension URI. uint32 extension_uri_reference = 1 ; // A surrogate key used in the context of a single plan to reference a // specific function uint32 function_anchor = 2 ; // A simple name if there is only one impl for the function within the YAML. // A compound name, referencing that includes type short names if there is // more than one impl per name in the YAML. string name = 3 ; } } Note Anchors only have meaning within a single plan and exist simply to reduce plan size. They are not some form of global identifier. Different plans may use different anchors for the same specific functions, types, type variations, etc. Note It is valid for a plan to include SimpleExtensionURI s and/or SimpleExtensionDeclaration s that are not referenced directly.","title":"Simple Extensions"},{"location":"serialization/binary_serialization/#advanced-extensions","text":"Substrait protobuf exposes a special object in multiple places in the representation to expose extension capabilities. Extensions are done via this object. Extensions are separated into main concepts: Advanced Extension Type Description Optimization A change to the plan that may help some consumers work more efficiently with the plan. These properties should be propagated through plan pipelines where possible but do not impact the meaning of the plan. A consumer can safely ignore these properties. Enhancement A change to the plan that functionally changes the behavior of the plan. Use these sparingly as they will impact plan interoperability. Advanced Extension Protobuf message AdvancedExtension { // An optimization is helpful information that don't influence semantics. May // be ignored by a consumer. google.protobuf.Any optimization = 1 ; // An enhancement alter semantics. Cannot be ignored by a consumer. google.protobuf.Any enhancement = 2 ; }","title":"Advanced Extensions"},{"location":"serialization/binary_serialization/#capabilities","text":"When two systems exchanging Substrait plans want to understand each other\u2019s capabilities, they may exchange a Capabilities message. The capabilities message provides information on the set of simple and advanced extensions that the system supports. Capabilities Message message Capabilities { // List of Substrait versions this system supports repeated string substrait_versions = 1 ; // list of com.google.Any message types this system supports for advanced // extensions. repeated string advanced_extension_type_urls = 2 ; // list of simple extensions this system supports. repeated SimpleExtension simple_extensions = 3 ; message SimpleExtension { string uri = 1 ; repeated string function_keys = 2 ; repeated string type_keys = 3 ; repeated string type_variation_keys = 4 ; } }","title":"Capabilities"},{"location":"serialization/binary_serialization/#protobuf-rationale","text":"The binary format of Substrait is designed to be easy to work with in many languages. A key requirement is that someone can take the binary format IDL and use standard tools to build a set of primitives that are easy to work with in any of a number of languages. This allows communities to build and use Substrait using only a binary IDL and the specification (and allows the Substrait project to avoid being required to build libraries for each language to work with the specification). There are several binary IDLs that exist today. The key requirements for Substrait are the following: Strongly typed IDL schema language High-quality well-supported and idiomatic bindings/compilers for key languages (Python, Javascript, C++, Go, Rust, Java) Compact serial representation The primary formats that exist that roughly qualify under these requirements include: Protobuf, Thrift, Flatbuf, Avro, Cap\u2019N\u2019Proto. Protobuf was chosen due to its clean typing system and large number of high quality language bindings. The binary serialization IDLs can be found on GitHub and are sampled throughout the documentation.","title":"Protobuf Rationale"},{"location":"serialization/text_serialization/","text":"Text Serialization \u00b6 To maximize the new user experience, it is important for Substrait to have a text representation of plans. This allows people to experiment with basic tooling. Building simple CLI tools that do things like SQL > Plan and Plan > SQL or REPL plan construction can all be done relatively straightforwardly with a text representation. The recommended text serialization format is JSON. Since the text format is not designed for performance, the format can be produced to maximize readability. This also allows nice symmetry between the construction of plans and the configuration of various extensions such as function signatures and user defined types. To ensure the JSON is valid, the object will be defined using the OpenApi 3.1 specification . This not only allows strong validation, the OpenApi specification enables code generators to be easily used to produce plans in many languages. While JSON will be used for much of the plan serialization, Substrait uses a custom simplistic grammar for record level expressions. While one can construct an equation such as (10 + 5)/2 using a tree of function and literal objects, it is much more human-readable to consume a plan when the information is written similarly to the way one typically consumes scalar expressions. This grammar will be maintained in an ANTLR grammar (targetable to multiple programming languages) and is also planned to be supported via JSON schema definition format tag so that the grammar can be validated as part of the schema validation.","title":"Text Serialization"},{"location":"serialization/text_serialization/#text-serialization","text":"To maximize the new user experience, it is important for Substrait to have a text representation of plans. This allows people to experiment with basic tooling. Building simple CLI tools that do things like SQL > Plan and Plan > SQL or REPL plan construction can all be done relatively straightforwardly with a text representation. The recommended text serialization format is JSON. Since the text format is not designed for performance, the format can be produced to maximize readability. This also allows nice symmetry between the construction of plans and the configuration of various extensions such as function signatures and user defined types. To ensure the JSON is valid, the object will be defined using the OpenApi 3.1 specification . This not only allows strong validation, the OpenApi specification enables code generators to be easily used to produce plans in many languages. While JSON will be used for much of the plan serialization, Substrait uses a custom simplistic grammar for record level expressions. While one can construct an equation such as (10 + 5)/2 using a tree of function and literal objects, it is much more human-readable to consume a plan when the information is written similarly to the way one typically consumes scalar expressions. This grammar will be maintained in an ANTLR grammar (targetable to multiple programming languages) and is also planned to be supported via JSON schema definition format tag so that the grammar can be validated as part of the schema validation.","title":"Text Serialization"},{"location":"spec/specification/","text":"Specification \u00b6 Process \u00b6 The goal of this project is initially to establish a well-defined specification. Once established, new versions of the specification will follow a normal development/release process. To provide something to peruse while clarifying an openness to the community during the initial development of the specification, we plan to follow the following steps for development of the specification. We will use GitHub branches to describe each of these steps and patches will be proposed to be moved from one branch to the next to allow review of documents while still having strawmen to start with. The steps are: Empty - No outline has been produced. A sketch needs to be produced for people to react and iterate on. Sketch - Something has been written but should serve more as a conceptual backing for what should be achieved in this part of the specification. No collaboration or consensus has occurred. This will be discussed and iterated on until an initial WIP version can be patched. The WIP version will be held in a PR to iterate on until it is committed to the WIP branch of the repository. WIP - An initial version that multiple contributors have agreed to has been produced for this portion of the specification. Any user is welcome to propose additional changes or discussions regarding this component, but it now represents a community intention. Commit - Believed to be a well-formed plan for this portion of the specification. Documents that have had no outstanding reviews for 14 days will be moved from WIP to commit. Changes can still be made, but the section should no longer be under constant revision. (This status is more for external observers to understand the progress of the specification than something that influences internal project process.) Once all portions of the specification have been moved to commit (or eliminated), the specification will move to an initial version number. To try to get a working end-to-end model as quickly as possible, a small number of items have been prioritized. The set of components outlined here are proposed as a mechanism for having bite-size review/discussion chunks to make forward progress. Components \u00b6 Priority Status Section Description 1 wip Simple Types A way to describe the set of basic types that will be operated on within a plan. Only includes simple types such as integers and doubles (nothing configurable or compound). wip Compound Types Expression of types that go beyond simple scalar values. Key concepts here include: configurable types such as fixed length and numeric types as well as compound types such as structs, maps, lists, etc. wip Type Variations Physical variations to base types. sketch User Defined Types Extensions that can be defined for specific IR producers/consumers. 2 sketch Field References Expressions to identify which portions of a record should be operated on. 3 sketch Scalar Functions Description of how functions are specified. Concepts include arguments, variadic functions, output type derivation, etc. sketch Scalar Function List A list of well-known canonical functions in YAML format. sketch Specialized Record Expressions Specialized expression types that are more naturally expressed outside the function paradigm. Examples include items such as if/then/else and switch statements. sketch Aggregate Functions Functions that are expressed in aggregation operations. Examples include things such as SUM, COUNT, etc. Operations take many records and collapse them into a single (possibly compound) value. sketch Window Functions Functions that relate a record to a set of encompassing records. Examples in SQL include RANK, NTILE, etc. empty Table Functions Functions that convert one or more values from an input record into 0..N output records. Example include operations such as explode, pos-explode, etc. sketch User Defined Functions Reusable named functions that are built beyond the core specification. Implementations are typically registered thorough external means (drop a file in a directory, send a special command with implementation, etc.) sketch Embedded Functions Functions implementations embedded directly within the plan. Frequently used in data science workflows where business logic is interspersed with standard operations. 4 sketch Relation Basics Basic concepts around relational algebra, record emit and properties. sketch Logical Relations Common relational operations used in compute plans including project, join, aggregation, etc. sketch Physical Relations Specific execution sub-variations of common relational operations that describe have multiple unique physical variants associated with a single logical operation. Examples include hash join, merge join, nested loop join, etc. empty User Defined Relations Installed and reusable relational operations customized to a particular platform. empty Embedded Relations Relational operations where plans contain the \u201cmachine code\u201d to directly execute the necessary operations. 5 sketch Text Serialization A human producible & consumable representation of the plan specification. 6 sketch Binary Serialization A high performance & compact binary representation of the plan specification.","title":"Specification"},{"location":"spec/specification/#specification","text":"","title":"Specification"},{"location":"spec/specification/#process","text":"The goal of this project is initially to establish a well-defined specification. Once established, new versions of the specification will follow a normal development/release process. To provide something to peruse while clarifying an openness to the community during the initial development of the specification, we plan to follow the following steps for development of the specification. We will use GitHub branches to describe each of these steps and patches will be proposed to be moved from one branch to the next to allow review of documents while still having strawmen to start with. The steps are: Empty - No outline has been produced. A sketch needs to be produced for people to react and iterate on. Sketch - Something has been written but should serve more as a conceptual backing for what should be achieved in this part of the specification. No collaboration or consensus has occurred. This will be discussed and iterated on until an initial WIP version can be patched. The WIP version will be held in a PR to iterate on until it is committed to the WIP branch of the repository. WIP - An initial version that multiple contributors have agreed to has been produced for this portion of the specification. Any user is welcome to propose additional changes or discussions regarding this component, but it now represents a community intention. Commit - Believed to be a well-formed plan for this portion of the specification. Documents that have had no outstanding reviews for 14 days will be moved from WIP to commit. Changes can still be made, but the section should no longer be under constant revision. (This status is more for external observers to understand the progress of the specification than something that influences internal project process.) Once all portions of the specification have been moved to commit (or eliminated), the specification will move to an initial version number. To try to get a working end-to-end model as quickly as possible, a small number of items have been prioritized. The set of components outlined here are proposed as a mechanism for having bite-size review/discussion chunks to make forward progress.","title":"Process"},{"location":"spec/specification/#components","text":"Priority Status Section Description 1 wip Simple Types A way to describe the set of basic types that will be operated on within a plan. Only includes simple types such as integers and doubles (nothing configurable or compound). wip Compound Types Expression of types that go beyond simple scalar values. Key concepts here include: configurable types such as fixed length and numeric types as well as compound types such as structs, maps, lists, etc. wip Type Variations Physical variations to base types. sketch User Defined Types Extensions that can be defined for specific IR producers/consumers. 2 sketch Field References Expressions to identify which portions of a record should be operated on. 3 sketch Scalar Functions Description of how functions are specified. Concepts include arguments, variadic functions, output type derivation, etc. sketch Scalar Function List A list of well-known canonical functions in YAML format. sketch Specialized Record Expressions Specialized expression types that are more naturally expressed outside the function paradigm. Examples include items such as if/then/else and switch statements. sketch Aggregate Functions Functions that are expressed in aggregation operations. Examples include things such as SUM, COUNT, etc. Operations take many records and collapse them into a single (possibly compound) value. sketch Window Functions Functions that relate a record to a set of encompassing records. Examples in SQL include RANK, NTILE, etc. empty Table Functions Functions that convert one or more values from an input record into 0..N output records. Example include operations such as explode, pos-explode, etc. sketch User Defined Functions Reusable named functions that are built beyond the core specification. Implementations are typically registered thorough external means (drop a file in a directory, send a special command with implementation, etc.) sketch Embedded Functions Functions implementations embedded directly within the plan. Frequently used in data science workflows where business logic is interspersed with standard operations. 4 sketch Relation Basics Basic concepts around relational algebra, record emit and properties. sketch Logical Relations Common relational operations used in compute plans including project, join, aggregation, etc. sketch Physical Relations Specific execution sub-variations of common relational operations that describe have multiple unique physical variants associated with a single logical operation. Examples include hash join, merge join, nested loop join, etc. empty User Defined Relations Installed and reusable relational operations customized to a particular platform. empty Embedded Relations Relational operations where plans contain the \u201cmachine code\u201d to directly execute the necessary operations. 5 sketch Text Serialization A human producible & consumable representation of the plan specification. 6 sketch Binary Serialization A high performance & compact binary representation of the plan specification.","title":"Components"},{"location":"spec/technology_principles/","text":"Technology Principles \u00b6 Provide a good suite of well-specified common functionality in databases and data science applications. Make it easy for users to privately or publicly extend the representation to support specialized/custom operations. Produce something that is language agnostic and requires minimal work to start developing against in a new language. Drive towards a common format that avoids specialization for single favorite producer or consumer. Establish clear delineation between specifications that MUST be respected to and those that can be optionally ignored. Establish a forgiving compatibility approach and versioning scheme that supports cross-version compatibility in maximum number of cases. Minimize the need for consumer intelligence by excluding concepts like overloading, type coercion, implicit casting, field name handling, etc. (Note: this is weak and should be better stated.) Decomposability/severability: A particular producer or consumer should be able to produce or consume only a subset of the specification and interact well with any other Substrait system as long the specific operations requested fit within the subset of specification supported by the counter system.","title":"Technology Principles"},{"location":"spec/technology_principles/#technology-principles","text":"Provide a good suite of well-specified common functionality in databases and data science applications. Make it easy for users to privately or publicly extend the representation to support specialized/custom operations. Produce something that is language agnostic and requires minimal work to start developing against in a new language. Drive towards a common format that avoids specialization for single favorite producer or consumer. Establish clear delineation between specifications that MUST be respected to and those that can be optionally ignored. Establish a forgiving compatibility approach and versioning scheme that supports cross-version compatibility in maximum number of cases. Minimize the need for consumer intelligence by excluding concepts like overloading, type coercion, implicit casting, field name handling, etc. (Note: this is weak and should be better stated.) Decomposability/severability: A particular producer or consumer should be able to produce or consume only a subset of the specification and interact well with any other Substrait system as long the specific operations requested fit within the subset of specification supported by the counter system.","title":"Technology Principles"},{"location":"spec/versioning/","text":"Versioning \u00b6 As an interface specification, the goal of Substrait is to reach a point where (breaking) changes will never need to happen again, or at least be few and far between. By analogy, Apache Arrow\u2019s in-memory format specification has stayed functionally constant, despite many major library versions being released. However, we\u2019re not there yet. When we believe that we\u2019ve reached this point, we will signal this by releasing version 1.0.0. Until then, we will remain in the 0.x.x version regime. Despite this, we strive to maintain backward compatibility for both the binary representation and the text representation by means of deprecation. When a breaking change cannot be reasonably avoided, we may remove previously deprecated fields. All deprecated fields will be removed for the 1.0.0 release. Substrait uses semantic versioning for its version numbers, with the addition that, during 0.x.y, we increment the x digit for breaking changes and new features, and the y digit for fixes and other nonfunctional changes. The release process is currently automated and makes a new release every week, provided something has changed on the main branch since the previous release. This release cadence will likely be slowed down as stability increases over time. Conventional commits are used to distinguish between breaking changes, new features, and fixes, and GitHub actions are used to verify that there are indeed no breaking protobuf changes in a commit, unless the commit message states this.","title":"Versioning"},{"location":"spec/versioning/#versioning","text":"As an interface specification, the goal of Substrait is to reach a point where (breaking) changes will never need to happen again, or at least be few and far between. By analogy, Apache Arrow\u2019s in-memory format specification has stayed functionally constant, despite many major library versions being released. However, we\u2019re not there yet. When we believe that we\u2019ve reached this point, we will signal this by releasing version 1.0.0. Until then, we will remain in the 0.x.x version regime. Despite this, we strive to maintain backward compatibility for both the binary representation and the text representation by means of deprecation. When a breaking change cannot be reasonably avoided, we may remove previously deprecated fields. All deprecated fields will be removed for the 1.0.0 release. Substrait uses semantic versioning for its version numbers, with the addition that, during 0.x.y, we increment the x digit for breaking changes and new features, and the y digit for fixes and other nonfunctional changes. The release process is currently automated and makes a new release every week, provided something has changed on the main branch since the previous release. This release cadence will likely be slowed down as stability increases over time. Conventional commits are used to distinguish between breaking changes, new features, and fixes, and GitHub actions are used to verify that there are indeed no breaking protobuf changes in a commit, unless the commit message states this.","title":"Versioning"},{"location":"types/type_classes/","text":"Type Classes \u00b6 In Substrait, the \u201cclass\u201d of a type, not to be confused with the concept from object-oriented programming, defines the set of non-null values that instances of a type may assume. Implementations of a Substrait type must support at least this set of values, but may include more; for example, an i8 could be represented using the same in-memory format as an i32 , as long as functions operating on i8 values within [-128..127] behave as specified (in this case, this means 8-bit overflow must work as expected). Operating on values outside the specified range is unspecified behavior. Simple Types \u00b6 Simple type classes are those that don\u2019t support any form of configuration. For simplicity, any generic type that has only a small number of discrete implementations is declared directly, as opposed to via configuration. Type Name Description Protobuf representation for literals boolean A value that is either True or False. bool i8 A signed integer within [-128..127], typically represented as an 8-bit two\u2019s complement number. int32 i16 A signed integer within [-32,768..32,767], typically represented as a 16-bit two\u2019s complement number. int32 i32 A signed integer within [-2147483648..2,147,483,647], typically represented as a 32-bit two\u2019s complement number. int32 i64 A signed integer within [\u22129,223,372,036,854,775,808..9,223,372,036,854,775,807], typically represented as a 64-bit two\u2019s complement number. int64 fp32 A 4-byte single-precision floating point number with range as defined here . float fp64 An 8-byte double-precision floating point number with range as defined here . double string A unicode string of text, [0..2,147,483,647] UTF-8 bytes in length. string binary A binary value, [0..2,147,483,647] bytes in length. binary timestamp A naive timestamp within [1000-01-01 00:00:00.000000..9999-12-31 23:59:59.999999], with microsecond precision. Does not include timezone information and can thus not be unambiguously mapped to a moment on the timeline without context. Similar to naive datetime in Python. int64 microseconds since 1970-01-01 00:00:00.000000 (in an unspecified timezone) timestamp_tz A timezone-aware timestamp within [1000-01-01 00:00:00.000000 UTC..9999-12-31 23:59:59.999999 UTC], with microsecond precision. Similar to aware datetime in Python. int64 microseconds since 1970-01-01 00:00:00.000000 UTC date A date within [1000-01-01..9999-12-31]. int32 days since 1970-01-01 time A time since the beginning of any day. Range of [0..86,399,999,999] microseconds; leap seconds need not be supported. int64 microseconds past midnight interval_year Interval year to month. Supports a range of [-10,000..10,000] years with month precision (= [-120,000..120,000] months). Usually stored as separate integers for years and months, but only the total number of months is significant, i.e. 1y 0m is considered equal to 0y 12m or 1001y -12000m . int32 years and int32 months, with the added constraint that each component can never independently specify more than 10,000 years, even if the components have opposite signs (e.g. -10000y 200000m is not allowed) interval_day Interval day to second. Supports a range of [-3,650,000..3,650,000] days with microsecond precision (= [-315,360,000,000,000,000..315,360,000,000,000,000] microseconds). Usually stored as separate integers for various components, but only the total number of microseconds is significant, i.e. 1d 0s is considered equal to 0d 86400s . int32 days, int32 seconds, and int32 microseconds, with the added constraint that each component can never independently specify more than 10,000 years, even if the components have opposite signs (e.g. 3650001d -86400s 0us is not allowed) uuid A universally-unique identifier composed of 128 bits. Typically presented to users in the following hexadecimal format: c48ffa9e-64f4-44cb-ae47-152b4e60e77b . Any 128-bit value is allowed, without specific adherence to RFC4122. 16-byte binary Compound Types \u00b6 Compound type classes are type classes that need to be configured by means of a parameter pack. Type Name Description Protobuf representation for literals FIXEDCHAR<L> A fixed-length unicode string of L characters. L must be within [1..2,147,483,647]. L-character string VARCHAR<L> A unicode string of at most L characters.L must be within [1..2,147,483,647]. string with at most L characters FIXEDBINARY<L> A binary string of L bytes. When casting, values shorter than L are padded with zeros, and values longer than L are right-trimmed. L-byte bytes DECIMAL<P, S> A fixed-precision decimal value having precision (P, number of digits) <= 38 and scale (S, number of fractional digits) 0 <= S <= P. 16-byte bytes representing a little-endian 128-bit integer, to be divided by 10^S to get the decimal value STRUCT<T1,\u2026,Tn> A list of types in a defined order. repeated Literal , types matching T1..Tn NSTRUCT<N:T1,\u2026,N:Tn> Pseudo-type : A struct that maps unique names to value types. Each name is a UTF-8-encoded string. Each value can have a distinct type. Note that NSTRUCT is actually a pseudo-type, because Substrait\u2019s core type system is based entirely on ordinal positions, not named fields. Nonetheless, when working with systems outside Substrait, names are important. n/a LIST<T> A list of values of type T. The list can be between [0..2,147,483,647] values in length. repeated Literal , all types matching T MAP<K, V> An unordered list of type K keys with type V values. repeated KeyValue (in turn two Literal s), all key types matching K and all value types matching V User-Defined Types \u00b6 User-defined type classes can be created using a combination of pre-defined types. User-defined types are defined as part of simple extensions . An extension can declare an arbitrary number of user defined extension types. A YAML example of an extension type is below: name : point structure : longitude : i32 latitude : i32 This declares a new type (namespaced to the associated YAML file) called \u201cpoint\u201d. This type is composed of two i32 values named longitude and latitude. Once a type has been declared, it can be used in function declarations. [TBD: should field references be allowed to dereference the components of a user defined type?] Literals for user-defined types are represented using protobuf Any messages. Compound User-Defined Types \u00b6 User-defined types may be turned into compound types by requiring parameters to be passed to them. The supported \u201cmeta-types\u201d for parameters are data types (like those used in LIST , MAP , and STRUCT ), booleans, integers, enumerations, and strings. Using parameters, we could redefine \u201cpoint\u201d with different types of coordinates. For example: name : point parameters : - name : T description : | The type used for the longitude and latitude components of the point. type : dataType or: name : point parameters : - name : coordinate_type type : enumeration options : - integer - double or: name : point parameters : - name : LONG type : dataType - name : LAT type : dataType We can\u2019t specify the internal structure in this case, because there is currently no support for derived types in the structure. The allowed range can be limited for integer parameters. For example: name : vector parameters : - name : T type : dataType - name : dimensions type : integer min : 2 max : 3 This specifies a vector that can be either 2- or 3-dimensional. Note however that it\u2019s not currently possible to put constraints on data type, string, or (technically) boolean parameters. Similar to function arguments, the last parameter may be specified to be variadic, allowing it to be specified one or more times instead of only once. For example: name : union parameters : - name : T type : dataType variadic : true This defines a type that can be parameterized with one or more other data types, for example union<i32, i64> but also union<bool> . Zero or more is also possible, by making the last argument optional: name : tuple parameters : - name : T type : dataType optional : true variadic : true This would also allow for tuple<> , to define a zero-tuple.","title":"Type Classes"},{"location":"types/type_classes/#type-classes","text":"In Substrait, the \u201cclass\u201d of a type, not to be confused with the concept from object-oriented programming, defines the set of non-null values that instances of a type may assume. Implementations of a Substrait type must support at least this set of values, but may include more; for example, an i8 could be represented using the same in-memory format as an i32 , as long as functions operating on i8 values within [-128..127] behave as specified (in this case, this means 8-bit overflow must work as expected). Operating on values outside the specified range is unspecified behavior.","title":"Type Classes"},{"location":"types/type_classes/#simple-types","text":"Simple type classes are those that don\u2019t support any form of configuration. For simplicity, any generic type that has only a small number of discrete implementations is declared directly, as opposed to via configuration. Type Name Description Protobuf representation for literals boolean A value that is either True or False. bool i8 A signed integer within [-128..127], typically represented as an 8-bit two\u2019s complement number. int32 i16 A signed integer within [-32,768..32,767], typically represented as a 16-bit two\u2019s complement number. int32 i32 A signed integer within [-2147483648..2,147,483,647], typically represented as a 32-bit two\u2019s complement number. int32 i64 A signed integer within [\u22129,223,372,036,854,775,808..9,223,372,036,854,775,807], typically represented as a 64-bit two\u2019s complement number. int64 fp32 A 4-byte single-precision floating point number with range as defined here . float fp64 An 8-byte double-precision floating point number with range as defined here . double string A unicode string of text, [0..2,147,483,647] UTF-8 bytes in length. string binary A binary value, [0..2,147,483,647] bytes in length. binary timestamp A naive timestamp within [1000-01-01 00:00:00.000000..9999-12-31 23:59:59.999999], with microsecond precision. Does not include timezone information and can thus not be unambiguously mapped to a moment on the timeline without context. Similar to naive datetime in Python. int64 microseconds since 1970-01-01 00:00:00.000000 (in an unspecified timezone) timestamp_tz A timezone-aware timestamp within [1000-01-01 00:00:00.000000 UTC..9999-12-31 23:59:59.999999 UTC], with microsecond precision. Similar to aware datetime in Python. int64 microseconds since 1970-01-01 00:00:00.000000 UTC date A date within [1000-01-01..9999-12-31]. int32 days since 1970-01-01 time A time since the beginning of any day. Range of [0..86,399,999,999] microseconds; leap seconds need not be supported. int64 microseconds past midnight interval_year Interval year to month. Supports a range of [-10,000..10,000] years with month precision (= [-120,000..120,000] months). Usually stored as separate integers for years and months, but only the total number of months is significant, i.e. 1y 0m is considered equal to 0y 12m or 1001y -12000m . int32 years and int32 months, with the added constraint that each component can never independently specify more than 10,000 years, even if the components have opposite signs (e.g. -10000y 200000m is not allowed) interval_day Interval day to second. Supports a range of [-3,650,000..3,650,000] days with microsecond precision (= [-315,360,000,000,000,000..315,360,000,000,000,000] microseconds). Usually stored as separate integers for various components, but only the total number of microseconds is significant, i.e. 1d 0s is considered equal to 0d 86400s . int32 days, int32 seconds, and int32 microseconds, with the added constraint that each component can never independently specify more than 10,000 years, even if the components have opposite signs (e.g. 3650001d -86400s 0us is not allowed) uuid A universally-unique identifier composed of 128 bits. Typically presented to users in the following hexadecimal format: c48ffa9e-64f4-44cb-ae47-152b4e60e77b . Any 128-bit value is allowed, without specific adherence to RFC4122. 16-byte binary","title":"Simple Types"},{"location":"types/type_classes/#compound-types","text":"Compound type classes are type classes that need to be configured by means of a parameter pack. Type Name Description Protobuf representation for literals FIXEDCHAR<L> A fixed-length unicode string of L characters. L must be within [1..2,147,483,647]. L-character string VARCHAR<L> A unicode string of at most L characters.L must be within [1..2,147,483,647]. string with at most L characters FIXEDBINARY<L> A binary string of L bytes. When casting, values shorter than L are padded with zeros, and values longer than L are right-trimmed. L-byte bytes DECIMAL<P, S> A fixed-precision decimal value having precision (P, number of digits) <= 38 and scale (S, number of fractional digits) 0 <= S <= P. 16-byte bytes representing a little-endian 128-bit integer, to be divided by 10^S to get the decimal value STRUCT<T1,\u2026,Tn> A list of types in a defined order. repeated Literal , types matching T1..Tn NSTRUCT<N:T1,\u2026,N:Tn> Pseudo-type : A struct that maps unique names to value types. Each name is a UTF-8-encoded string. Each value can have a distinct type. Note that NSTRUCT is actually a pseudo-type, because Substrait\u2019s core type system is based entirely on ordinal positions, not named fields. Nonetheless, when working with systems outside Substrait, names are important. n/a LIST<T> A list of values of type T. The list can be between [0..2,147,483,647] values in length. repeated Literal , all types matching T MAP<K, V> An unordered list of type K keys with type V values. repeated KeyValue (in turn two Literal s), all key types matching K and all value types matching V","title":"Compound Types"},{"location":"types/type_classes/#user-defined-types","text":"User-defined type classes can be created using a combination of pre-defined types. User-defined types are defined as part of simple extensions . An extension can declare an arbitrary number of user defined extension types. A YAML example of an extension type is below: name : point structure : longitude : i32 latitude : i32 This declares a new type (namespaced to the associated YAML file) called \u201cpoint\u201d. This type is composed of two i32 values named longitude and latitude. Once a type has been declared, it can be used in function declarations. [TBD: should field references be allowed to dereference the components of a user defined type?] Literals for user-defined types are represented using protobuf Any messages.","title":"User-Defined Types"},{"location":"types/type_classes/#compound-user-defined-types","text":"User-defined types may be turned into compound types by requiring parameters to be passed to them. The supported \u201cmeta-types\u201d for parameters are data types (like those used in LIST , MAP , and STRUCT ), booleans, integers, enumerations, and strings. Using parameters, we could redefine \u201cpoint\u201d with different types of coordinates. For example: name : point parameters : - name : T description : | The type used for the longitude and latitude components of the point. type : dataType or: name : point parameters : - name : coordinate_type type : enumeration options : - integer - double or: name : point parameters : - name : LONG type : dataType - name : LAT type : dataType We can\u2019t specify the internal structure in this case, because there is currently no support for derived types in the structure. The allowed range can be limited for integer parameters. For example: name : vector parameters : - name : T type : dataType - name : dimensions type : integer min : 2 max : 3 This specifies a vector that can be either 2- or 3-dimensional. Note however that it\u2019s not currently possible to put constraints on data type, string, or (technically) boolean parameters. Similar to function arguments, the last parameter may be specified to be variadic, allowing it to be specified one or more times instead of only once. For example: name : union parameters : - name : T type : dataType variadic : true This defines a type that can be parameterized with one or more other data types, for example union<i32, i64> but also union<bool> . Zero or more is also possible, by making the last argument optional: name : tuple parameters : - name : T type : dataType optional : true variadic : true This would also allow for tuple<> , to define a zero-tuple.","title":"Compound User-Defined Types"},{"location":"types/type_parsing/","text":"Type Syntax Parsing \u00b6 In many places, it is useful to have a human-readable string representation of data types. Substrait has a custom syntax for type declaration. The basic structure of a type declaration is: name?[variation]<param0,...,paramN> The components of this expression are: Component Description Required Name Each type has a name. A type is expressed by providing a name. This name can be expressed in arbitrary case (e.g. varchar and vArChAr are equivalent). Nullability indicator A type is either non-nullable or nullable. To express nullability, a type name is appended with a question mark. Optional, defaults to non-nullable Variation When expressing a type, a user can define the type based on a type variation. Some systems use type variations to describe different underlying representations of the same data type. This is expressed as a bracketed integer such as [2]. Optional, defaults to [0] Parameters Compound types may have one or more configurable properties. The two main types of properties are integer and type properties. The parameters for each type correspond to a list of known properties associated with a type as declared in the order defined in the type specification. For compound types (types that contain types), the data type syntax will include nested type declarations. The one exception is structs, which are further outlined below. Required where parameters are defined Grammars \u00b6 It is relatively easy in most languages to produce simple parser & emitters for the type syntax. To make that easier, Substrait also includes an ANTLR [impl pending] grammar to ease consumption and production of types. Structs & Named Structs \u00b6 Structs are unique from other types because they have an arbitrary number of parameters. The parameters can also include one or two subproperties. Struct parsing is thus declared in the following two ways: # Struct struct?[variation]<type0, type1,..., typeN> # Named Struct nstruct?[variation]<name0:type0, name1:type1,..., nameN:typeN> In the normal (non-named) form, struct declares a set of types that are fields within that struct. In the named struct form, the parameters are formed by tuples of names + types, delineated by a colon. Names that are composed only of numbers and letters can be left unquoted. For other characters, names should be quoted with double quotes and use backslash for double-quote escaping. Note, in core Substrait algebra, fields are unnamed and references are always based on zero-index ordinal positions. However, data inputs must declare name-to-ordinal mappings and outputs must declare ordinal-to-name mappings. As such, Substrait also provides a named struct which is a pseudo-type that is useful for human consumption. Outside these places, most structs in a Substrait plan are structs, not named-structs. The two cannot be used interchangeably.","title":"Type Syntax Parsing"},{"location":"types/type_parsing/#type-syntax-parsing","text":"In many places, it is useful to have a human-readable string representation of data types. Substrait has a custom syntax for type declaration. The basic structure of a type declaration is: name?[variation]<param0,...,paramN> The components of this expression are: Component Description Required Name Each type has a name. A type is expressed by providing a name. This name can be expressed in arbitrary case (e.g. varchar and vArChAr are equivalent). Nullability indicator A type is either non-nullable or nullable. To express nullability, a type name is appended with a question mark. Optional, defaults to non-nullable Variation When expressing a type, a user can define the type based on a type variation. Some systems use type variations to describe different underlying representations of the same data type. This is expressed as a bracketed integer such as [2]. Optional, defaults to [0] Parameters Compound types may have one or more configurable properties. The two main types of properties are integer and type properties. The parameters for each type correspond to a list of known properties associated with a type as declared in the order defined in the type specification. For compound types (types that contain types), the data type syntax will include nested type declarations. The one exception is structs, which are further outlined below. Required where parameters are defined","title":"Type Syntax Parsing"},{"location":"types/type_parsing/#grammars","text":"It is relatively easy in most languages to produce simple parser & emitters for the type syntax. To make that easier, Substrait also includes an ANTLR [impl pending] grammar to ease consumption and production of types.","title":"Grammars"},{"location":"types/type_parsing/#structs-named-structs","text":"Structs are unique from other types because they have an arbitrary number of parameters. The parameters can also include one or two subproperties. Struct parsing is thus declared in the following two ways: # Struct struct?[variation]<type0, type1,..., typeN> # Named Struct nstruct?[variation]<name0:type0, name1:type1,..., nameN:typeN> In the normal (non-named) form, struct declares a set of types that are fields within that struct. In the named struct form, the parameters are formed by tuples of names + types, delineated by a colon. Names that are composed only of numbers and letters can be left unquoted. For other characters, names should be quoted with double quotes and use backslash for double-quote escaping. Note, in core Substrait algebra, fields are unnamed and references are always based on zero-index ordinal positions. However, data inputs must declare name-to-ordinal mappings and outputs must declare ordinal-to-name mappings. As such, Substrait also provides a named struct which is a pseudo-type that is useful for human consumption. Outside these places, most structs in a Substrait plan are structs, not named-structs. The two cannot be used interchangeably.","title":"Structs &amp; Named Structs"},{"location":"types/type_system/","text":"Type System \u00b6 Substrait tries to cover the most common types used in data manipulation. Types beyond this common core may be represented using simple extensions . Substrait types fundamentally consist of four components: Component Condition Examples Description Class Always i8 , string , STRUCT , extensions Together with the parameter pack, describes the set of non-null values supported by the type. Subdivided into simple and compound type classes. Nullability Always Either NULLABLE ( ? suffix) or REQUIRED (no suffix) Describes whether values of this type can be null. Note that null is considered to be a special value of a nullable type, rather than the only value of a special null type. Variation Always No suffix or explicitly [0] (system-preferred), or an extension Allows different variations of the same type class to exist in a system at a time, usually distinguished by in-memory format. Parameters Compound types only <10, 2> (for DECIMAL ), <i32, string> (for STRUCT ) Some combination of zero or more data types or integers. The expected set of parameters and the significance of each parameter depends on the type class. Refer to Type Parsing for a description of the syntax used to describe types. Note that Substrait employs a strict type system without any coercion rules. All changes in types must be made explicit via cast expressions .","title":"Type System"},{"location":"types/type_system/#type-system","text":"Substrait tries to cover the most common types used in data manipulation. Types beyond this common core may be represented using simple extensions . Substrait types fundamentally consist of four components: Component Condition Examples Description Class Always i8 , string , STRUCT , extensions Together with the parameter pack, describes the set of non-null values supported by the type. Subdivided into simple and compound type classes. Nullability Always Either NULLABLE ( ? suffix) or REQUIRED (no suffix) Describes whether values of this type can be null. Note that null is considered to be a special value of a nullable type, rather than the only value of a special null type. Variation Always No suffix or explicitly [0] (system-preferred), or an extension Allows different variations of the same type class to exist in a system at a time, usually distinguished by in-memory format. Parameters Compound types only <10, 2> (for DECIMAL ), <i32, string> (for STRUCT ) Some combination of zero or more data types or integers. The expected set of parameters and the significance of each parameter depends on the type class. Refer to Type Parsing for a description of the syntax used to describe types. Note that Substrait employs a strict type system without any coercion rules. All changes in types must be made explicit via cast expressions .","title":"Type System"},{"location":"types/type_variations/","text":"Type Variations \u00b6 Type variations may be used to represent differences in representation between different consumers. For example, an engine might support dictionary encoding for a string, or could be using either a row-wise or columnar representation of a struct. All variations of a type are expected to have the same semantics when operated on by functions or other expressions. All variations except the \u201csystem-preferred\u201d variation (a.k.a. [0] , see Type Parsing ) must be defined using simple extensions . The key properties of these variations are: Property Description Base Type Class The type class that this variation belongs to. Name The name used to reference this type. Should be unique within type variations for this parent type within a simple extension. Description A human description of the purpose of this type variation. Function Behavior INHERITS or SEPARATE : whether functions that support the system-preferred variation implicitly also support this variation, or whether functions should be resolved independently. For example, if one has the function add(i8,i8) defined and then defines an i8 variation, this determines whether the i8 variation can be bound to the base add operation (inherits) or whether a specialized version of add needs to be defined specifically for this variation (separate). Defaults to inherits.","title":"Type Variations"},{"location":"types/type_variations/#type-variations","text":"Type variations may be used to represent differences in representation between different consumers. For example, an engine might support dictionary encoding for a string, or could be using either a row-wise or columnar representation of a struct. All variations of a type are expected to have the same semantics when operated on by functions or other expressions. All variations except the \u201csystem-preferred\u201d variation (a.k.a. [0] , see Type Parsing ) must be defined using simple extensions . The key properties of these variations are: Property Description Base Type Class The type class that this variation belongs to. Name The name used to reference this type. Should be unique within type variations for this parent type within a simple extension. Description A human description of the purpose of this type variation. Function Behavior INHERITS or SEPARATE : whether functions that support the system-preferred variation implicitly also support this variation, or whether functions should be resolved independently. For example, if one has the function add(i8,i8) defined and then defines an i8 variation, this determines whether the i8 variation can be bound to the base add operation (inherits) or whether a specialized version of add needs to be defined specifically for this variation (separate). Defaults to inherits.","title":"Type Variations"}]}